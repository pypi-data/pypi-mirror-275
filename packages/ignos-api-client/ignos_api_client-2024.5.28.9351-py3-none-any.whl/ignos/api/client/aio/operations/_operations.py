# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, List, Optional, Type, TypeVar, Union, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ...operations._operations import (
    build_alerts_alert_notification_access_request,
    build_alerts_delete_machine_inactivity_subscription_request,
    build_alerts_get_machine_inactivity_alert_type_request,
    build_alerts_list_machine_inactivity_subscriptions_request,
    build_alerts_subscribe_to_machine_inactivity_alerts_request,
    build_alerts_update_machine_inactivity_alert_subscription_request,
    build_assets_create_asset_request,
    build_assets_get_asset_by_id_request,
    build_assets_get_asset_structure_by_id_request,
    build_assets_list_assets_request,
    build_assets_list_machines_request,
    build_assets_search_assets_request,
    build_assets_update_asset_request,
    build_azure_regions_list_azure_regions_request,
    build_booking_cancel_booking_request,
    build_booking_create_booking_request,
    build_booking_finish_delivery_request,
    build_booking_get_booking_request,
    build_booking_list_bookings_request,
    build_booking_start_delivery_request,
    build_booking_update_booking_request,
    build_cdf_get_cdf_config_request,
    build_cdf_update_cdf_config_request,
    build_cnc_file_transfer_create_upload_cam_transfer_info_request,
    build_cnc_file_transfer_get_cam_transfer_request,
    build_cnc_file_transfer_get_transfer_status_request,
    build_cnc_file_transfer_start_cam_transfer_to_machine_from_temp_upload_request,
    build_cnc_file_transfer_start_cam_transfer_to_machine_request,
    build_cnc_file_transfer_start_cnc_machine_operation_transfer_to_cloud_request,
    build_cnc_file_transfer_start_cnc_machine_operation_transfer_to_machine_request,
    build_cnc_setup_agent_create_upload_programs_info_request,
    build_cnc_setup_agent_get_cnc_agent_config_request,
    build_cnc_setup_agent_set_transfer_status_request,
    build_cnc_setup_copy_cnc_machine_operations_request,
    build_cnc_setup_copy_cnc_part_request,
    build_cnc_setup_copy_tools_cnc_machine_request,
    build_cnc_setup_create_cnc_machine_operation_request,
    build_cnc_setup_create_cnc_machine_operation_tool_request,
    build_cnc_setup_create_cnc_machine_request,
    build_cnc_setup_create_cnc_machine_tool_request,
    build_cnc_setup_create_cnc_part_request,
    build_cnc_setup_create_upload_attachment_info_request,
    build_cnc_setup_create_upload_part_drawing_info_request,
    build_cnc_setup_create_upload_programs_info_request,
    build_cnc_setup_delete_cnc_machine_communication_settings_request,
    build_cnc_setup_delete_cnc_machine_operation_attachment_request,
    build_cnc_setup_delete_cnc_machine_operation_program_request,
    build_cnc_setup_delete_cnc_machine_operation_program_version_request,
    build_cnc_setup_delete_cnc_machine_operation_request,
    build_cnc_setup_delete_cnc_machine_operation_tool_image_request,
    build_cnc_setup_delete_cnc_machine_operation_tool_request,
    build_cnc_setup_delete_cnc_machine_request,
    build_cnc_setup_delete_cnc_machine_tool_image_request,
    build_cnc_setup_delete_cnc_machine_tool_request,
    build_cnc_setup_delete_cnc_part_drawing_request,
    build_cnc_setup_delete_cnc_part_request,
    build_cnc_setup_get_cnc_machine_communication_settings_request,
    build_cnc_setup_get_cnc_machine_operation_request,
    build_cnc_setup_get_cnc_machine_request,
    build_cnc_setup_get_cnc_part_drawing_request,
    build_cnc_setup_get_cnc_part_request,
    build_cnc_setup_import_operation_with_tools_request,
    build_cnc_setup_list_cnc_machine_operations_attachments_request,
    build_cnc_setup_list_cnc_machine_operations_by_part_request,
    build_cnc_setup_list_cnc_machine_operations_programs_archive_request,
    build_cnc_setup_list_cnc_machine_operations_programs_request,
    build_cnc_setup_list_cnc_machine_operations_request,
    build_cnc_setup_list_cnc_machines_request,
    build_cnc_setup_list_cnc_parts_request,
    build_cnc_setup_list_cnc_tool_by_cnc_machine_request,
    build_cnc_setup_list_cnc_tool_by_operation_request,
    build_cnc_setup_list_cnc_tool_types_request,
    build_cnc_setup_post_list_cnc_machine_operations_request,
    build_cnc_setup_post_list_cnc_parts_request,
    build_cnc_setup_update_cnc_machine_communication_settings_request,
    build_cnc_setup_update_cnc_machine_operation_program_request,
    build_cnc_setup_update_cnc_machine_operation_program_version_request,
    build_cnc_setup_update_cnc_machine_operation_request,
    build_cnc_setup_update_cnc_machine_operation_tool_request,
    build_cnc_setup_update_cnc_machine_request,
    build_cnc_setup_update_cnc_machine_tool_request,
    build_cnc_setup_update_cnc_part_request,
    build_cnc_setup_upload_cnc_machine_tool_image_request,
    build_cnc_setup_upload_operation_cnc_tool_image_request,
    build_companies_list_production_companies_request,
    build_companies_select_production_company_request,
    build_countries_list_countries_request,
    build_customer_orders_get_customer_order_request,
    build_customer_orders_list_customer_order_lines_request,
    build_customer_orders_list_customer_orders_request,
    build_customer_orders_post_list_customer_orders_request,
    build_customer_orders_upsert_customer_order_line_request,
    build_customer_orders_upsert_customer_order_request,
    build_customers_create_customer_mapping_request,
    build_customers_deactivate_customer_request,
    build_customers_delete_customer_mappings_request,
    build_customers_delete_customer_request,
    build_customers_get_current_customer_request,
    build_customers_list_customer_groups_request,
    build_customers_list_customers_request,
    build_customers_post_list_customers_request,
    build_customers_upsert_customer_request,
    build_document_types_activate_document_type_request,
    build_document_types_create_document_type_request,
    build_document_types_deactivate_document_type_request,
    build_document_types_delete_document_type_request,
    build_document_types_get_document_type_request,
    build_document_types_list_all_document_rule_types_request,
    build_document_types_list_document_generators_request,
    build_document_types_list_document_type_rules_request,
    build_document_types_list_document_types_request,
    build_document_types_update_document_type_request,
    build_document_types_update_document_type_rules_request,
    build_documents_check_if_imported_document_exists_request,
    build_documents_import_document_request,
    build_electrical_create_electrical_iot_config_request,
    build_electrical_delete_electrical_iot_config_request,
    build_electrical_list_electrical_data_configs_request,
    build_electrical_list_electrical_source_types_request,
    build_external_accept_supplier_invite_request,
    build_external_access_create_company_user_request,
    build_external_access_delete_company_customer_request,
    build_external_access_delete_company_user_request,
    build_external_access_list_company_customers_request,
    build_external_access_list_roles_request,
    build_external_access_list_users_request,
    build_external_access_update_company_user_request,
    build_external_list_companies_request,
    build_external_list_invites_request,
    build_external_services_get_credential_request,
    build_links_create_link_request,
    build_links_delete_link_request,
    build_links_get_all_link_scopes_request,
    build_links_get_all_links_request,
    build_locations_search_locations_request,
    build_locations_suggestions_locations_request,
    build_machine_alarms_count_machine_alarms_request,
    build_machine_alarms_get_machine_alarm_details_request,
    build_machine_alarms_list_alarm_severity_occurrences_request,
    build_machine_alarms_list_alarms_per_machine_request,
    build_machine_alarms_list_machine_alarms_request,
    build_machine_utilization_get_factory_utilization_request,
    build_machine_utilization_get_machine_states_summary_request,
    build_machine_utilization_get_machine_utilization_request,
    build_machine_utilization_get_machine_utilizations_request,
    build_machine_utilization_get_utilization_details_for_machine_request,
    build_machine_utilization_list_machine_states_request,
    build_machine_utilization_list_machine_uptimes_today_request,
    build_machine_utilization_list_power_on_utilization_datapoints_request,
    build_machines_create_machine_group_request,
    build_machines_create_machine_without_resource_request,
    build_machines_create_resource_with_machine_request,
    build_machines_create_resource_without_machine_request,
    build_machines_delete_machine_group_request,
    build_machines_get_machine_erp_data_request,
    build_machines_get_machine_states_summary_request,
    build_machines_get_machine_utilization_summary_request,
    build_machines_list_current_machine_operators_request,
    build_machines_list_current_machine_states_request,
    build_machines_list_machine_erp_data_request,
    build_machines_list_machine_groups_request,
    build_machines_list_machine_states_request,
    build_machines_list_machines_request,
    build_machines_update_machine_group_request,
    build_me_get_current_user_request,
    build_me_get_my_apps_request,
    build_me_set_is_beta_tester_request,
    build_me_update_current_user_last_seen_request,
    build_measurement_form_schemas_add_resource_type_for_needs_generator_request,
    build_measurement_form_schemas_create_draft_version_request,
    build_measurement_form_schemas_create_measurement_form_mapping_request,
    build_measurement_form_schemas_create_measurement_form_request,
    build_measurement_form_schemas_create_measurement_form_schema_from_need_request,
    build_measurement_form_schemas_create_measurement_form_schema_link_request,
    build_measurement_form_schemas_create_schema_element_request,
    build_measurement_form_schemas_delete_measurement_form_instance_schema_feedback_request,
    build_measurement_form_schemas_delete_measurement_form_mapping_request,
    build_measurement_form_schemas_delete_measurement_form_schema_link_request,
    build_measurement_form_schemas_delete_measurment_form_schemas_not_needed_request,
    build_measurement_form_schemas_delete_resource_type_for_needs_generator_request,
    build_measurement_form_schemas_get_measurement_form_customer_settings_request,
    build_measurement_form_schemas_get_measurement_form_import_status_request,
    build_measurement_form_schemas_get_measurement_form_instance_schema_feedback_request,
    build_measurement_form_schemas_get_measurement_form_mapping_request,
    build_measurement_form_schemas_get_measurement_form_mapping_suggestion_request,
    build_measurement_form_schemas_get_measurement_form_schema_request,
    build_measurement_form_schemas_get_measurement_form_settings_request,
    build_measurement_form_schemas_import_measurement_form_schema_request,
    build_measurement_form_schemas_is_mapping_from_previous_version_required_request,
    build_measurement_form_schemas_list_frequencies_request,
    build_measurement_form_schemas_list_linkable_measurement_form_schemas_request,
    build_measurement_form_schemas_list_measurement_form_instance_schema_feedback_request,
    build_measurement_form_schemas_list_measurement_form_mappings_from_schema_request,
    build_measurement_form_schemas_list_measurement_form_needs_request,
    build_measurement_form_schemas_list_measurment_form_schemas_not_needed_request,
    build_measurement_form_schemas_list_measurment_form_schemas_request,
    build_measurement_form_schemas_list_measurment_form_schemas_with_history_request,
    build_measurement_form_schemas_list_resource_types_for_needs_generator_request,
    build_measurement_form_schemas_post_list_linkable_measurement_form_schemas_request,
    build_measurement_form_schemas_post_list_measurement_form_instance_schema_feedback_request,
    build_measurement_form_schemas_post_list_measurement_form_needs_request,
    build_measurement_form_schemas_post_list_measurement_form_schemas_not_needed_request,
    build_measurement_form_schemas_post_list_measurement_form_schemas_request,
    build_measurement_form_schemas_post_list_measurement_form_schemas_with_history_request,
    build_measurement_form_schemas_release_schema_request,
    build_measurement_form_schemas_revoke_schema_request,
    build_measurement_form_schemas_set_measurement_form_instance_schema_feedback_user_request,
    build_measurement_form_schemas_set_measurement_form_mapping_balloons_request,
    build_measurement_form_schemas_set_measurement_form_mapping_balloons_v2_request,
    build_measurement_form_schemas_set_measurement_form_need_as_not_needed_request,
    build_measurement_form_schemas_set_measurement_form_need_user_request,
    build_measurement_form_schemas_update_measurement_form_customer_settings_request,
    build_measurement_form_schemas_update_measurement_form_schema_request,
    build_measurement_form_schemas_update_measurement_form_settings_request,
    build_measurement_form_schemas_update_schema_grouped_elements_request,
    build_measurement_form_schemas_upload_need_drawing_request,
    build_measurement_form_schemas_upload_schema_attachment_request,
    build_measurement_form_schemas_upload_schema_drawing_request,
    build_measurement_forms_instances_approve_measurement_form_instance_request,
    build_measurement_forms_instances_batch_insert_values_request,
    build_measurement_forms_instances_cancel_measurement_form_instance_request,
    build_measurement_forms_instances_complete_measurement_form_instance_request,
    build_measurement_forms_instances_create_measurement_form_instance_request,
    build_measurement_forms_instances_create_measurement_form_instance_schema_feedback_request,
    build_measurement_forms_instances_disapprove_measurement_form_instance_request,
    build_measurement_forms_instances_export_dimension_report_request,
    build_measurement_forms_instances_get_audit_log_request,
    build_measurement_forms_instances_get_measurement_form_instance_request,
    build_measurement_forms_instances_get_measurement_form_instance_schema_request,
    build_measurement_forms_instances_get_schema_instance_elements_request,
    build_measurement_forms_instances_get_validation_rules_request,
    build_measurement_forms_instances_get_workorder_measurement_form_progress_request,
    build_measurement_forms_instances_import_measurement_form_instance_request,
    build_measurement_forms_instances_list_measurement_form_instance_feedback_request,
    build_measurement_forms_instances_list_measurement_forms_by_status_request,
    build_measurement_forms_instances_list_measurement_forms_request,
    build_measurement_forms_instances_list_supplier_measurement_form_instances_request,
    build_measurement_forms_instances_post_list_measurement_forms_by_status_request,
    build_measurement_forms_instances_post_list_measurement_forms_request,
    build_measurement_forms_instances_reactivate_measurement_form_instance_request,
    build_measurement_forms_instances_remove_supplier_from_measurment_form_instance_request,
    build_measurement_forms_instances_save_comment_request,
    build_measurement_forms_instances_save_measurement_form_instance_schema_comment_request,
    build_measurement_forms_instances_save_tool_request,
    build_measurement_forms_instances_save_value_request,
    build_measurement_forms_instances_update_measurement_form_instance_request,
    build_measurement_forms_instances_update_schema_instance_elements_request,
    build_measurement_forms_instances_upsert_supplier_to_measurment_form_instance_request,
    build_measuring_tools_attach_calibration_certificate_request,
    build_measuring_tools_create_manufacturer_request,
    build_measuring_tools_create_measuring_tool_request,
    build_measuring_tools_create_measuring_tool_sub_type_request,
    build_measuring_tools_create_measuring_tool_type_request,
    build_measuring_tools_create_measuring_unit_request,
    build_measuring_tools_delete_calibration_certificate_request,
    build_measuring_tools_delete_measuring_tool_sub_type_request,
    build_measuring_tools_delete_measuring_tool_type_request,
    build_measuring_tools_delete_measuring_unit_request,
    build_measuring_tools_deprecate_tool_request,
    build_measuring_tools_get_calibration_list_request,
    build_measuring_tools_get_measuring_tool_request,
    build_measuring_tools_get_measuring_tool_settings_request,
    build_measuring_tools_get_measuring_tool_whitelist_request,
    build_measuring_tools_import_measuring_tool_request,
    build_measuring_tools_list_calibrations_request,
    build_measuring_tools_list_manufacturers_request,
    build_measuring_tools_list_measuring_tool_sub_types_request,
    build_measuring_tools_list_measuring_tool_types_request,
    build_measuring_tools_list_measuring_tools_request,
    build_measuring_tools_list_measuring_units_request,
    build_measuring_tools_list_unregistered_tool_values_request,
    build_measuring_tools_register_calibration_request,
    build_measuring_tools_remove_measuring_tool_from_whitelist_request,
    build_measuring_tools_update_measuring_tool_request,
    build_measuring_tools_update_measuring_tool_settings_request,
    build_measuring_tools_update_measuring_tool_sub_type_request,
    build_measuring_tools_update_measuring_tool_type_request,
    build_measuring_tools_update_whitelisted_measuring_tool_request,
    build_measuring_tools_whitelist_measuring_tool_request,
    build_mes_documents_get_document_request,
    build_mes_get_worker_details_for_current_user_request,
    build_mes_links_add_mes_link_request,
    build_mes_links_delete_mes_link_request,
    build_mes_links_list_mes_links_request,
    build_mes_links_list_unmapped_mes_links_request,
    build_mes_links_update_mes_link_request,
    build_mes_production_order_check_production_order_for_open_non_conformances_request,
    build_mes_production_order_get_production_order_bom_request,
    build_mes_production_order_get_production_order_open_non_conformances_request,
    build_mes_production_order_get_production_order_pick_list_suggestion_request,
    build_mes_production_order_get_production_order_request,
    build_mes_production_order_list_production_order_activities_request,
    build_mes_production_order_post_material_pick_list_request,
    build_mes_production_schedule_get_available_production_schedule_filters_request,
    build_mes_production_schedule_get_scheduled_work_summary_request,
    build_mes_production_schedule_list_my_current_work_activities_request,
    build_mes_production_schedule_list_my_current_work_activities_v2_request,
    build_mes_production_schedule_list_production_schedule_operations_request,
    build_mes_production_schedule_post_list_production_schedule_operations_request,
    build_mes_production_schedule_report_operation_progress_request,
    build_mes_production_schedule_start_operations_request,
    build_mes_projects_list_order_schedule_request,
    build_mes_projects_list_projects_request,
    build_mes_resource_list_resource_group_resources_request,
    build_mes_resource_list_resource_groups_request,
    build_mrb_approve_mrb_revision_request,
    build_mrb_attach_pdf_request,
    build_mrb_create_mrb_request,
    build_mrb_create_mrb_revision_link_request,
    build_mrb_create_mrb_revision_pdf_request,
    build_mrb_create_mrb_revision_request,
    build_mrb_create_mrb_template_request,
    build_mrb_delete_mrb_template_request,
    build_mrb_exclude_mrb_revision_content_request,
    build_mrb_get_mrb_company_settings_request,
    build_mrb_get_mrb_instance_job_status_request,
    build_mrb_get_mrb_instance_request,
    build_mrb_get_mrb_pdf_export_job_status_request,
    build_mrb_get_mrb_revision_content_request,
    build_mrb_get_mrb_template_request,
    build_mrb_include_mrb_revision_content_request,
    build_mrb_list_mrb_instance_reports_request,
    build_mrb_list_mrb_instance_revisions_request,
    build_mrb_list_mrb_instances_request,
    build_mrb_list_mrb_templates_request,
    build_mrb_list_recent_mrb_intances_request,
    build_mrb_mark_mrb_revision_as_sent_request,
    build_mrb_post_list_mrb_instance_reports_request,
    build_mrb_refresh_mrb_revision_content_request,
    build_mrb_reject_mrb_revision_request,
    build_mrb_update_mrb_template_request,
    build_mrb_upload_mrb_revision_pdf_request,
    build_mrb_upsert_mrb_company_settings_request,
    build_operator_calculators_calculate_bar_weight_request,
    build_operator_calculators_calculate_right_angled_triangle_request,
    build_operator_calculators_calculate_spindle_and_cutting_speed_request,
    build_operator_calculators_list_materials_with_density_request,
    build_power_list_power_regions_request,
    build_presentation_get_component_settings_request,
    build_resources_list_all_machines_request,
    build_suppliers_create_supplier_invite_request,
    build_suppliers_create_supplier_mapping_request,
    build_suppliers_delete_supplier_invite_request,
    build_suppliers_delete_supplier_mappings_request,
    build_suppliers_delete_supplier_request,
    build_suppliers_import_supplier_request,
    build_suppliers_list_supplier_invites_request,
    build_suppliers_list_suppliers_request,
    build_sustainability_create_customer_order_line_ghg_report_request,
    build_sustainability_get_consumption_request,
    build_sustainability_get_customer_order_consumption_request,
    build_sustainability_get_power_request,
    build_sustainability_get_product_consumption_request,
    build_sustainability_get_work_order_consumption_request,
    build_sustainability_test_request,
    build_system_health_dashboard_get_machine_data_health_request,
    build_trace_add_sequence_to_trace_list_request,
    build_trace_generate_trace_request,
    build_trace_get_customer_order_trace_status_request,
    build_trace_get_trace_request,
    build_trace_list_customer_order_line_traces_request,
    build_trace_list_trace_workorders_request,
    build_trace_post_list_trace_workorders_request,
    build_trace_set_trace_manual_completed_request,
    build_trace_update_trace_request,
    build_tracking_create_label_request,
    build_tracking_create_tracking_events_request,
    build_tracking_create_tracking_history_request,
    build_tracking_delete_tracking_history_request,
    build_tracking_list_tracking_history_request,
    build_tracking_list_work_order_tracking_history_request,
    build_upload_create_upload_info_request,
    build_users_list_users_request,
    build_users_post_list_users_request,
    build_welding_create_welding_iot_config_request,
    build_welding_delete_welding_iot_config_request,
    build_welding_list_electrical_data_configs_request,
    build_welding_list_welding_source_types_request,
    build_workorders_check_resource_status_request,
    build_workorders_create_work_order_mapping_request,
    build_workorders_delete_work_order_mappings_request,
    build_workorders_delete_workorder_operation_event_request,
    build_workorders_delete_workorder_request,
    build_workorders_filter_workorder_operation_events_request,
    build_workorders_get_work_order_consumption_request,
    build_workorders_get_workorder_operation_event_request,
    build_workorders_get_workorder_request,
    build_workorders_list_active_workorder_operations_request,
    build_workorders_list_workorders_request,
    build_workorders_post_list_workorders_request,
    build_workorders_register_workorder_operation_event_request,
    build_workorders_search_work_orders_request,
    build_workorders_set_workorder_customer_order_reference_request,
    build_workorders_start_workorder_operation_request,
    build_workorders_start_workorder_operation_v2_request,
    build_workorders_stop_workorder_operation_request,
    build_workorders_stop_workorder_operation_v2_request,
    build_workorders_update_workorder_operation_event_timestamps_request,
    build_workorders_upsert_workorder_consumption_request,
    build_workorders_upsert_workorder_request,
    build_workorders_upsert_workorder_traces_request,
    build_workorders_upsert_workorder_v2_request,
    build_workspace_templates_admin_create_workspace_template_request,
    build_workspace_templates_admin_delete_workspace_template_request,
    build_workspace_templates_admin_delete_workspace_template_widget_request,
    build_workspace_templates_admin_get_workspace_template_request,
    build_workspace_templates_admin_update_workspace_template_request,
    build_workspace_templates_admin_update_workspace_template_widget_settings_request,
    build_workspace_templates_admin_update_workspace_template_widgets_request,
    build_workspace_templates_get_workspace_templates_request,
    build_workspaces_create_workspace_from_template_request,
    build_workspaces_create_workspace_request,
    build_workspaces_delete_workspace_request,
    build_workspaces_delete_workspace_widget_request,
    build_workspaces_get_my_workspaces_request,
    build_workspaces_get_workspace_request,
    build_workspaces_update_workspace_request,
    build_workspaces_update_workspace_widget_settings_request,
    build_workspaces_update_workspace_widgets_request,
)

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object


class AlertsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`alerts` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def alert_notification_access(self, **kwargs: Any) -> _models.AlertNotificationAccessDto:
        """alert_notification_access.

        :return: AlertNotificationAccessDto
        :rtype: ~ignos.api.client.models.AlertNotificationAccessDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AlertNotificationAccessDto] = kwargs.pop("cls", None)

        _request = build_alerts_alert_notification_access_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("AlertNotificationAccessDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_machine_inactivity_alert_type(self, **kwargs: Any) -> _models.MachineInactivityAlertTypeDto:
        """get_machine_inactivity_alert_type.

        :return: MachineInactivityAlertTypeDto
        :rtype: ~ignos.api.client.models.MachineInactivityAlertTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MachineInactivityAlertTypeDto] = kwargs.pop("cls", None)

        _request = build_alerts_get_machine_inactivity_alert_type_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MachineInactivityAlertTypeDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_machine_inactivity_subscriptions(
        self, **kwargs: Any
    ) -> List[_models.MachineInactivityCriteriaDtoAlertSubscriptionDto]:
        """list_machine_inactivity_subscriptions.

        :return: list of MachineInactivityCriteriaDtoAlertSubscriptionDto
        :rtype: list[~ignos.api.client.models.MachineInactivityCriteriaDtoAlertSubscriptionDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MachineInactivityCriteriaDtoAlertSubscriptionDto]] = kwargs.pop("cls", None)

        _request = build_alerts_list_machine_inactivity_subscriptions_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MachineInactivityCriteriaDtoAlertSubscriptionDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def subscribe_to_machine_inactivity_alerts(
        self,
        body: Optional[_models.SubscribeToMachineInactivityAlerts] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MachineInactivityCriteriaDtoAlertSubscriptionDto:
        """subscribe_to_machine_inactivity_alerts.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.SubscribeToMachineInactivityAlerts
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MachineInactivityCriteriaDtoAlertSubscriptionDto
        :rtype: ~ignos.api.client.models.MachineInactivityCriteriaDtoAlertSubscriptionDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def subscribe_to_machine_inactivity_alerts(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MachineInactivityCriteriaDtoAlertSubscriptionDto:
        """subscribe_to_machine_inactivity_alerts.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MachineInactivityCriteriaDtoAlertSubscriptionDto
        :rtype: ~ignos.api.client.models.MachineInactivityCriteriaDtoAlertSubscriptionDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def subscribe_to_machine_inactivity_alerts(
        self, body: Optional[Union[_models.SubscribeToMachineInactivityAlerts, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MachineInactivityCriteriaDtoAlertSubscriptionDto:
        """subscribe_to_machine_inactivity_alerts.

        :param body: Is either a SubscribeToMachineInactivityAlerts type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.SubscribeToMachineInactivityAlerts or IO[bytes]
        :return: MachineInactivityCriteriaDtoAlertSubscriptionDto
        :rtype: ~ignos.api.client.models.MachineInactivityCriteriaDtoAlertSubscriptionDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MachineInactivityCriteriaDtoAlertSubscriptionDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "SubscribeToMachineInactivityAlerts")
            else:
                _json = None

        _request = build_alerts_subscribe_to_machine_inactivity_alerts_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MachineInactivityCriteriaDtoAlertSubscriptionDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_machine_inactivity_alert_subscription(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        id: str,
        body: Optional[_models.UpdateMachineInactivitySubscription] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """update_machine_inactivity_alert_subscription.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateMachineInactivitySubscription
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_machine_inactivity_alert_subscription(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """update_machine_inactivity_alert_subscription.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_machine_inactivity_alert_subscription(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        id: str,
        body: Optional[Union[_models.UpdateMachineInactivitySubscription, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """update_machine_inactivity_alert_subscription.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateMachineInactivitySubscription type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.UpdateMachineInactivitySubscription or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateMachineInactivitySubscription")
            else:
                _json = None

        _request = build_alerts_update_machine_inactivity_alert_subscription_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_machine_inactivity_subscription(  # pylint: disable=inconsistent-return-statements
        self, id: str, **kwargs: Any
    ) -> None:
        """delete_machine_inactivity_subscription.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_alerts_delete_machine_inactivity_subscription_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class AssetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`assets` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_assets(
        self,
        *,
        external_idprefix: Optional[str] = None,
        name: Optional[str] = None,
        source: Optional[str] = None,
        limit: int = 100,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any
    ) -> _models.AssetDtoPagedResult:
        """list_assets.

        :keyword external_idprefix: Default value is None.
        :paramtype external_idprefix: str
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword source: Default value is None.
        :paramtype source: str
        :keyword limit: Default value is 100.
        :paramtype limit: int
        :keyword continuation_token_parameter: Default value is None.
        :paramtype continuation_token_parameter: str
        :return: AssetDtoPagedResult
        :rtype: ~ignos.api.client.models.AssetDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AssetDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_assets_list_assets_request(
            external_idprefix=external_idprefix,
            name=name,
            source=source,
            limit=limit,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("AssetDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_asset(
        self, body: Optional[_models.CreateAsset] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AssetDto:
        """create_asset.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateAsset
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AssetDto
        :rtype: ~ignos.api.client.models.AssetDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_asset(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AssetDto:
        """create_asset.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: AssetDto
        :rtype: ~ignos.api.client.models.AssetDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_asset(
        self, body: Optional[Union[_models.CreateAsset, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.AssetDto:
        """create_asset.

        :param body: Is either a CreateAsset type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CreateAsset or IO[bytes]
        :return: AssetDto
        :rtype: ~ignos.api.client.models.AssetDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AssetDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateAsset")
            else:
                _json = None

        _request = build_assets_create_asset_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("AssetDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def search_assets(
        self, *, name: Optional[str] = None, description: Optional[str] = None, limit: int = 100, **kwargs: Any
    ) -> List[_models.AssetDto]:
        """search_assets.

        :keyword name: Default value is None.
        :paramtype name: str
        :keyword description: Default value is None.
        :paramtype description: str
        :keyword limit: Default value is 100.
        :paramtype limit: int
        :return: list of AssetDto
        :rtype: list[~ignos.api.client.models.AssetDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AssetDto]] = kwargs.pop("cls", None)

        _request = build_assets_search_assets_request(
            name=name,
            description=description,
            limit=limit,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[AssetDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_asset_by_id(self, id: int, **kwargs: Any) -> _models.AssetDto:
        """get_asset_by_id.

        :param id: Required.
        :type id: int
        :return: AssetDto
        :rtype: ~ignos.api.client.models.AssetDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AssetDto] = kwargs.pop("cls", None)

        _request = build_assets_get_asset_by_id_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("AssetDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_asset(
        self,
        id: int,
        body: Optional[_models.UpdateAssetRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AssetDto:
        """update_asset.

        :param id: Required.
        :type id: int
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateAssetRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AssetDto
        :rtype: ~ignos.api.client.models.AssetDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_asset(
        self, id: int, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AssetDto:
        """update_asset.

        :param id: Required.
        :type id: int
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: AssetDto
        :rtype: ~ignos.api.client.models.AssetDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_asset(
        self, id: int, body: Optional[Union[_models.UpdateAssetRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.AssetDto:
        """update_asset.

        :param id: Required.
        :type id: int
        :param body: Is either a UpdateAssetRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UpdateAssetRequest or IO[bytes]
        :return: AssetDto
        :rtype: ~ignos.api.client.models.AssetDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AssetDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateAssetRequest")
            else:
                _json = None

        _request = build_assets_update_asset_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("AssetDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_asset_structure_by_id(self, id: int, **kwargs: Any) -> _models.AssetStructureDto:
        """get_asset_structure_by_id.

        :param id: Required.
        :type id: int
        :return: AssetStructureDto
        :rtype: ~ignos.api.client.models.AssetStructureDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AssetStructureDto] = kwargs.pop("cls", None)

        _request = build_assets_get_asset_structure_by_id_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("AssetStructureDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_machines(self, **kwargs: Any) -> List[_models.MachineDto]:
        """list_machines.

        :return: list of MachineDto
        :rtype: list[~ignos.api.client.models.MachineDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MachineDto]] = kwargs.pop("cls", None)

        _request = build_assets_list_machines_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MachineDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class AzureRegionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`azure_regions` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_azure_regions(self, **kwargs: Any) -> List[_models.AzureRegionDto]:
        """list_azure_regions.

        :return: list of AzureRegionDto
        :rtype: list[~ignos.api.client.models.AzureRegionDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AzureRegionDto]] = kwargs.pop("cls", None)

        _request = build_azure_regions_list_azure_regions_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[AzureRegionDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class BookingOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`booking` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def list_bookings(
        self,
        body: Optional[_models.BookingRequestListDto] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BookingResponseListDto:
        """list_bookings.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.BookingRequestListDto
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BookingResponseListDto
        :rtype: ~ignos.api.client.models.BookingResponseListDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def list_bookings(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.BookingResponseListDto:
        """list_bookings.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: BookingResponseListDto
        :rtype: ~ignos.api.client.models.BookingResponseListDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def list_bookings(
        self, body: Optional[Union[_models.BookingRequestListDto, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.BookingResponseListDto:
        """list_bookings.

        :param body: Is either a BookingRequestListDto type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.BookingRequestListDto or IO[bytes]
        :return: BookingResponseListDto
        :rtype: ~ignos.api.client.models.BookingResponseListDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.BookingResponseListDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "BookingRequestListDto")
            else:
                _json = None

        _request = build_booking_list_bookings_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("BookingResponseListDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_booking(self, booking_id: str, **kwargs: Any) -> _models.BookingResponseDto:
        """get_booking.

        :param booking_id: Required.
        :type booking_id: str
        :return: BookingResponseDto
        :rtype: ~ignos.api.client.models.BookingResponseDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.BookingResponseDto] = kwargs.pop("cls", None)

        _request = build_booking_get_booking_request(
            booking_id=booking_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("BookingResponseDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_booking(  # pylint: disable=inconsistent-return-statements
        self,
        booking_id: str,
        body: Optional[_models.BookingRequestDto] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """update_booking.

        :param booking_id: Required.
        :type booking_id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.BookingRequestDto
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_booking(  # pylint: disable=inconsistent-return-statements
        self,
        booking_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """update_booking.

        :param booking_id: Required.
        :type booking_id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_booking(  # pylint: disable=inconsistent-return-statements
        self, booking_id: str, body: Optional[Union[_models.BookingRequestDto, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """update_booking.

        :param booking_id: Required.
        :type booking_id: str
        :param body: Is either a BookingRequestDto type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.BookingRequestDto or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "BookingRequestDto")
            else:
                _json = None

        _request = build_booking_update_booking_request(
            booking_id=booking_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def create_booking(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[_models.BookingRequestDto] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """create_booking.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.BookingRequestDto
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_booking(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """create_booking.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_booking(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.BookingRequestDto, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """create_booking.

        :param body: Is either a BookingRequestDto type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.BookingRequestDto or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "BookingRequestDto")
            else:
                _json = None

        _request = build_booking_create_booking_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def cancel_booking(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[_models.BookingUpdateDto] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """cancel_booking.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.BookingUpdateDto
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def cancel_booking(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """cancel_booking.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def cancel_booking(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.BookingUpdateDto, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """cancel_booking.

        :param body: Is either a BookingUpdateDto type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.BookingUpdateDto or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "BookingUpdateDto")
            else:
                _json = None

        _request = build_booking_cancel_booking_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def start_delivery(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[_models.BookingUpdateDto] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """start_delivery.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.BookingUpdateDto
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def start_delivery(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """start_delivery.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def start_delivery(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.BookingUpdateDto, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """start_delivery.

        :param body: Is either a BookingUpdateDto type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.BookingUpdateDto or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "BookingUpdateDto")
            else:
                _json = None

        _request = build_booking_start_delivery_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def finish_delivery(  # pylint: disable=inconsistent-return-statements
        self,
        body: Optional[_models.BookingDeliveryUpdateDto] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """finish_delivery.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.BookingDeliveryUpdateDto
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def finish_delivery(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """finish_delivery.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def finish_delivery(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.BookingDeliveryUpdateDto, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """finish_delivery.

        :param body: Is either a BookingDeliveryUpdateDto type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.BookingDeliveryUpdateDto or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "BookingDeliveryUpdateDto")
            else:
                _json = None

        _request = build_booking_finish_delivery_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class CdfOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`cdf` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_cdf_config(self, **kwargs: Any) -> _models.CdfConfigDto:
        """Get CDF config.

        Get CDF config.

        :return: CdfConfigDto
        :rtype: ~ignos.api.client.models.CdfConfigDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CdfConfigDto] = kwargs.pop("cls", None)

        _request = build_cdf_get_cdf_config_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CdfConfigDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_cdf_config(
        self, body: Optional[_models.UpdateCdfConfig] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CdfConfigDto:
        """Update CDF config.

        Update CDF config.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateCdfConfig
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CdfConfigDto
        :rtype: ~ignos.api.client.models.CdfConfigDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_cdf_config(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CdfConfigDto:
        """Update CDF config.

        Update CDF config.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CdfConfigDto
        :rtype: ~ignos.api.client.models.CdfConfigDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_cdf_config(
        self, body: Optional[Union[_models.UpdateCdfConfig, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CdfConfigDto:
        """Update CDF config.

        Update CDF config.

        :param body: Is either a UpdateCdfConfig type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UpdateCdfConfig or IO[bytes]
        :return: CdfConfigDto
        :rtype: ~ignos.api.client.models.CdfConfigDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CdfConfigDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateCdfConfig")
            else:
                _json = None

        _request = build_cdf_update_cdf_config_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CdfConfigDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class CncFileTransferOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`cnc_file_transfer` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def start_cnc_machine_operation_transfer_to_cloud(  # pylint: disable=name-too-long
        self, id: str, **kwargs: Any
    ) -> _models.CncMachineTransferDto:
        """start_cnc_machine_operation_transfer_to_cloud.

        :param id: Required.
        :type id: str
        :return: CncMachineTransferDto
        :rtype: ~ignos.api.client.models.CncMachineTransferDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CncMachineTransferDto] = kwargs.pop("cls", None)

        _request = build_cnc_file_transfer_start_cnc_machine_operation_transfer_to_cloud_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncMachineTransferDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def start_cnc_machine_operation_transfer_to_machine(  # pylint: disable=name-too-long
        self, id: str, **kwargs: Any
    ) -> _models.CncMachineTransferDto:
        """start_cnc_machine_operation_transfer_to_machine.

        :param id: Required.
        :type id: str
        :return: CncMachineTransferDto
        :rtype: ~ignos.api.client.models.CncMachineTransferDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CncMachineTransferDto] = kwargs.pop("cls", None)

        _request = build_cnc_file_transfer_start_cnc_machine_operation_transfer_to_machine_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncMachineTransferDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_transfer_status(self, id: str, **kwargs: Any) -> _models.CncMachineTransferDto:
        """get_transfer_status.

        :param id: Required.
        :type id: str
        :return: CncMachineTransferDto
        :rtype: ~ignos.api.client.models.CncMachineTransferDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CncMachineTransferDto] = kwargs.pop("cls", None)

        _request = build_cnc_file_transfer_get_transfer_status_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncMachineTransferDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_upload_cam_transfer_info(
        self,
        body: Optional[_models.UploadCamFileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.UploadCamFileDto:
        """create_upload_cam_transfer_info.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UploadCamFileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: UploadCamFileDto
        :rtype: ~ignos.api.client.models.UploadCamFileDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_upload_cam_transfer_info(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.UploadCamFileDto:
        """create_upload_cam_transfer_info.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: UploadCamFileDto
        :rtype: ~ignos.api.client.models.UploadCamFileDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_upload_cam_transfer_info(
        self, body: Optional[Union[_models.UploadCamFileRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.UploadCamFileDto:
        """create_upload_cam_transfer_info.

        :param body: Is either a UploadCamFileRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UploadCamFileRequest or IO[bytes]
        :return: UploadCamFileDto
        :rtype: ~ignos.api.client.models.UploadCamFileDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.UploadCamFileDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UploadCamFileRequest")
            else:
                _json = None

        _request = build_cnc_file_transfer_create_upload_cam_transfer_info_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("UploadCamFileDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_cam_transfer(self, *, path: Optional[str] = None, **kwargs: Any) -> _models.CamTransferDto:
        """get_cam_transfer.

        :keyword path: Default value is None.
        :paramtype path: str
        :return: CamTransferDto
        :rtype: ~ignos.api.client.models.CamTransferDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CamTransferDto] = kwargs.pop("cls", None)

        _request = build_cnc_file_transfer_get_cam_transfer_request(
            path=path,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CamTransferDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def start_cam_transfer_to_machine(
        self,
        body: Optional[_models.StartCamTransferToMachine] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CncMachineTransferDto:
        """start_cam_transfer_to_machine.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.StartCamTransferToMachine
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CncMachineTransferDto
        :rtype: ~ignos.api.client.models.CncMachineTransferDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def start_cam_transfer_to_machine(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncMachineTransferDto:
        """start_cam_transfer_to_machine.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CncMachineTransferDto
        :rtype: ~ignos.api.client.models.CncMachineTransferDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def start_cam_transfer_to_machine(
        self, body: Optional[Union[_models.StartCamTransferToMachine, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CncMachineTransferDto:
        """start_cam_transfer_to_machine.

        :param body: Is either a StartCamTransferToMachine type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.StartCamTransferToMachine or IO[bytes]
        :return: CncMachineTransferDto
        :rtype: ~ignos.api.client.models.CncMachineTransferDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CncMachineTransferDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "StartCamTransferToMachine")
            else:
                _json = None

        _request = build_cnc_file_transfer_start_cam_transfer_to_machine_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncMachineTransferDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def start_cam_transfer_to_machine_from_temp_upload(  # pylint: disable=name-too-long
        self,
        body: Optional[_models.StartCamTransferToMachineFromTempUpload] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CncMachineTransferDto:
        """start_cam_transfer_to_machine_from_temp_upload.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.StartCamTransferToMachineFromTempUpload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CncMachineTransferDto
        :rtype: ~ignos.api.client.models.CncMachineTransferDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def start_cam_transfer_to_machine_from_temp_upload(  # pylint: disable=name-too-long
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncMachineTransferDto:
        """start_cam_transfer_to_machine_from_temp_upload.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CncMachineTransferDto
        :rtype: ~ignos.api.client.models.CncMachineTransferDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def start_cam_transfer_to_machine_from_temp_upload(  # pylint: disable=name-too-long
        self, body: Optional[Union[_models.StartCamTransferToMachineFromTempUpload, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CncMachineTransferDto:
        """start_cam_transfer_to_machine_from_temp_upload.

        :param body: Is either a StartCamTransferToMachineFromTempUpload type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.StartCamTransferToMachineFromTempUpload or IO[bytes]
        :return: CncMachineTransferDto
        :rtype: ~ignos.api.client.models.CncMachineTransferDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CncMachineTransferDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "StartCamTransferToMachineFromTempUpload")
            else:
                _json = None

        _request = build_cnc_file_transfer_start_cam_transfer_to_machine_from_temp_upload_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncMachineTransferDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class CncSetupOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`cnc_setup` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_cnc_machine(self, id: str, **kwargs: Any) -> _models.CncMachineDto:
        """get_cnc_machine.

        :param id: Required.
        :type id: str
        :return: CncMachineDto
        :rtype: ~ignos.api.client.models.CncMachineDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CncMachineDto] = kwargs.pop("cls", None)

        _request = build_cnc_setup_get_cnc_machine_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncMachineDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_cnc_machine(
        self,
        id: str,
        body: Optional[_models.UpdateCncMachineRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CncMachineDto:
        """update_cnc_machine.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateCncMachineRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CncMachineDto
        :rtype: ~ignos.api.client.models.CncMachineDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_cnc_machine(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncMachineDto:
        """update_cnc_machine.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CncMachineDto
        :rtype: ~ignos.api.client.models.CncMachineDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_cnc_machine(
        self, id: str, body: Optional[Union[_models.UpdateCncMachineRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CncMachineDto:
        """update_cnc_machine.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateCncMachineRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.UpdateCncMachineRequest or IO[bytes]
        :return: CncMachineDto
        :rtype: ~ignos.api.client.models.CncMachineDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CncMachineDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateCncMachineRequest")
            else:
                _json = None

        _request = build_cnc_setup_update_cnc_machine_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncMachineDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_cnc_machine(  # pylint: disable=inconsistent-return-statements
        self, id: str, **kwargs: Any
    ) -> None:
        """delete_cnc_machine.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_cnc_setup_delete_cnc_machine_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_cnc_machines(
        self, *, name_prefix: Optional[str] = None, **kwargs: Any
    ) -> List[_models.CncMachineDto]:
        """list_cnc_machines.

        :keyword name_prefix: Default value is None.
        :paramtype name_prefix: str
        :return: list of CncMachineDto
        :rtype: list[~ignos.api.client.models.CncMachineDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CncMachineDto]] = kwargs.pop("cls", None)

        _request = build_cnc_setup_list_cnc_machines_request(
            name_prefix=name_prefix,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[CncMachineDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_cnc_machine(
        self, body: Optional[_models.CreateCncMachine] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncMachineDto:
        """create_cnc_machine.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateCncMachine
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CncMachineDto
        :rtype: ~ignos.api.client.models.CncMachineDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_cnc_machine(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncMachineDto:
        """create_cnc_machine.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CncMachineDto
        :rtype: ~ignos.api.client.models.CncMachineDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_cnc_machine(
        self, body: Optional[Union[_models.CreateCncMachine, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CncMachineDto:
        """create_cnc_machine.

        :param body: Is either a CreateCncMachine type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CreateCncMachine or IO[bytes]
        :return: CncMachineDto
        :rtype: ~ignos.api.client.models.CncMachineDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CncMachineDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateCncMachine")
            else:
                _json = None

        _request = build_cnc_setup_create_cnc_machine_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncMachineDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_cnc_machine_communication_settings(
        self, id: str, **kwargs: Any
    ) -> _models.CncMachineCommunicationSettingsDto:
        """get_cnc_machine_communication_settings.

        :param id: Required.
        :type id: str
        :return: CncMachineCommunicationSettingsDto
        :rtype: ~ignos.api.client.models.CncMachineCommunicationSettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CncMachineCommunicationSettingsDto] = kwargs.pop("cls", None)

        _request = build_cnc_setup_get_cnc_machine_communication_settings_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncMachineCommunicationSettingsDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_cnc_machine_communication_settings(  # pylint: disable=name-too-long
        self,
        id: str,
        body: Optional[_models.UpdateCncMachineCommunicationSettingsRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CncMachineCommunicationSettingsDto:
        """update_cnc_machine_communication_settings.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateCncMachineCommunicationSettingsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CncMachineCommunicationSettingsDto
        :rtype: ~ignos.api.client.models.CncMachineCommunicationSettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_cnc_machine_communication_settings(  # pylint: disable=name-too-long
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncMachineCommunicationSettingsDto:
        """update_cnc_machine_communication_settings.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CncMachineCommunicationSettingsDto
        :rtype: ~ignos.api.client.models.CncMachineCommunicationSettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_cnc_machine_communication_settings(  # pylint: disable=name-too-long
        self,
        id: str,
        body: Optional[Union[_models.UpdateCncMachineCommunicationSettingsRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.CncMachineCommunicationSettingsDto:
        """update_cnc_machine_communication_settings.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateCncMachineCommunicationSettingsRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.UpdateCncMachineCommunicationSettingsRequest or IO[bytes]
        :return: CncMachineCommunicationSettingsDto
        :rtype: ~ignos.api.client.models.CncMachineCommunicationSettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CncMachineCommunicationSettingsDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateCncMachineCommunicationSettingsRequest")
            else:
                _json = None

        _request = build_cnc_setup_update_cnc_machine_communication_settings_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncMachineCommunicationSettingsDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_cnc_machine_communication_settings(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, id: str, **kwargs: Any
    ) -> None:
        """delete_cnc_machine_communication_settings.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_cnc_setup_delete_cnc_machine_communication_settings_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def create_cnc_part(
        self, body: Optional[_models.CreateCncPart] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncPartDto:
        """create_cnc_part.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateCncPart
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CncPartDto
        :rtype: ~ignos.api.client.models.CncPartDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_cnc_part(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncPartDto:
        """create_cnc_part.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CncPartDto
        :rtype: ~ignos.api.client.models.CncPartDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_cnc_part(
        self, body: Optional[Union[_models.CreateCncPart, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CncPartDto:
        """create_cnc_part.

        :param body: Is either a CreateCncPart type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CreateCncPart or IO[bytes]
        :return: CncPartDto
        :rtype: ~ignos.api.client.models.CncPartDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CncPartDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateCncPart")
            else:
                _json = None

        _request = build_cnc_setup_create_cnc_part_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncPartDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_cnc_parts(
        self,
        *,
        page_size: int = 50,
        customer_id: Optional[str] = None,
        customer_name: Optional[str] = None,
        part_number: Optional[str] = None,
        part_revision: Optional[str] = None,
        part_name: Optional[str] = None,
        drawing: Optional[str] = None,
        drawing_revision: Optional[str] = None,
        material: Optional[str] = None,
        filter_deleted: Optional[Union[str, _models.CncFilterDeletedDto]] = None,
        filter: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any
    ) -> _models.CncPartListDtoPagedResult:
        """list_cnc_parts.

        :keyword page_size: Default value is 50.
        :paramtype page_size: int
        :keyword customer_id: Default value is None.
        :paramtype customer_id: str
        :keyword customer_name: Default value is None.
        :paramtype customer_name: str
        :keyword part_number: Default value is None.
        :paramtype part_number: str
        :keyword part_revision: Default value is None.
        :paramtype part_revision: str
        :keyword part_name: Default value is None.
        :paramtype part_name: str
        :keyword drawing: Default value is None.
        :paramtype drawing: str
        :keyword drawing_revision: Default value is None.
        :paramtype drawing_revision: str
        :keyword material: Default value is None.
        :paramtype material: str
        :keyword filter_deleted: Known values are: "NoneDeleted", "OnlyDeleted", and "All". Default
         value is None.
        :paramtype filter_deleted: str or ~ignos.api.client.models.CncFilterDeletedDto
        :keyword filter: Default value is None.
        :paramtype filter: str
        :keyword continuation_token_parameter: Default value is None.
        :paramtype continuation_token_parameter: str
        :return: CncPartListDtoPagedResult
        :rtype: ~ignos.api.client.models.CncPartListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CncPartListDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_cnc_setup_list_cnc_parts_request(
            page_size=page_size,
            customer_id=customer_id,
            customer_name=customer_name,
            part_number=part_number,
            part_revision=part_revision,
            part_name=part_name,
            drawing=drawing,
            drawing_revision=drawing_revision,
            material=material,
            filter_deleted=filter_deleted,
            filter=filter,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncPartListDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_cnc_part(
        self,
        id: str,
        body: Optional[_models.UpdateCncPartRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CncPartDto:
        """update_cnc_part.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateCncPartRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CncPartDto
        :rtype: ~ignos.api.client.models.CncPartDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_cnc_part(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncPartDto:
        """update_cnc_part.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CncPartDto
        :rtype: ~ignos.api.client.models.CncPartDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_cnc_part(
        self, id: str, body: Optional[Union[_models.UpdateCncPartRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CncPartDto:
        """update_cnc_part.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateCncPartRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UpdateCncPartRequest or IO[bytes]
        :return: CncPartDto
        :rtype: ~ignos.api.client.models.CncPartDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CncPartDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateCncPartRequest")
            else:
                _json = None

        _request = build_cnc_setup_update_cnc_part_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncPartDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_cnc_part(self, id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """delete_cnc_part.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_cnc_setup_delete_cnc_part_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_cnc_part(self, id: str, **kwargs: Any) -> _models.CncPartDto:
        """get_cnc_part.

        :param id: Required.
        :type id: str
        :return: CncPartDto
        :rtype: ~ignos.api.client.models.CncPartDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CncPartDto] = kwargs.pop("cls", None)

        _request = build_cnc_setup_get_cnc_part_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncPartDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_list_cnc_parts(
        self,
        body: Optional[_models.ListCncPartsRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CncPartListDtoPagedResult:
        """post_list_cnc_parts.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListCncPartsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CncPartListDtoPagedResult
        :rtype: ~ignos.api.client.models.CncPartListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_cnc_parts(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncPartListDtoPagedResult:
        """post_list_cnc_parts.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CncPartListDtoPagedResult
        :rtype: ~ignos.api.client.models.CncPartListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_cnc_parts(
        self, body: Optional[Union[_models.ListCncPartsRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CncPartListDtoPagedResult:
        """post_list_cnc_parts.

        :param body: Is either a ListCncPartsRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.ListCncPartsRequest or IO[bytes]
        :return: CncPartListDtoPagedResult
        :rtype: ~ignos.api.client.models.CncPartListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CncPartListDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListCncPartsRequest")
            else:
                _json = None

        _request = build_cnc_setup_post_list_cnc_parts_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncPartListDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def copy_cnc_part(
        self, body: Optional[_models.CopyCncPart] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncPartDto:
        """copy_cnc_part.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CopyCncPart
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CncPartDto
        :rtype: ~ignos.api.client.models.CncPartDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def copy_cnc_part(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncPartDto:
        """copy_cnc_part.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CncPartDto
        :rtype: ~ignos.api.client.models.CncPartDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def copy_cnc_part(
        self, body: Optional[Union[_models.CopyCncPart, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CncPartDto:
        """copy_cnc_part.

        :param body: Is either a CopyCncPart type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CopyCncPart or IO[bytes]
        :return: CncPartDto
        :rtype: ~ignos.api.client.models.CncPartDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CncPartDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CopyCncPart")
            else:
                _json = None

        _request = build_cnc_setup_copy_cnc_part_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncPartDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_upload_part_drawing_info(
        self,
        id: str,
        body: Optional[_models.UploadPartDrawingRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.UploadFileDto:
        """create_upload_part_drawing_info.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UploadPartDrawingRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: UploadFileDto
        :rtype: ~ignos.api.client.models.UploadFileDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_upload_part_drawing_info(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.UploadFileDto:
        """create_upload_part_drawing_info.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: UploadFileDto
        :rtype: ~ignos.api.client.models.UploadFileDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_upload_part_drawing_info(
        self, id: str, body: Optional[Union[_models.UploadPartDrawingRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.UploadFileDto:
        """create_upload_part_drawing_info.

        :param id: Required.
        :type id: str
        :param body: Is either a UploadPartDrawingRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.UploadPartDrawingRequest or IO[bytes]
        :return: UploadFileDto
        :rtype: ~ignos.api.client.models.UploadFileDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.UploadFileDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UploadPartDrawingRequest")
            else:
                _json = None

        _request = build_cnc_setup_create_upload_part_drawing_info_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("UploadFileDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_cnc_part_drawing(self, id: str, **kwargs: Any) -> _models.FileDto:
        """get_cnc_part_drawing.

        :param id: Required.
        :type id: str
        :return: FileDto
        :rtype: ~ignos.api.client.models.FileDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FileDto] = kwargs.pop("cls", None)

        _request = build_cnc_setup_get_cnc_part_drawing_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("FileDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def delete_cnc_part_drawing(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[_models.DeletePartDrawingRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """delete_cnc_part_drawing.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.DeletePartDrawingRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def delete_cnc_part_drawing(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """delete_cnc_part_drawing.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def delete_cnc_part_drawing(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[Union[_models.DeletePartDrawingRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """delete_cnc_part_drawing.

        :param id: Required.
        :type id: str
        :param body: Is either a DeletePartDrawingRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.DeletePartDrawingRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "DeletePartDrawingRequest")
            else:
                _json = None

        _request = build_cnc_setup_delete_cnc_part_drawing_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def create_cnc_machine_operation(
        self,
        body: Optional[_models.CreateCncMachineOperation] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CncMachineOperationDto:
        """create_cnc_machine_operation.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateCncMachineOperation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CncMachineOperationDto
        :rtype: ~ignos.api.client.models.CncMachineOperationDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_cnc_machine_operation(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncMachineOperationDto:
        """create_cnc_machine_operation.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CncMachineOperationDto
        :rtype: ~ignos.api.client.models.CncMachineOperationDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_cnc_machine_operation(
        self, body: Optional[Union[_models.CreateCncMachineOperation, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CncMachineOperationDto:
        """create_cnc_machine_operation.

        :param body: Is either a CreateCncMachineOperation type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.CreateCncMachineOperation or IO[bytes]
        :return: CncMachineOperationDto
        :rtype: ~ignos.api.client.models.CncMachineOperationDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CncMachineOperationDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateCncMachineOperation")
            else:
                _json = None

        _request = build_cnc_setup_create_cnc_machine_operation_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncMachineOperationDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_cnc_machine_operations(
        self,
        *,
        page_size: int = 50,
        cnc_machine_id: Optional[str] = None,
        customer_id: Optional[str] = None,
        customer_name: Optional[str] = None,
        part_number: Optional[str] = None,
        part_revision: Optional[str] = None,
        part_name: Optional[str] = None,
        drawing: Optional[str] = None,
        drawing_revision: Optional[str] = None,
        material: Optional[str] = None,
        filter_deleted: Optional[Union[str, _models.CncFilterDeletedDto]] = None,
        filter: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any
    ) -> _models.CncMachineOperationSearchResultDtoPagedResult:
        """list_cnc_machine_operations.

        :keyword page_size: Default value is 50.
        :paramtype page_size: int
        :keyword cnc_machine_id: Default value is None.
        :paramtype cnc_machine_id: str
        :keyword customer_id: Default value is None.
        :paramtype customer_id: str
        :keyword customer_name: Default value is None.
        :paramtype customer_name: str
        :keyword part_number: Default value is None.
        :paramtype part_number: str
        :keyword part_revision: Default value is None.
        :paramtype part_revision: str
        :keyword part_name: Default value is None.
        :paramtype part_name: str
        :keyword drawing: Default value is None.
        :paramtype drawing: str
        :keyword drawing_revision: Default value is None.
        :paramtype drawing_revision: str
        :keyword material: Default value is None.
        :paramtype material: str
        :keyword filter_deleted: Known values are: "NoneDeleted", "OnlyDeleted", and "All". Default
         value is None.
        :paramtype filter_deleted: str or ~ignos.api.client.models.CncFilterDeletedDto
        :keyword filter: Default value is None.
        :paramtype filter: str
        :keyword continuation_token_parameter: Default value is None.
        :paramtype continuation_token_parameter: str
        :return: CncMachineOperationSearchResultDtoPagedResult
        :rtype: ~ignos.api.client.models.CncMachineOperationSearchResultDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CncMachineOperationSearchResultDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_cnc_setup_list_cnc_machine_operations_request(
            page_size=page_size,
            cnc_machine_id=cnc_machine_id,
            customer_id=customer_id,
            customer_name=customer_name,
            part_number=part_number,
            part_revision=part_revision,
            part_name=part_name,
            drawing=drawing,
            drawing_revision=drawing_revision,
            material=material,
            filter_deleted=filter_deleted,
            filter=filter,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncMachineOperationSearchResultDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_list_cnc_machine_operations(
        self,
        body: Optional[_models.ListCncMachineOperationsRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CncMachineOperationSearchResultDtoPagedResult:
        """post_list_cnc_machine_operations.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListCncMachineOperationsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CncMachineOperationSearchResultDtoPagedResult
        :rtype: ~ignos.api.client.models.CncMachineOperationSearchResultDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_cnc_machine_operations(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncMachineOperationSearchResultDtoPagedResult:
        """post_list_cnc_machine_operations.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CncMachineOperationSearchResultDtoPagedResult
        :rtype: ~ignos.api.client.models.CncMachineOperationSearchResultDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_cnc_machine_operations(
        self, body: Optional[Union[_models.ListCncMachineOperationsRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CncMachineOperationSearchResultDtoPagedResult:
        """post_list_cnc_machine_operations.

        :param body: Is either a ListCncMachineOperationsRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.ListCncMachineOperationsRequest or IO[bytes]
        :return: CncMachineOperationSearchResultDtoPagedResult
        :rtype: ~ignos.api.client.models.CncMachineOperationSearchResultDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CncMachineOperationSearchResultDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListCncMachineOperationsRequest")
            else:
                _json = None

        _request = build_cnc_setup_post_list_cnc_machine_operations_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncMachineOperationSearchResultDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_cnc_machine_operation(
        self,
        id: str,
        body: Optional[_models.UpdateCncMachineOperationRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CncMachineOperationDto:
        """update_cnc_machine_operation.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateCncMachineOperationRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CncMachineOperationDto
        :rtype: ~ignos.api.client.models.CncMachineOperationDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_cnc_machine_operation(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncMachineOperationDto:
        """update_cnc_machine_operation.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CncMachineOperationDto
        :rtype: ~ignos.api.client.models.CncMachineOperationDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_cnc_machine_operation(
        self, id: str, body: Optional[Union[_models.UpdateCncMachineOperationRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CncMachineOperationDto:
        """update_cnc_machine_operation.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateCncMachineOperationRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.UpdateCncMachineOperationRequest or IO[bytes]
        :return: CncMachineOperationDto
        :rtype: ~ignos.api.client.models.CncMachineOperationDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CncMachineOperationDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateCncMachineOperationRequest")
            else:
                _json = None

        _request = build_cnc_setup_update_cnc_machine_operation_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncMachineOperationDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_cnc_machine_operation(self, id: str, **kwargs: Any) -> _models.CncMachineOperationDto:
        """get_cnc_machine_operation.

        :param id: Required.
        :type id: str
        :return: CncMachineOperationDto
        :rtype: ~ignos.api.client.models.CncMachineOperationDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CncMachineOperationDto] = kwargs.pop("cls", None)

        _request = build_cnc_setup_get_cnc_machine_operation_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncMachineOperationDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_cnc_machine_operation(  # pylint: disable=inconsistent-return-statements
        self, id: str, **kwargs: Any
    ) -> None:
        """delete_cnc_machine_operation.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_cnc_setup_delete_cnc_machine_operation_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def copy_cnc_machine_operations(
        self,
        body: Optional[_models.CopyCncMachineOperations] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.CncMachineOperationDto]:
        """copy_cnc_machine_operations.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CopyCncMachineOperations
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of CncMachineOperationDto
        :rtype: list[~ignos.api.client.models.CncMachineOperationDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def copy_cnc_machine_operations(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.CncMachineOperationDto]:
        """copy_cnc_machine_operations.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: list of CncMachineOperationDto
        :rtype: list[~ignos.api.client.models.CncMachineOperationDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def copy_cnc_machine_operations(
        self, body: Optional[Union[_models.CopyCncMachineOperations, IO[bytes]]] = None, **kwargs: Any
    ) -> List[_models.CncMachineOperationDto]:
        """copy_cnc_machine_operations.

        :param body: Is either a CopyCncMachineOperations type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.CopyCncMachineOperations or IO[bytes]
        :return: list of CncMachineOperationDto
        :rtype: list[~ignos.api.client.models.CncMachineOperationDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.CncMachineOperationDto]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CopyCncMachineOperations")
            else:
                _json = None

        _request = build_cnc_setup_copy_cnc_machine_operations_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[CncMachineOperationDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def copy_tools_cnc_machine(
        self,
        body: Optional[_models.CopyToolsCncMachine] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.CncToolDto]:
        """copy_tools_cnc_machine.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CopyToolsCncMachine
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of CncToolDto
        :rtype: list[~ignos.api.client.models.CncToolDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def copy_tools_cnc_machine(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.CncToolDto]:
        """copy_tools_cnc_machine.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: list of CncToolDto
        :rtype: list[~ignos.api.client.models.CncToolDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def copy_tools_cnc_machine(
        self, body: Optional[Union[_models.CopyToolsCncMachine, IO[bytes]]] = None, **kwargs: Any
    ) -> List[_models.CncToolDto]:
        """copy_tools_cnc_machine.

        :param body: Is either a CopyToolsCncMachine type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CopyToolsCncMachine or IO[bytes]
        :return: list of CncToolDto
        :rtype: list[~ignos.api.client.models.CncToolDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.CncToolDto]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CopyToolsCncMachine")
            else:
                _json = None

        _request = build_cnc_setup_copy_tools_cnc_machine_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[CncToolDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_upload_programs_info(
        self,
        id: str,
        body: Optional[_models.UploadFileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.UploadFileDto]:
        """create_upload_programs_info.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UploadFileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of UploadFileDto
        :rtype: list[~ignos.api.client.models.UploadFileDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_upload_programs_info(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.UploadFileDto]:
        """create_upload_programs_info.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: list of UploadFileDto
        :rtype: list[~ignos.api.client.models.UploadFileDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_upload_programs_info(
        self, id: str, body: Optional[Union[_models.UploadFileRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> List[_models.UploadFileDto]:
        """create_upload_programs_info.

        :param id: Required.
        :type id: str
        :param body: Is either a UploadFileRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UploadFileRequest or IO[bytes]
        :return: list of UploadFileDto
        :rtype: list[~ignos.api.client.models.UploadFileDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.UploadFileDto]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UploadFileRequest")
            else:
                _json = None

        _request = build_cnc_setup_create_upload_programs_info_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[UploadFileDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_cnc_machine_operations_programs(
        self, id: str, *, filter_deleted: Optional[Union[str, _models.CncFilterDeletedDto]] = None, **kwargs: Any
    ) -> List[_models.ProgramFileDto]:
        """list_cnc_machine_operations_programs.

        :param id: Required.
        :type id: str
        :keyword filter_deleted: Known values are: "NoneDeleted", "OnlyDeleted", and "All". Default
         value is None.
        :paramtype filter_deleted: str or ~ignos.api.client.models.CncFilterDeletedDto
        :return: list of ProgramFileDto
        :rtype: list[~ignos.api.client.models.ProgramFileDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProgramFileDto]] = kwargs.pop("cls", None)

        _request = build_cnc_setup_list_cnc_machine_operations_programs_request(
            id=id,
            filter_deleted=filter_deleted,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[ProgramFileDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_cnc_machine_operations_programs_archive(  # pylint: disable=name-too-long
        self,
        id: str,
        filename: str,
        *,
        filter_deleted: Optional[Union[str, _models.CncFilterDeletedDto]] = None,
        **kwargs: Any
    ) -> List[_models.ProgramFileDto]:
        """list_cnc_machine_operations_programs_archive.

        :param id: Required.
        :type id: str
        :param filename: Required.
        :type filename: str
        :keyword filter_deleted: Known values are: "NoneDeleted", "OnlyDeleted", and "All". Default
         value is None.
        :paramtype filter_deleted: str or ~ignos.api.client.models.CncFilterDeletedDto
        :return: list of ProgramFileDto
        :rtype: list[~ignos.api.client.models.ProgramFileDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProgramFileDto]] = kwargs.pop("cls", None)

        _request = build_cnc_setup_list_cnc_machine_operations_programs_archive_request(
            id=id,
            filename=filename,
            filter_deleted=filter_deleted,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[ProgramFileDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_cnc_machine_operation_program(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        filename: str,
        body: Optional[_models.UpdateProgramFileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """update_cnc_machine_operation_program.

        :param id: Required.
        :type id: str
        :param filename: Required.
        :type filename: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateProgramFileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_cnc_machine_operation_program(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        filename: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """update_cnc_machine_operation_program.

        :param id: Required.
        :type id: str
        :param filename: Required.
        :type filename: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_cnc_machine_operation_program(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        filename: str,
        body: Optional[Union[_models.UpdateProgramFileRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """update_cnc_machine_operation_program.

        :param id: Required.
        :type id: str
        :param filename: Required.
        :type filename: str
        :param body: Is either a UpdateProgramFileRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.UpdateProgramFileRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateProgramFileRequest")
            else:
                _json = None

        _request = build_cnc_setup_update_cnc_machine_operation_program_request(
            id=id,
            filename=filename,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_cnc_machine_operation_program(  # pylint: disable=inconsistent-return-statements
        self, id: str, filename: str, **kwargs: Any
    ) -> None:
        """delete_cnc_machine_operation_program.

        :param id: Required.
        :type id: str
        :param filename: Required.
        :type filename: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_cnc_setup_delete_cnc_machine_operation_program_request(
            id=id,
            filename=filename,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def update_cnc_machine_operation_program_version(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        id: str,
        filename: str,
        version_id: int,
        body: Optional[_models.UpdateProgramFileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """update_cnc_machine_operation_program_version.

        :param id: Required.
        :type id: str
        :param filename: Required.
        :type filename: str
        :param version_id: Required.
        :type version_id: int
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateProgramFileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_cnc_machine_operation_program_version(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        id: str,
        filename: str,
        version_id: int,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """update_cnc_machine_operation_program_version.

        :param id: Required.
        :type id: str
        :param filename: Required.
        :type filename: str
        :param version_id: Required.
        :type version_id: int
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_cnc_machine_operation_program_version(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        id: str,
        filename: str,
        version_id: int,
        body: Optional[Union[_models.UpdateProgramFileRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """update_cnc_machine_operation_program_version.

        :param id: Required.
        :type id: str
        :param filename: Required.
        :type filename: str
        :param version_id: Required.
        :type version_id: int
        :param body: Is either a UpdateProgramFileRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.UpdateProgramFileRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateProgramFileRequest")
            else:
                _json = None

        _request = build_cnc_setup_update_cnc_machine_operation_program_version_request(
            id=id,
            filename=filename,
            version_id=version_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_cnc_machine_operation_program_version(  # pylint: disable=name-too-long
        self, id: str, filename: str, version_id: int, **kwargs: Any
    ) -> List[_models.ProgramFileDto]:
        """delete_cnc_machine_operation_program_version.

        :param id: Required.
        :type id: str
        :param filename: Required.
        :type filename: str
        :param version_id: Required.
        :type version_id: int
        :return: list of ProgramFileDto
        :rtype: list[~ignos.api.client.models.ProgramFileDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProgramFileDto]] = kwargs.pop("cls", None)

        _request = build_cnc_setup_delete_cnc_machine_operation_program_version_request(
            id=id,
            filename=filename,
            version_id=version_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[ProgramFileDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_upload_attachment_info(
        self,
        id: str,
        body: Optional[_models.UploadFileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.UploadFileDto]:
        """create_upload_attachment_info.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UploadFileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of UploadFileDto
        :rtype: list[~ignos.api.client.models.UploadFileDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_upload_attachment_info(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.UploadFileDto]:
        """create_upload_attachment_info.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: list of UploadFileDto
        :rtype: list[~ignos.api.client.models.UploadFileDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_upload_attachment_info(
        self, id: str, body: Optional[Union[_models.UploadFileRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> List[_models.UploadFileDto]:
        """create_upload_attachment_info.

        :param id: Required.
        :type id: str
        :param body: Is either a UploadFileRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UploadFileRequest or IO[bytes]
        :return: list of UploadFileDto
        :rtype: list[~ignos.api.client.models.UploadFileDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.UploadFileDto]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UploadFileRequest")
            else:
                _json = None

        _request = build_cnc_setup_create_upload_attachment_info_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[UploadFileDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_cnc_machine_operations_attachments(self, id: str, **kwargs: Any) -> List[_models.FileDto]:
        """list_cnc_machine_operations_attachments.

        :param id: Required.
        :type id: str
        :return: list of FileDto
        :rtype: list[~ignos.api.client.models.FileDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.FileDto]] = kwargs.pop("cls", None)

        _request = build_cnc_setup_list_cnc_machine_operations_attachments_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[FileDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_cnc_machine_operation_attachment(  # pylint: disable=inconsistent-return-statements
        self, operation_id: str, filename: str, **kwargs: Any
    ) -> None:
        """delete_cnc_machine_operation_attachment.

        :param operation_id: Required.
        :type operation_id: str
        :param filename: Required.
        :type filename: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_cnc_setup_delete_cnc_machine_operation_attachment_request(
            operation_id=operation_id,
            filename=filename,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_cnc_machine_operations_by_part(self, id: str, **kwargs: Any) -> List[_models.CncMachineOperationDto]:
        """list_cnc_machine_operations_by_part.

        :param id: Required.
        :type id: str
        :return: list of CncMachineOperationDto
        :rtype: list[~ignos.api.client.models.CncMachineOperationDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CncMachineOperationDto]] = kwargs.pop("cls", None)

        _request = build_cnc_setup_list_cnc_machine_operations_by_part_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[CncMachineOperationDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_cnc_tool_types(self, **kwargs: Any) -> List[_models.CncToolTypeDto]:
        """list_cnc_tool_types.

        :return: list of CncToolTypeDto
        :rtype: list[~ignos.api.client.models.CncToolTypeDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CncToolTypeDto]] = kwargs.pop("cls", None)

        _request = build_cnc_setup_list_cnc_tool_types_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[CncToolTypeDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_cnc_machine_operation_tool(
        self,
        id: str,
        body: Optional[_models.CreateCncMachineOperationToolRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CncToolDto:
        """create_cnc_machine_operation_tool.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateCncMachineOperationToolRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CncToolDto
        :rtype: ~ignos.api.client.models.CncToolDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_cnc_machine_operation_tool(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncToolDto:
        """create_cnc_machine_operation_tool.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CncToolDto
        :rtype: ~ignos.api.client.models.CncToolDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_cnc_machine_operation_tool(
        self,
        id: str,
        body: Optional[Union[_models.CreateCncMachineOperationToolRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.CncToolDto:
        """create_cnc_machine_operation_tool.

        :param id: Required.
        :type id: str
        :param body: Is either a CreateCncMachineOperationToolRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.CreateCncMachineOperationToolRequest or IO[bytes]
        :return: CncToolDto
        :rtype: ~ignos.api.client.models.CncToolDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CncToolDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateCncMachineOperationToolRequest")
            else:
                _json = None

        _request = build_cnc_setup_create_cnc_machine_operation_tool_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncToolDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_cnc_tool_by_operation(self, id: str, **kwargs: Any) -> List[_models.CncToolDto]:
        """list_cnc_tool_by_operation.

        :param id: Required.
        :type id: str
        :return: list of CncToolDto
        :rtype: list[~ignos.api.client.models.CncToolDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CncToolDto]] = kwargs.pop("cls", None)

        _request = build_cnc_setup_list_cnc_tool_by_operation_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[CncToolDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_cnc_machine_operation_tool(
        self,
        operation_id: str,
        id: int,
        body: Optional[_models.UpdateCncMachineOperationToolRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CncToolDto:
        """update_cnc_machine_operation_tool.

        :param operation_id: Required.
        :type operation_id: str
        :param id: Required.
        :type id: int
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateCncMachineOperationToolRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CncToolDto
        :rtype: ~ignos.api.client.models.CncToolDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_cnc_machine_operation_tool(
        self,
        operation_id: str,
        id: int,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CncToolDto:
        """update_cnc_machine_operation_tool.

        :param operation_id: Required.
        :type operation_id: str
        :param id: Required.
        :type id: int
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CncToolDto
        :rtype: ~ignos.api.client.models.CncToolDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_cnc_machine_operation_tool(
        self,
        operation_id: str,
        id: int,
        body: Optional[Union[_models.UpdateCncMachineOperationToolRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.CncToolDto:
        """update_cnc_machine_operation_tool.

        :param operation_id: Required.
        :type operation_id: str
        :param id: Required.
        :type id: int
        :param body: Is either a UpdateCncMachineOperationToolRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.UpdateCncMachineOperationToolRequest or IO[bytes]
        :return: CncToolDto
        :rtype: ~ignos.api.client.models.CncToolDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CncToolDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateCncMachineOperationToolRequest")
            else:
                _json = None

        _request = build_cnc_setup_update_cnc_machine_operation_tool_request(
            operation_id=operation_id,
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncToolDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_cnc_machine_operation_tool(  # pylint: disable=inconsistent-return-statements
        self, operation_id: str, id: int, **kwargs: Any
    ) -> None:
        """delete_cnc_machine_operation_tool.

        :param operation_id: Required.
        :type operation_id: str
        :param id: Required.
        :type id: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_cnc_setup_delete_cnc_machine_operation_tool_request(
            operation_id=operation_id,
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def upload_operation_cnc_tool_image(
        self,
        operation_id: str,
        id: int,
        body: Optional[_models.UploadCncToolImageRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ImageFileDto:
        """upload_operation_cnc_tool_image.

        :param operation_id: Required.
        :type operation_id: str
        :param id: Required.
        :type id: int
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UploadCncToolImageRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ImageFileDto
        :rtype: ~ignos.api.client.models.ImageFileDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def upload_operation_cnc_tool_image(
        self,
        operation_id: str,
        id: int,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ImageFileDto:
        """upload_operation_cnc_tool_image.

        :param operation_id: Required.
        :type operation_id: str
        :param id: Required.
        :type id: int
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: ImageFileDto
        :rtype: ~ignos.api.client.models.ImageFileDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def upload_operation_cnc_tool_image(
        self,
        operation_id: str,
        id: int,
        body: Optional[Union[_models.UploadCncToolImageRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.ImageFileDto:
        """upload_operation_cnc_tool_image.

        :param operation_id: Required.
        :type operation_id: str
        :param id: Required.
        :type id: int
        :param body: Is either a UploadCncToolImageRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.UploadCncToolImageRequest or IO[bytes]
        :return: ImageFileDto
        :rtype: ~ignos.api.client.models.ImageFileDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ImageFileDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UploadCncToolImageRequest")
            else:
                _json = None

        _request = build_cnc_setup_upload_operation_cnc_tool_image_request(
            operation_id=operation_id,
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ImageFileDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_cnc_machine_operation_tool_image(  # pylint: disable=inconsistent-return-statements
        self, operation_id: str, id: int, filename: str, **kwargs: Any
    ) -> None:
        """delete_cnc_machine_operation_tool_image.

        :param operation_id: Required.
        :type operation_id: str
        :param id: Required.
        :type id: int
        :param filename: Required.
        :type filename: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_cnc_setup_delete_cnc_machine_operation_tool_image_request(
            operation_id=operation_id,
            id=id,
            filename=filename,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def create_cnc_machine_tool(
        self,
        id: str,
        body: Optional[_models.CreateCncMachineOperationToolRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CncToolDto:
        """create_cnc_machine_tool.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateCncMachineOperationToolRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CncToolDto
        :rtype: ~ignos.api.client.models.CncToolDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_cnc_machine_tool(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CncToolDto:
        """create_cnc_machine_tool.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CncToolDto
        :rtype: ~ignos.api.client.models.CncToolDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_cnc_machine_tool(
        self,
        id: str,
        body: Optional[Union[_models.CreateCncMachineOperationToolRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.CncToolDto:
        """create_cnc_machine_tool.

        :param id: Required.
        :type id: str
        :param body: Is either a CreateCncMachineOperationToolRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.CreateCncMachineOperationToolRequest or IO[bytes]
        :return: CncToolDto
        :rtype: ~ignos.api.client.models.CncToolDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CncToolDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateCncMachineOperationToolRequest")
            else:
                _json = None

        _request = build_cnc_setup_create_cnc_machine_tool_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncToolDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_cnc_tool_by_cnc_machine(self, id: str, **kwargs: Any) -> List[_models.CncToolDto]:
        """list_cnc_tool_by_cnc_machine.

        :param id: Required.
        :type id: str
        :return: list of CncToolDto
        :rtype: list[~ignos.api.client.models.CncToolDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CncToolDto]] = kwargs.pop("cls", None)

        _request = build_cnc_setup_list_cnc_tool_by_cnc_machine_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[CncToolDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_cnc_machine_tool(
        self,
        cnc_machine_id: str,
        id: int,
        body: Optional[_models.UpdateCncMachineToolRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CncToolDto:
        """update_cnc_machine_tool.

        :param cnc_machine_id: Required.
        :type cnc_machine_id: str
        :param id: Required.
        :type id: int
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateCncMachineToolRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CncToolDto
        :rtype: ~ignos.api.client.models.CncToolDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_cnc_machine_tool(
        self,
        cnc_machine_id: str,
        id: int,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CncToolDto:
        """update_cnc_machine_tool.

        :param cnc_machine_id: Required.
        :type cnc_machine_id: str
        :param id: Required.
        :type id: int
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CncToolDto
        :rtype: ~ignos.api.client.models.CncToolDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_cnc_machine_tool(
        self,
        cnc_machine_id: str,
        id: int,
        body: Optional[Union[_models.UpdateCncMachineToolRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.CncToolDto:
        """update_cnc_machine_tool.

        :param cnc_machine_id: Required.
        :type cnc_machine_id: str
        :param id: Required.
        :type id: int
        :param body: Is either a UpdateCncMachineToolRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.UpdateCncMachineToolRequest or IO[bytes]
        :return: CncToolDto
        :rtype: ~ignos.api.client.models.CncToolDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CncToolDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateCncMachineToolRequest")
            else:
                _json = None

        _request = build_cnc_setup_update_cnc_machine_tool_request(
            cnc_machine_id=cnc_machine_id,
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CncToolDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_cnc_machine_tool(  # pylint: disable=inconsistent-return-statements
        self, cnc_machine_id: str, id: int, **kwargs: Any
    ) -> None:
        """delete_cnc_machine_tool.

        :param cnc_machine_id: Required.
        :type cnc_machine_id: str
        :param id: Required.
        :type id: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_cnc_setup_delete_cnc_machine_tool_request(
            cnc_machine_id=cnc_machine_id,
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def upload_cnc_machine_tool_image(
        self,
        machine_id: str,
        id: int,
        body: Optional[_models.UploadCncToolImageRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ImageFileDto:
        """upload_cnc_machine_tool_image.

        :param machine_id: Required.
        :type machine_id: str
        :param id: Required.
        :type id: int
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UploadCncToolImageRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ImageFileDto
        :rtype: ~ignos.api.client.models.ImageFileDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def upload_cnc_machine_tool_image(
        self,
        machine_id: str,
        id: int,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ImageFileDto:
        """upload_cnc_machine_tool_image.

        :param machine_id: Required.
        :type machine_id: str
        :param id: Required.
        :type id: int
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: ImageFileDto
        :rtype: ~ignos.api.client.models.ImageFileDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def upload_cnc_machine_tool_image(
        self,
        machine_id: str,
        id: int,
        body: Optional[Union[_models.UploadCncToolImageRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.ImageFileDto:
        """upload_cnc_machine_tool_image.

        :param machine_id: Required.
        :type machine_id: str
        :param id: Required.
        :type id: int
        :param body: Is either a UploadCncToolImageRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.UploadCncToolImageRequest or IO[bytes]
        :return: ImageFileDto
        :rtype: ~ignos.api.client.models.ImageFileDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ImageFileDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UploadCncToolImageRequest")
            else:
                _json = None

        _request = build_cnc_setup_upload_cnc_machine_tool_image_request(
            machine_id=machine_id,
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ImageFileDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_cnc_machine_tool_image(  # pylint: disable=inconsistent-return-statements
        self, machine_id: str, id: int, filename: str, **kwargs: Any
    ) -> None:
        """delete_cnc_machine_tool_image.

        :param machine_id: Required.
        :type machine_id: str
        :param id: Required.
        :type id: int
        :param filename: Required.
        :type filename: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_cnc_setup_delete_cnc_machine_tool_image_request(
            machine_id=machine_id,
            id=id,
            filename=filename,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def import_operation_with_tools(  # pylint: disable=inconsistent-return-statements
        self,
        body: Optional[_models.ImportOperationWithTool] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """import_operation_with_tools.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ImportOperationWithTool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def import_operation_with_tools(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """import_operation_with_tools.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def import_operation_with_tools(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.ImportOperationWithTool, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """import_operation_with_tools.

        :param body: Is either a ImportOperationWithTool type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.ImportOperationWithTool or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ImportOperationWithTool")
            else:
                _json = None

        _request = build_cnc_setup_import_operation_with_tools_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class CncSetupAgentOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`cnc_setup_agent` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_cnc_agent_config(
        self, *, agent_id: Optional[str] = None, agent_version: Optional[str] = None, **kwargs: Any
    ) -> _models.AgentConfigDto:
        """get_cnc_agent_config.

        :keyword agent_id: Default value is None.
        :paramtype agent_id: str
        :keyword agent_version: Default value is None.
        :paramtype agent_version: str
        :return: AgentConfigDto
        :rtype: ~ignos.api.client.models.AgentConfigDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AgentConfigDto] = kwargs.pop("cls", None)

        _request = build_cnc_setup_agent_get_cnc_agent_config_request(
            agent_id=agent_id,
            agent_version=agent_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("AgentConfigDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_upload_programs_info(
        self,
        id: str,
        body: Optional[_models.UploadFileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.UploadFileDto]:
        """create_upload_programs_info.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UploadFileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of UploadFileDto
        :rtype: list[~ignos.api.client.models.UploadFileDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_upload_programs_info(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.UploadFileDto]:
        """create_upload_programs_info.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: list of UploadFileDto
        :rtype: list[~ignos.api.client.models.UploadFileDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_upload_programs_info(
        self, id: str, body: Optional[Union[_models.UploadFileRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> List[_models.UploadFileDto]:
        """create_upload_programs_info.

        :param id: Required.
        :type id: str
        :param body: Is either a UploadFileRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UploadFileRequest or IO[bytes]
        :return: list of UploadFileDto
        :rtype: list[~ignos.api.client.models.UploadFileDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.UploadFileDto]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UploadFileRequest")
            else:
                _json = None

        _request = build_cnc_setup_agent_create_upload_programs_info_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[UploadFileDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def set_transfer_status(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[_models.SetTransferStatusRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """set_transfer_status.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.SetTransferStatusRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def set_transfer_status(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """set_transfer_status.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def set_transfer_status(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[Union[_models.SetTransferStatusRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """set_transfer_status.

        :param id: Required.
        :type id: str
        :param body: Is either a SetTransferStatusRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.SetTransferStatusRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "SetTransferStatusRequest")
            else:
                _json = None

        _request = build_cnc_setup_agent_set_transfer_status_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class CountriesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`countries` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_countries(self, **kwargs: Any) -> List[_models.CountryDto]:
        """list_countries.

        :return: list of CountryDto
        :rtype: list[~ignos.api.client.models.CountryDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CountryDto]] = kwargs.pop("cls", None)

        _request = build_countries_list_countries_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[CountryDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class CustomersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`customers` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_current_customer(self, **kwargs: Any) -> _models.CurrentCustomerDto:
        """get_current_customer.

        :return: CurrentCustomerDto
        :rtype: ~ignos.api.client.models.CurrentCustomerDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CurrentCustomerDto] = kwargs.pop("cls", None)

        _request = build_customers_get_current_customer_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CurrentCustomerDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def upsert_customer(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[_models.UpsertCustomerRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Upsert a customer.

        Upsert a customer.

        :param id: Customer id. Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpsertCustomerRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def upsert_customer(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Upsert a customer.

        Upsert a customer.

        :param id: Customer id. Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def upsert_customer(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[Union[_models.UpsertCustomerRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """Upsert a customer.

        Upsert a customer.

        :param id: Customer id. Required.
        :type id: str
        :param body: Is either a UpsertCustomerRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UpsertCustomerRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpsertCustomerRequest")
            else:
                _json = None

        _request = build_customers_upsert_customer_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_customer(self, id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes a customer.

        Deletes a customer.

        :param id: Customer id. Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_customers_delete_customer_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_customers(
        self,
        *,
        page_size: int = 50,
        filter: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any
    ) -> _models.CustomerDtoPagedResult:
        """List customers.

        List customers.

        :keyword page_size: Page size. Default value is 50.
        :paramtype page_size: int
        :keyword filter: Filter customer name (contains). Default value is None.
        :paramtype filter: str
        :keyword continuation_token_parameter: Continuation token used for pagination. Default value is
         None.
        :paramtype continuation_token_parameter: str
        :return: CustomerDtoPagedResult
        :rtype: ~ignos.api.client.models.CustomerDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CustomerDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_customers_list_customers_request(
            page_size=page_size,
            filter=filter,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CustomerDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_list_customers(
        self,
        body: Optional[_models.ListCustomersRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CustomerDtoPagedResult:
        """post_list_customers.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListCustomersRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CustomerDtoPagedResult
        :rtype: ~ignos.api.client.models.CustomerDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_customers(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CustomerDtoPagedResult:
        """post_list_customers.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CustomerDtoPagedResult
        :rtype: ~ignos.api.client.models.CustomerDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_customers(
        self, body: Optional[Union[_models.ListCustomersRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CustomerDtoPagedResult:
        """post_list_customers.

        :param body: Is either a ListCustomersRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.ListCustomersRequest or IO[bytes]
        :return: CustomerDtoPagedResult
        :rtype: ~ignos.api.client.models.CustomerDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CustomerDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListCustomersRequest")
            else:
                _json = None

        _request = build_customers_post_list_customers_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CustomerDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_customer_groups(self, **kwargs: Any) -> List[_models.CustomerGroupDto]:
        """List customer groups.

        List customer groups.

        :return: list of CustomerGroupDto
        :rtype: list[~ignos.api.client.models.CustomerGroupDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CustomerGroupDto]] = kwargs.pop("cls", None)

        _request = build_customers_list_customer_groups_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[CustomerGroupDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def deactivate_customer(self, id: str, **kwargs: Any) -> _models.ProblemDetails:
        """Deactivates an existing customer.

        Deactivates an existing customer.

        :param id: Customer id. Required.
        :type id: str
        :return: ProblemDetails
        :rtype: ~ignos.api.client.models.ProblemDetails
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProblemDetails] = kwargs.pop("cls", None)

        _request = build_customers_deactivate_customer_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [404]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ProblemDetails", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_customer_mapping(  # pylint: disable=inconsistent-return-statements
        self,
        body: Optional[_models.CreateCustomerMapping] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Creates a customer mapping between old customer id and new customer id.

        Creates a customer mapping between old customer id and new customer id.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateCustomerMapping
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_customer_mapping(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Creates a customer mapping between old customer id and new customer id.

        Creates a customer mapping between old customer id and new customer id.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_customer_mapping(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.CreateCustomerMapping, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """Creates a customer mapping between old customer id and new customer id.

        Creates a customer mapping between old customer id and new customer id.

        :param body: Is either a CreateCustomerMapping type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CreateCustomerMapping or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateCustomerMapping")
            else:
                _json = None

        _request = build_customers_create_customer_mapping_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_customer_mappings(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete all customer mappings between old customer ids and new customer ids.

        Delete all customer mappings between old customer ids and new customer ids.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_customers_delete_customer_mappings_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class DocumentsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`documents` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def import_document(
        self, body: Optional[_models.ImportDocument] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ImportDocumentResultDto:
        """Import document with revisions from other systems.

        Import document with revisions from other systems.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ImportDocument
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ImportDocumentResultDto
        :rtype: ~ignos.api.client.models.ImportDocumentResultDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def import_document(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ImportDocumentResultDto:
        """Import document with revisions from other systems.

        Import document with revisions from other systems.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: ImportDocumentResultDto
        :rtype: ~ignos.api.client.models.ImportDocumentResultDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def import_document(
        self, body: Optional[Union[_models.ImportDocument, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.ImportDocumentResultDto:
        """Import document with revisions from other systems.

        Import document with revisions from other systems.

        :param body: Is either a ImportDocument type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.ImportDocument or IO[bytes]
        :return: ImportDocumentResultDto
        :rtype: ~ignos.api.client.models.ImportDocumentResultDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ImportDocumentResultDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ImportDocument")
            else:
                _json = None

        _request = build_documents_import_document_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ImportDocumentResultDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def check_if_imported_document_exists(
        self, *, imported_reference: Optional[str] = None, **kwargs: Any
    ) -> str:
        """Checks if a document exists with import reference. Returns document id if document exists.

        Checks if a document exists with import reference. Returns document id if document exists.

        :keyword imported_reference: Default value is None.
        :paramtype imported_reference: str
        :return: str
        :rtype: str
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[str] = kwargs.pop("cls", None)

        _request = build_documents_check_if_imported_document_exists_request(
            imported_reference=imported_reference,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("str", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class DocumentTypesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`document_types` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_document_types(
        self, *, include_inactive: bool = False, **kwargs: Any
    ) -> List[_models.DocumentTypeDto]:
        """list_document_types.

        :keyword include_inactive: Default value is False.
        :paramtype include_inactive: bool
        :return: list of DocumentTypeDto
        :rtype: list[~ignos.api.client.models.DocumentTypeDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DocumentTypeDto]] = kwargs.pop("cls", None)

        _request = build_document_types_list_document_types_request(
            include_inactive=include_inactive,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[DocumentTypeDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_document_type(
        self,
        body: Optional[_models.CreateDocumentTypeRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DocumentTypeDto:
        """create_document_type.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateDocumentTypeRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DocumentTypeDto
        :rtype: ~ignos.api.client.models.DocumentTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_document_type(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DocumentTypeDto:
        """create_document_type.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: DocumentTypeDto
        :rtype: ~ignos.api.client.models.DocumentTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_document_type(
        self, body: Optional[Union[_models.CreateDocumentTypeRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.DocumentTypeDto:
        """create_document_type.

        :param body: Is either a CreateDocumentTypeRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.CreateDocumentTypeRequest or IO[bytes]
        :return: DocumentTypeDto
        :rtype: ~ignos.api.client.models.DocumentTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DocumentTypeDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateDocumentTypeRequest")
            else:
                _json = None

        _request = build_document_types_create_document_type_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("DocumentTypeDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_document_type(self, id: str, **kwargs: Any) -> _models.DocumentTypeDto:
        """get_document_type.

        :param id: Required.
        :type id: str
        :return: DocumentTypeDto
        :rtype: ~ignos.api.client.models.DocumentTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DocumentTypeDto] = kwargs.pop("cls", None)

        _request = build_document_types_get_document_type_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("DocumentTypeDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_document_type(
        self,
        id: str,
        body: Optional[_models.UpdateDocumentTypeRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DocumentTypeDto:
        """update_document_type.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateDocumentTypeRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DocumentTypeDto
        :rtype: ~ignos.api.client.models.DocumentTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_document_type(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DocumentTypeDto:
        """update_document_type.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: DocumentTypeDto
        :rtype: ~ignos.api.client.models.DocumentTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_document_type(
        self, id: str, body: Optional[Union[_models.UpdateDocumentTypeRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.DocumentTypeDto:
        """update_document_type.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateDocumentTypeRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.UpdateDocumentTypeRequest or IO[bytes]
        :return: DocumentTypeDto
        :rtype: ~ignos.api.client.models.DocumentTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DocumentTypeDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateDocumentTypeRequest")
            else:
                _json = None

        _request = build_document_types_update_document_type_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("DocumentTypeDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_document_type(  # pylint: disable=inconsistent-return-statements
        self, id: str, **kwargs: Any
    ) -> None:
        """Delete document type. Only allowed if not used.

        Delete document type. Only allowed if not used.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_document_types_delete_document_type_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def activate_document_type(  # pylint: disable=inconsistent-return-statements
        self, id: str, **kwargs: Any
    ) -> None:
        """activate_document_type.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_document_types_activate_document_type_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def deactivate_document_type(  # pylint: disable=inconsistent-return-statements
        self, id: str, **kwargs: Any
    ) -> None:
        """deactivate_document_type.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_document_types_deactivate_document_type_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_document_type_rules(self, id: str, **kwargs: Any) -> List[_models.DocumentTypeRuleDto]:
        """list_document_type_rules.

        :param id: Required.
        :type id: str
        :return: list of DocumentTypeRuleDto
        :rtype: list[~ignos.api.client.models.DocumentTypeRuleDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DocumentTypeRuleDto]] = kwargs.pop("cls", None)

        _request = build_document_types_list_document_type_rules_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[DocumentTypeRuleDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_document_type_rules(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[_models.UpdateDocumentTypeRuleRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """update_document_type_rules.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateDocumentTypeRuleRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_document_type_rules(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """update_document_type_rules.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_document_type_rules(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[Union[_models.UpdateDocumentTypeRuleRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """update_document_type_rules.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateDocumentTypeRuleRequest type or a IO[bytes] type. Default value
         is None.
        :type body: ~ignos.api.client.models.UpdateDocumentTypeRuleRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateDocumentTypeRuleRequest")
            else:
                _json = None

        _request = build_document_types_update_document_type_rules_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_all_document_rule_types(self, **kwargs: Any) -> List[_models.DocumentTypeRuleTypeDto]:
        """list_all_document_rule_types.

        :return: list of DocumentTypeRuleTypeDto
        :rtype: list[~ignos.api.client.models.DocumentTypeRuleTypeDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DocumentTypeRuleTypeDto]] = kwargs.pop("cls", None)

        _request = build_document_types_list_all_document_rule_types_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[DocumentTypeRuleTypeDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_document_generators(self, **kwargs: Any) -> List[_models.DocumentGeneratorTypeDto]:
        """list_document_generators.

        :return: list of DocumentGeneratorTypeDto
        :rtype: list[~ignos.api.client.models.DocumentGeneratorTypeDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DocumentGeneratorTypeDto]] = kwargs.pop("cls", None)

        _request = build_document_types_list_document_generators_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[DocumentGeneratorTypeDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class CompaniesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`companies` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_production_companies(self, **kwargs: Any) -> List[_models.ProductionCompanyDto]:
        """list_production_companies.

        :return: list of ProductionCompanyDto
        :rtype: list[~ignos.api.client.models.ProductionCompanyDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProductionCompanyDto]] = kwargs.pop("cls", None)

        _request = build_companies_list_production_companies_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[ProductionCompanyDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def select_production_company(
        self,
        body: Optional[_models.SelectProductionCompany] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProductionCompanyDto:
        """select_production_company.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.SelectProductionCompany
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProductionCompanyDto
        :rtype: ~ignos.api.client.models.ProductionCompanyDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def select_production_company(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProductionCompanyDto:
        """select_production_company.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: ProductionCompanyDto
        :rtype: ~ignos.api.client.models.ProductionCompanyDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def select_production_company(
        self, body: Optional[Union[_models.SelectProductionCompany, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.ProductionCompanyDto:
        """select_production_company.

        :param body: Is either a SelectProductionCompany type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.SelectProductionCompany or IO[bytes]
        :return: ProductionCompanyDto
        :rtype: ~ignos.api.client.models.ProductionCompanyDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProductionCompanyDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "SelectProductionCompany")
            else:
                _json = None

        _request = build_companies_select_production_company_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ProductionCompanyDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class CustomerOrdersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`customer_orders` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def upsert_customer_order(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[_models.UpsertCustomerOrderRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Upsert a customer order.

        Upsert a customer order.

        :param id: Customer order id. Required.
        :type id: str
        :param body: Order details. Default value is None.
        :type body: ~ignos.api.client.models.UpsertCustomerOrderRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def upsert_customer_order(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Upsert a customer order.

        Upsert a customer order.

        :param id: Customer order id. Required.
        :type id: str
        :param body: Order details. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def upsert_customer_order(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[Union[_models.UpsertCustomerOrderRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """Upsert a customer order.

        Upsert a customer order.

        :param id: Customer order id. Required.
        :type id: str
        :param body: Order details. Is either a UpsertCustomerOrderRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.UpsertCustomerOrderRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpsertCustomerOrderRequest")
            else:
                _json = None

        _request = build_customer_orders_upsert_customer_order_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_customer_order(self, id: str, **kwargs: Any) -> _models.CustomerOrderDto:
        """get_customer_order.

        :param id: Required.
        :type id: str
        :return: CustomerOrderDto
        :rtype: ~ignos.api.client.models.CustomerOrderDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CustomerOrderDto] = kwargs.pop("cls", None)

        _request = build_customer_orders_get_customer_order_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CustomerOrderDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def upsert_customer_order_line(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        line: int,
        body: Optional[_models.CustomerOrderLineDto] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Upsert a customer order line. Customer order must exist.

        Upsert a customer order line. Customer order must exist.

        :param id: Customer order id. Required.
        :type id: str
        :param line: Customer order line. Required.
        :type line: int
        :param body: Order line details. Default value is None.
        :type body: ~ignos.api.client.models.CustomerOrderLineDto
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def upsert_customer_order_line(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        line: int,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Upsert a customer order line. Customer order must exist.

        Upsert a customer order line. Customer order must exist.

        :param id: Customer order id. Required.
        :type id: str
        :param line: Customer order line. Required.
        :type line: int
        :param body: Order line details. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def upsert_customer_order_line(  # pylint: disable=inconsistent-return-statements
        self, id: str, line: int, body: Optional[Union[_models.CustomerOrderLineDto, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """Upsert a customer order line. Customer order must exist.

        Upsert a customer order line. Customer order must exist.

        :param id: Customer order id. Required.
        :type id: str
        :param line: Customer order line. Required.
        :type line: int
        :param body: Order line details. Is either a CustomerOrderLineDto type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.CustomerOrderLineDto or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CustomerOrderLineDto")
            else:
                _json = None

        _request = build_customer_orders_upsert_customer_order_line_request(
            id=id,
            line=line,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_customer_orders(
        self,
        *,
        page_size: int = 50,
        filter: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any
    ) -> _models.CustomerOrderDtoPagedResult:
        """List customer orders.

        List customer orders.

        :keyword page_size: Page size. Default value is 50.
        :paramtype page_size: int
        :keyword filter: Filter customer order id or external ordernumber. Default value is None.
        :paramtype filter: str
        :keyword continuation_token_parameter: Continuation token used for pagination. Default value is
         None.
        :paramtype continuation_token_parameter: str
        :return: CustomerOrderDtoPagedResult
        :rtype: ~ignos.api.client.models.CustomerOrderDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CustomerOrderDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_customer_orders_list_customer_orders_request(
            page_size=page_size,
            filter=filter,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CustomerOrderDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_list_customer_orders(
        self,
        body: Optional[_models.ListCustomerOrdersRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CustomerOrderDtoPagedResult:
        """post_list_customer_orders.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListCustomerOrdersRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CustomerOrderDtoPagedResult
        :rtype: ~ignos.api.client.models.CustomerOrderDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_customer_orders(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CustomerOrderDtoPagedResult:
        """post_list_customer_orders.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CustomerOrderDtoPagedResult
        :rtype: ~ignos.api.client.models.CustomerOrderDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_customer_orders(
        self, body: Optional[Union[_models.ListCustomerOrdersRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CustomerOrderDtoPagedResult:
        """post_list_customer_orders.

        :param body: Is either a ListCustomerOrdersRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.ListCustomerOrdersRequest or IO[bytes]
        :return: CustomerOrderDtoPagedResult
        :rtype: ~ignos.api.client.models.CustomerOrderDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CustomerOrderDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListCustomerOrdersRequest")
            else:
                _json = None

        _request = build_customer_orders_post_list_customer_orders_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CustomerOrderDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_customer_order_lines(self, id: str, **kwargs: Any) -> List[_models.CustomerOrderLineDto]:
        """list_customer_order_lines.

        :param id: Required.
        :type id: str
        :return: list of CustomerOrderLineDto
        :rtype: list[~ignos.api.client.models.CustomerOrderLineDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CustomerOrderLineDto]] = kwargs.pop("cls", None)

        _request = build_customer_orders_list_customer_order_lines_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[CustomerOrderLineDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ResourcesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`resources` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_all_machines(self, **kwargs: Any) -> List[_models.MachineDto]:
        """list_all_machines.

        :return: list of MachineDto
        :rtype: list[~ignos.api.client.models.MachineDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MachineDto]] = kwargs.pop("cls", None)

        _request = build_resources_list_all_machines_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MachineDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class WorkordersOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`workorders` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def upsert_workorder(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[_models.UpsertWorkorder] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create or update a workorder.

        Create or update a workorder.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpsertWorkorder
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def upsert_workorder(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create or update a workorder.

        Create or update a workorder.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def upsert_workorder(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.UpsertWorkorder, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """Create or update a workorder.

        Create or update a workorder.

        :param body: Is either a UpsertWorkorder type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UpsertWorkorder or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpsertWorkorder")
            else:
                _json = None

        _request = build_workorders_upsert_workorder_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def upsert_workorder_v2(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[_models.UpsertWorkorderV2] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create or update a workorder.

        Create or update a workorder.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpsertWorkorderV2
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def upsert_workorder_v2(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create or update a workorder.

        Create or update a workorder.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def upsert_workorder_v2(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.UpsertWorkorderV2, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """Create or update a workorder.

        Create or update a workorder.

        :param body: Is either a UpsertWorkorderV2 type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UpsertWorkorderV2 or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpsertWorkorderV2")
            else:
                _json = None

        _request = build_workorders_upsert_workorder_v2_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_workorders(
        self,
        *,
        page_size: int = 50,
        search: Optional[str] = None,
        company_id: Optional[str] = None,
        active_orders: Optional[bool] = None,
        search_type: Optional[Union[str, _models.SearchTypeDto]] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any
    ) -> _models.WorkorderListDtoPagedResult:
        """List work orders.

        List work orders.

        :keyword page_size: Number of items per page. Default 50. Use -1 for dynamic page size. Default
         value is 50.
        :paramtype page_size: int
        :keyword search: Searches work order ID using starts with. Default value is None.
        :paramtype search: str
        :keyword company_id: The company the work order belongs to. Default value is None.
        :paramtype company_id: str
        :keyword active_orders: Searches active or inactive work orders. Use null to ignore. Default
         value is None.
        :paramtype active_orders: bool
        :keyword search_type: The matching strategy when searching on work order ID. The default is
         StartsWith. Known values are: "Contains", "StartsWith", "EndsWith", and "Equals". Default value
         is None.
        :paramtype search_type: str or ~ignos.api.client.models.SearchTypeDto
        :keyword continuation_token_parameter: Continuation token used for pagination. Default value is
         None.
        :paramtype continuation_token_parameter: str
        :return: WorkorderListDtoPagedResult
        :rtype: ~ignos.api.client.models.WorkorderListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkorderListDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_workorders_list_workorders_request(
            page_size=page_size,
            search=search,
            company_id=company_id,
            active_orders=active_orders,
            search_type=search_type,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkorderListDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def upsert_workorder_consumption(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[_models.UpsertWorkOrderConsumptionsRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Update consumed materials on work order.

        Update consumed materials on work order.

        :param id: Work order id. Required.
        :type id: str
        :param body: Consumption details. Default value is None.
        :type body: ~ignos.api.client.models.UpsertWorkOrderConsumptionsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def upsert_workorder_consumption(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Update consumed materials on work order.

        Update consumed materials on work order.

        :param id: Work order id. Required.
        :type id: str
        :param body: Consumption details. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def upsert_workorder_consumption(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[Union[_models.UpsertWorkOrderConsumptionsRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """Update consumed materials on work order.

        Update consumed materials on work order.

        :param id: Work order id. Required.
        :type id: str
        :param body: Consumption details. Is either a UpsertWorkOrderConsumptionsRequest type or a
         IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UpsertWorkOrderConsumptionsRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpsertWorkOrderConsumptionsRequest")
            else:
                _json = None

        _request = build_workorders_upsert_workorder_consumption_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_work_order_consumption(self, id: str, **kwargs: Any) -> _models.WorkOrderConsumptionDto:
        """get_work_order_consumption.

        :param id: Required.
        :type id: str
        :return: WorkOrderConsumptionDto
        :rtype: ~ignos.api.client.models.WorkOrderConsumptionDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkOrderConsumptionDto] = kwargs.pop("cls", None)

        _request = build_workorders_get_work_order_consumption_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkOrderConsumptionDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def upsert_workorder_traces(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[_models.UpsertWorkOrderTracesRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Create or update trace information for a workorder.

        Create or update trace information for a workorder.

        :param id: Workorder id. Required.
        :type id: str
        :param body: Trace details. Default value is None.
        :type body: ~ignos.api.client.models.UpsertWorkOrderTracesRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def upsert_workorder_traces(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create or update trace information for a workorder.

        Create or update trace information for a workorder.

        :param id: Workorder id. Required.
        :type id: str
        :param body: Trace details. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def upsert_workorder_traces(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[Union[_models.UpsertWorkOrderTracesRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """Create or update trace information for a workorder.

        Create or update trace information for a workorder.

        :param id: Workorder id. Required.
        :type id: str
        :param body: Trace details. Is either a UpsertWorkOrderTracesRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.UpsertWorkOrderTracesRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpsertWorkOrderTracesRequest")
            else:
                _json = None

        _request = build_workorders_upsert_workorder_traces_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def set_workorder_customer_order_reference(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[_models.WorkorderCustomerOrderReferenceDto] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """set_workorder_customer_order_reference.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.WorkorderCustomerOrderReferenceDto
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def set_workorder_customer_order_reference(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """set_workorder_customer_order_reference.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def set_workorder_customer_order_reference(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[Union[_models.WorkorderCustomerOrderReferenceDto, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """set_workorder_customer_order_reference.

        :param id: Required.
        :type id: str
        :param body: Is either a WorkorderCustomerOrderReferenceDto type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.WorkorderCustomerOrderReferenceDto or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "WorkorderCustomerOrderReferenceDto")
            else:
                _json = None

        _request = build_workorders_set_workorder_customer_order_reference_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def check_resource_status(self, id: str, **kwargs: Any) -> _models.ResourceExistDto:
        """check_resource_status.

        :param id: Required.
        :type id: str
        :return: ResourceExistDto
        :rtype: ~ignos.api.client.models.ResourceExistDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ResourceExistDto] = kwargs.pop("cls", None)

        _request = build_workorders_check_resource_status_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ResourceExistDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def start_workorder_operation(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        operation: int,
        body: Optional[_models.StartWorkOperationRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Register start work or setup on a workorder operation.

        Register start work or setup on a workorder operation.

        :param id: Required.
        :type id: str
        :param operation: Required.
        :type operation: int
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.StartWorkOperationRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def start_workorder_operation(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        operation: int,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Register start work or setup on a workorder operation.

        Register start work or setup on a workorder operation.

        :param id: Required.
        :type id: str
        :param operation: Required.
        :type operation: int
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def start_workorder_operation(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        operation: int,
        body: Optional[Union[_models.StartWorkOperationRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """Register start work or setup on a workorder operation.

        Register start work or setup on a workorder operation.

        :param id: Required.
        :type id: str
        :param operation: Required.
        :type operation: int
        :param body: Is either a StartWorkOperationRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.StartWorkOperationRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "StartWorkOperationRequest")
            else:
                _json = None

        _request = build_workorders_start_workorder_operation_request(
            id=id,
            operation=operation,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def stop_workorder_operation(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        operation: int,
        body: Optional[_models.StopWorkOperationRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Register end work or setup on a workorder operation.

        Register end work or setup on a workorder operation.

        :param id: Required.
        :type id: str
        :param operation: Required.
        :type operation: int
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.StopWorkOperationRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def stop_workorder_operation(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        operation: int,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Register end work or setup on a workorder operation.

        Register end work or setup on a workorder operation.

        :param id: Required.
        :type id: str
        :param operation: Required.
        :type operation: int
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def stop_workorder_operation(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        operation: int,
        body: Optional[Union[_models.StopWorkOperationRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """Register end work or setup on a workorder operation.

        Register end work or setup on a workorder operation.

        :param id: Required.
        :type id: str
        :param operation: Required.
        :type operation: int
        :param body: Is either a StopWorkOperationRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.StopWorkOperationRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "StopWorkOperationRequest")
            else:
                _json = None

        _request = build_workorders_stop_workorder_operation_request(
            id=id,
            operation=operation,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def register_workorder_operation_event(
        self,
        id: str,
        operation: int,
        body: Optional[_models.RegisterWorkorderOperationEventRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkorderOperationEventDto:
        """Register a completed work order operation event.

        Register a completed work order operation event.

        :param id: Required.
        :type id: str
        :param operation: Required.
        :type operation: int
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.RegisterWorkorderOperationEventRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkorderOperationEventDto
        :rtype: ~ignos.api.client.models.WorkorderOperationEventDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def register_workorder_operation_event(
        self,
        id: str,
        operation: int,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkorderOperationEventDto:
        """Register a completed work order operation event.

        Register a completed work order operation event.

        :param id: Required.
        :type id: str
        :param operation: Required.
        :type operation: int
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: WorkorderOperationEventDto
        :rtype: ~ignos.api.client.models.WorkorderOperationEventDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def register_workorder_operation_event(
        self,
        id: str,
        operation: int,
        body: Optional[Union[_models.RegisterWorkorderOperationEventRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.WorkorderOperationEventDto:
        """Register a completed work order operation event.

        Register a completed work order operation event.

        :param id: Required.
        :type id: str
        :param operation: Required.
        :type operation: int
        :param body: Is either a RegisterWorkorderOperationEventRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.RegisterWorkorderOperationEventRequest or IO[bytes]
        :return: WorkorderOperationEventDto
        :rtype: ~ignos.api.client.models.WorkorderOperationEventDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkorderOperationEventDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "RegisterWorkorderOperationEventRequest")
            else:
                _json = None

        _request = build_workorders_register_workorder_operation_event_request(
            id=id,
            operation=operation,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkorderOperationEventDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def start_workorder_operation_v2(
        self,
        id: str,
        operation: int,
        body: Optional[_models.StartWorkOperationRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkorderOperationEventDto:
        """Register start work or setup on a workorder operation.

        Register start work or setup on a workorder operation.

        :param id: Required.
        :type id: str
        :param operation: Required.
        :type operation: int
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.StartWorkOperationRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkorderOperationEventDto
        :rtype: ~ignos.api.client.models.WorkorderOperationEventDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def start_workorder_operation_v2(
        self,
        id: str,
        operation: int,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkorderOperationEventDto:
        """Register start work or setup on a workorder operation.

        Register start work or setup on a workorder operation.

        :param id: Required.
        :type id: str
        :param operation: Required.
        :type operation: int
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: WorkorderOperationEventDto
        :rtype: ~ignos.api.client.models.WorkorderOperationEventDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def start_workorder_operation_v2(
        self,
        id: str,
        operation: int,
        body: Optional[Union[_models.StartWorkOperationRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.WorkorderOperationEventDto:
        """Register start work or setup on a workorder operation.

        Register start work or setup on a workorder operation.

        :param id: Required.
        :type id: str
        :param operation: Required.
        :type operation: int
        :param body: Is either a StartWorkOperationRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.StartWorkOperationRequest or IO[bytes]
        :return: WorkorderOperationEventDto
        :rtype: ~ignos.api.client.models.WorkorderOperationEventDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkorderOperationEventDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "StartWorkOperationRequest")
            else:
                _json = None

        _request = build_workorders_start_workorder_operation_v2_request(
            id=id,
            operation=operation,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkorderOperationEventDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def stop_workorder_operation_v2(
        self,
        id: str,
        operation: int,
        body: Optional[_models.StopWorkOperationRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkorderOperationEventDto:
        """Register end work or setup on a workorder operation.

        Register end work or setup on a workorder operation.

        :param id: Required.
        :type id: str
        :param operation: Required.
        :type operation: int
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.StopWorkOperationRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkorderOperationEventDto
        :rtype: ~ignos.api.client.models.WorkorderOperationEventDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def stop_workorder_operation_v2(
        self,
        id: str,
        operation: int,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkorderOperationEventDto:
        """Register end work or setup on a workorder operation.

        Register end work or setup on a workorder operation.

        :param id: Required.
        :type id: str
        :param operation: Required.
        :type operation: int
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: WorkorderOperationEventDto
        :rtype: ~ignos.api.client.models.WorkorderOperationEventDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def stop_workorder_operation_v2(
        self,
        id: str,
        operation: int,
        body: Optional[Union[_models.StopWorkOperationRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.WorkorderOperationEventDto:
        """Register end work or setup on a workorder operation.

        Register end work or setup on a workorder operation.

        :param id: Required.
        :type id: str
        :param operation: Required.
        :type operation: int
        :param body: Is either a StopWorkOperationRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.StopWorkOperationRequest or IO[bytes]
        :return: WorkorderOperationEventDto
        :rtype: ~ignos.api.client.models.WorkorderOperationEventDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkorderOperationEventDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "StopWorkOperationRequest")
            else:
                _json = None

        _request = build_workorders_stop_workorder_operation_v2_request(
            id=id,
            operation=operation,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkorderOperationEventDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_active_workorder_operations(self, **kwargs: Any) -> List[_models.WorkorderOperationEventDto]:
        """list_active_workorder_operations.

        :return: list of WorkorderOperationEventDto
        :rtype: list[~ignos.api.client.models.WorkorderOperationEventDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkorderOperationEventDto]] = kwargs.pop("cls", None)

        _request = build_workorders_list_active_workorder_operations_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[WorkorderOperationEventDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_workorder_operation_event(  # pylint: disable=inconsistent-return-statements
        self, id: str, operation: int, event_id: str, **kwargs: Any
    ) -> None:
        """delete_workorder_operation_event.

        :param id: Required.
        :type id: str
        :param operation: Required.
        :type operation: int
        :param event_id: Required.
        :type event_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workorders_delete_workorder_operation_event_request(
            id=id,
            operation=operation,
            event_id=event_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_workorder(self, id: str, **kwargs: Any) -> _models.WorkorderDto:
        """Get a specific work order.

        Get a specific work order.

        :param id: The work order ID. Required.
        :type id: str
        :return: WorkorderDto
        :rtype: ~ignos.api.client.models.WorkorderDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkorderDto] = kwargs.pop("cls", None)

        _request = build_workorders_get_workorder_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkorderDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_workorder(self, id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes a specific work order.

        Deletes a specific work order.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workorders_delete_workorder_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def post_list_workorders(
        self,
        body: Optional[_models.ListWorkOrdersRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkorderListDtoPagedResult:
        """post_list_workorders.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListWorkOrdersRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkorderListDtoPagedResult
        :rtype: ~ignos.api.client.models.WorkorderListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_workorders(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.WorkorderListDtoPagedResult:
        """post_list_workorders.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: WorkorderListDtoPagedResult
        :rtype: ~ignos.api.client.models.WorkorderListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_workorders(
        self, body: Optional[Union[_models.ListWorkOrdersRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.WorkorderListDtoPagedResult:
        """post_list_workorders.

        :param body: Is either a ListWorkOrdersRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.ListWorkOrdersRequest or IO[bytes]
        :return: WorkorderListDtoPagedResult
        :rtype: ~ignos.api.client.models.WorkorderListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkorderListDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListWorkOrdersRequest")
            else:
                _json = None

        _request = build_workorders_post_list_workorders_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkorderListDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_workorder_operation_event(self, event_id: str, **kwargs: Any) -> _models.WorkorderOperationEventDto:
        """Get a specific work order operation event.

        Get a specific work order operation event.

        :param event_id: The ID of the event. Required.
        :type event_id: str
        :return: WorkorderOperationEventDto
        :rtype: ~ignos.api.client.models.WorkorderOperationEventDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkorderOperationEventDto] = kwargs.pop("cls", None)

        _request = build_workorders_get_workorder_operation_event_request(
            event_id=event_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkorderOperationEventDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_workorder_operation_event_timestamps(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        event_id: str,
        body: Optional[_models.UpdateWorkorderOperationEventTimestamps] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Update start time and/or end time of an existing work order operation event.

        Update start time and/or end time of an existing work order operation event.

        :param event_id: Required.
        :type event_id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateWorkorderOperationEventTimestamps
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_workorder_operation_event_timestamps(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, event_id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Update start time and/or end time of an existing work order operation event.

        Update start time and/or end time of an existing work order operation event.

        :param event_id: Required.
        :type event_id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_workorder_operation_event_timestamps(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        event_id: str,
        body: Optional[Union[_models.UpdateWorkorderOperationEventTimestamps, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """Update start time and/or end time of an existing work order operation event.

        Update start time and/or end time of an existing work order operation event.

        :param event_id: Required.
        :type event_id: str
        :param body: Is either a UpdateWorkorderOperationEventTimestamps type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.UpdateWorkorderOperationEventTimestamps or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateWorkorderOperationEventTimestamps")
            else:
                _json = None

        _request = build_workorders_update_workorder_operation_event_timestamps_request(
            event_id=event_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def filter_workorder_operation_events(
        self,
        body: Optional[_models.FilterWorkorderOperationEvents] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.WorkorderOperationEventDto]:
        """Filter work order operation events.

        Filter work order operation events.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.FilterWorkorderOperationEvents
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of WorkorderOperationEventDto
        :rtype: list[~ignos.api.client.models.WorkorderOperationEventDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def filter_workorder_operation_events(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.WorkorderOperationEventDto]:
        """Filter work order operation events.

        Filter work order operation events.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: list of WorkorderOperationEventDto
        :rtype: list[~ignos.api.client.models.WorkorderOperationEventDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def filter_workorder_operation_events(
        self, body: Optional[Union[_models.FilterWorkorderOperationEvents, IO[bytes]]] = None, **kwargs: Any
    ) -> List[_models.WorkorderOperationEventDto]:
        """Filter work order operation events.

        Filter work order operation events.

        :param body: Is either a FilterWorkorderOperationEvents type or a IO[bytes] type. Default value
         is None.
        :type body: ~ignos.api.client.models.FilterWorkorderOperationEvents or IO[bytes]
        :return: list of WorkorderOperationEventDto
        :rtype: list[~ignos.api.client.models.WorkorderOperationEventDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.WorkorderOperationEventDto]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "FilterWorkorderOperationEvents")
            else:
                _json = None

        _request = build_workorders_filter_workorder_operation_events_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[WorkorderOperationEventDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_work_order_mapping(  # pylint: disable=inconsistent-return-statements
        self,
        body: Optional[_models.CreateWorkOrderMapping] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Creates a work order mapping between old id and new work order id.

        Creates a work order mapping between old id and new work order id.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateWorkOrderMapping
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_work_order_mapping(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Creates a work order mapping between old id and new work order id.

        Creates a work order mapping between old id and new work order id.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_work_order_mapping(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.CreateWorkOrderMapping, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """Creates a work order mapping between old id and new work order id.

        Creates a work order mapping between old id and new work order id.

        :param body: Is either a CreateWorkOrderMapping type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.CreateWorkOrderMapping or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateWorkOrderMapping")
            else:
                _json = None

        _request = build_workorders_create_work_order_mapping_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_work_order_mappings(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deleteds existing work order mappings.

        Deleteds existing work order mappings.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workorders_delete_work_order_mappings_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def search_work_orders(
        self, *, input: Optional[str] = None, **kwargs: Any
    ) -> List[_models.SearchWorkOrderDto]:
        """search_work_orders.

        :keyword input: Default value is None.
        :paramtype input: str
        :return: list of SearchWorkOrderDto
        :rtype: list[~ignos.api.client.models.SearchWorkOrderDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SearchWorkOrderDto]] = kwargs.pop("cls", None)

        _request = build_workorders_search_work_orders_request(
            input=input,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[SearchWorkOrderDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ExternalOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`external` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_invites(self, **kwargs: Any) -> List[_models.InviteDto]:
        """list_invites.

        :return: list of InviteDto
        :rtype: list[~ignos.api.client.models.InviteDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.InviteDto]] = kwargs.pop("cls", None)

        _request = build_external_list_invites_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[InviteDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def accept_supplier_invite(
        self,
        body: Optional[_models.AcceptSupplierInviteRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CompanyDto:
        """accept_supplier_invite.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.AcceptSupplierInviteRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CompanyDto
        :rtype: ~ignos.api.client.models.CompanyDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def accept_supplier_invite(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CompanyDto:
        """accept_supplier_invite.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CompanyDto
        :rtype: ~ignos.api.client.models.CompanyDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def accept_supplier_invite(
        self, body: Optional[Union[_models.AcceptSupplierInviteRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CompanyDto:
        """accept_supplier_invite.

        :param body: Is either a AcceptSupplierInviteRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.AcceptSupplierInviteRequest or IO[bytes]
        :return: CompanyDto
        :rtype: ~ignos.api.client.models.CompanyDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CompanyDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "AcceptSupplierInviteRequest")
            else:
                _json = None

        _request = build_external_accept_supplier_invite_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CompanyDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_companies(self, **kwargs: Any) -> List[_models.CompanyDto]:
        """list_companies.

        :return: list of CompanyDto
        :rtype: list[~ignos.api.client.models.CompanyDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CompanyDto]] = kwargs.pop("cls", None)

        _request = build_external_list_companies_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[CompanyDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ExternalAccessOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`external_access` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_users(self, *, company_id: Optional[str] = None, **kwargs: Any) -> List[_models.CompanyUserDto]:
        """list_users.

        :keyword company_id: Default value is None.
        :paramtype company_id: str
        :return: list of CompanyUserDto
        :rtype: list[~ignos.api.client.models.CompanyUserDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CompanyUserDto]] = kwargs.pop("cls", None)

        _request = build_external_access_list_users_request(
            company_id=company_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[CompanyUserDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_company_user(
        self,
        body: Optional[_models.CreateCompanyUserRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CompanyUserDto:
        """create_company_user.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateCompanyUserRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CompanyUserDto
        :rtype: ~ignos.api.client.models.CompanyUserDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_company_user(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CompanyUserDto:
        """create_company_user.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CompanyUserDto
        :rtype: ~ignos.api.client.models.CompanyUserDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_company_user(
        self, body: Optional[Union[_models.CreateCompanyUserRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CompanyUserDto:
        """create_company_user.

        :param body: Is either a CreateCompanyUserRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.CreateCompanyUserRequest or IO[bytes]
        :return: CompanyUserDto
        :rtype: ~ignos.api.client.models.CompanyUserDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CompanyUserDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateCompanyUserRequest")
            else:
                _json = None

        _request = build_external_access_create_company_user_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CompanyUserDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_company_user(
        self,
        id: str,
        body: Optional[_models.UpdateCompanyUserRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CompanyUserDto:
        """update_company_user.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateCompanyUserRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CompanyUserDto
        :rtype: ~ignos.api.client.models.CompanyUserDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_company_user(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CompanyUserDto:
        """update_company_user.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CompanyUserDto
        :rtype: ~ignos.api.client.models.CompanyUserDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_company_user(
        self, id: str, body: Optional[Union[_models.UpdateCompanyUserRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CompanyUserDto:
        """update_company_user.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateCompanyUserRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.UpdateCompanyUserRequest or IO[bytes]
        :return: CompanyUserDto
        :rtype: ~ignos.api.client.models.CompanyUserDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CompanyUserDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateCompanyUserRequest")
            else:
                _json = None

        _request = build_external_access_update_company_user_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CompanyUserDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_company_user(  # pylint: disable=inconsistent-return-statements
        self, id: str, *, company_id: Optional[str] = None, **kwargs: Any
    ) -> None:
        """delete_company_user.

        :param id: Required.
        :type id: str
        :keyword company_id: Default value is None.
        :paramtype company_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_external_access_delete_company_user_request(
            id=id,
            company_id=company_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_roles(self, **kwargs: Any) -> List[_models.ExternalRoleDto]:
        """list_roles.

        :return: list of ExternalRoleDto
        :rtype: list[~ignos.api.client.models.ExternalRoleDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ExternalRoleDto]] = kwargs.pop("cls", None)

        _request = build_external_access_list_roles_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[ExternalRoleDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_company_customers(self, **kwargs: Any) -> List[_models.CompanyCustomerDto]:
        """list_company_customers.

        :return: list of CompanyCustomerDto
        :rtype: list[~ignos.api.client.models.CompanyCustomerDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CompanyCustomerDto]] = kwargs.pop("cls", None)

        _request = build_external_access_list_company_customers_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[CompanyCustomerDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_company_customer(  # pylint: disable=inconsistent-return-statements
        self, tenant_id: str, **kwargs: Any
    ) -> None:
        """delete_company_customer.

        :param tenant_id: Required.
        :type tenant_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_external_access_delete_company_customer_request(
            tenant_id=tenant_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class ExternalServicesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`external_services` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_credential(
        self, service_name: Union[str, _models.ExternalServiceName], **kwargs: Any
    ) -> _models.ExternalServiceCredentialDto:
        """get_credential.

        :param service_name: Known values are: "DbExtractor", "MtConnectExtractor", and
         "MqttConnector". Required.
        :type service_name: str or ~ignos.api.client.models.ExternalServiceName
        :return: ExternalServiceCredentialDto
        :rtype: ~ignos.api.client.models.ExternalServiceCredentialDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ExternalServiceCredentialDto] = kwargs.pop("cls", None)

        _request = build_external_services_get_credential_request(
            service_name=service_name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ExternalServiceCredentialDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ElectricalOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`electrical` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_electrical_source_types(self, **kwargs: Any) -> List[_models.IotTypeSourceDto]:
        """list_electrical_source_types.

        :return: list of IotTypeSourceDto
        :rtype: list[~ignos.api.client.models.IotTypeSourceDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.IotTypeSourceDto]] = kwargs.pop("cls", None)

        _request = build_electrical_list_electrical_source_types_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[IotTypeSourceDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_electrical_data_configs(self, **kwargs: Any) -> List[_models.ElectricalIotConfigDto]:
        """list_electrical_data_configs.

        :return: list of ElectricalIotConfigDto
        :rtype: list[~ignos.api.client.models.ElectricalIotConfigDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ElectricalIotConfigDto]] = kwargs.pop("cls", None)

        _request = build_electrical_list_electrical_data_configs_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[ElectricalIotConfigDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_electrical_iot_config(
        self,
        body: Optional[_models.CreateElectricalIotConfig] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ElectricalIotConfigDto:
        """create_electrical_iot_config.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateElectricalIotConfig
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ElectricalIotConfigDto
        :rtype: ~ignos.api.client.models.ElectricalIotConfigDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_electrical_iot_config(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ElectricalIotConfigDto:
        """create_electrical_iot_config.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: ElectricalIotConfigDto
        :rtype: ~ignos.api.client.models.ElectricalIotConfigDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_electrical_iot_config(
        self, body: Optional[Union[_models.CreateElectricalIotConfig, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.ElectricalIotConfigDto:
        """create_electrical_iot_config.

        :param body: Is either a CreateElectricalIotConfig type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.CreateElectricalIotConfig or IO[bytes]
        :return: ElectricalIotConfigDto
        :rtype: ~ignos.api.client.models.ElectricalIotConfigDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ElectricalIotConfigDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateElectricalIotConfig")
            else:
                _json = None

        _request = build_electrical_create_electrical_iot_config_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ElectricalIotConfigDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_electrical_iot_config(  # pylint: disable=inconsistent-return-statements
        self, type_id: str, id: str, **kwargs: Any
    ) -> None:
        """delete_electrical_iot_config.

        :param type_id: Required.
        :type type_id: str
        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_electrical_delete_electrical_iot_config_request(
            type_id=type_id,
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class WeldingOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`welding` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_welding_source_types(self, **kwargs: Any) -> List[_models.IotTypeSourceDto]:
        """list_welding_source_types.

        :return: list of IotTypeSourceDto
        :rtype: list[~ignos.api.client.models.IotTypeSourceDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.IotTypeSourceDto]] = kwargs.pop("cls", None)

        _request = build_welding_list_welding_source_types_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[IotTypeSourceDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_electrical_data_configs(self, **kwargs: Any) -> List[JSON]:
        """list_electrical_data_configs.

        :return: list of JSON
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_welding_list_electrical_data_configs_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[object]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def create_welding_iot_config(self, body: Optional[JSON] = None, **kwargs: Any) -> JSON:
        """create_welding_iot_config.

        :param body: Default value is None.
        :type body: JSON
        :return: JSON
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        if body is not None:
            _json = self._serialize.body(body, "object")
        else:
            _json = None

        _request = build_welding_create_welding_iot_config_request(
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_welding_iot_config(  # pylint: disable=inconsistent-return-statements
        self, type_id: str, id: str, **kwargs: Any
    ) -> None:
        """delete_welding_iot_config.

        :param type_id: Required.
        :type type_id: str
        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_welding_delete_welding_iot_config_request(
            type_id=type_id,
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class LinksOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`links` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_all_links(self, *, scope: Optional[str] = None, **kwargs: Any) -> List[_models.LinkDto]:
        """get_all_links.

        :keyword scope: Default value is None.
        :paramtype scope: str
        :return: list of LinkDto
        :rtype: list[~ignos.api.client.models.LinkDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LinkDto]] = kwargs.pop("cls", None)

        _request = build_links_get_all_links_request(
            scope=scope,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[LinkDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_link(
        self, body: Optional[_models.CreateLinkRequest] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LinkDto:
        """create_link.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateLinkRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LinkDto
        :rtype: ~ignos.api.client.models.LinkDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_link(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LinkDto:
        """create_link.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: LinkDto
        :rtype: ~ignos.api.client.models.LinkDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_link(
        self, body: Optional[Union[_models.CreateLinkRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.LinkDto:
        """create_link.

        :param body: Is either a CreateLinkRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CreateLinkRequest or IO[bytes]
        :return: LinkDto
        :rtype: ~ignos.api.client.models.LinkDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.LinkDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateLinkRequest")
            else:
                _json = None

        _request = build_links_create_link_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("LinkDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_all_link_scopes(self, **kwargs: Any) -> List[str]:
        """get_all_link_scopes.

        :return: list of str
        :rtype: list[str]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[str]] = kwargs.pop("cls", None)

        _request = build_links_get_all_link_scopes_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[str]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_link(  # pylint: disable=inconsistent-return-statements
        self, id: str, *, scope: Optional[str] = None, **kwargs: Any
    ) -> None:
        """delete_link.

        :param id: Required.
        :type id: str
        :keyword scope: Default value is None.
        :paramtype scope: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_links_delete_link_request(
            id=id,
            scope=scope,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class LocationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`locations` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def search_locations(
        self,
        *,
        input: Optional[str] = None,
        location_kinds: Optional[List[Union[str, _models.LocationKindDto]]] = None,
        **kwargs: Any
    ) -> List[_models.LocationDto]:
        """search_locations.

        :keyword input: Default value is None.
        :paramtype input: str
        :keyword location_kinds: Default value is None.
        :paramtype location_kinds: list[str or ~ignos.api.client.models.LocationKindDto]
        :return: list of LocationDto
        :rtype: list[~ignos.api.client.models.LocationDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LocationDto]] = kwargs.pop("cls", None)

        _request = build_locations_search_locations_request(
            input=input,
            location_kinds=location_kinds,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[LocationDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def suggestions_locations(
        self,
        *,
        work_order_id: Optional[str] = None,
        location_kinds: Optional[List[Union[str, _models.LocationKindDto]]] = None,
        **kwargs: Any
    ) -> List[_models.LocationDto]:
        """suggestions_locations.

        :keyword work_order_id: Default value is None.
        :paramtype work_order_id: str
        :keyword location_kinds: Default value is None.
        :paramtype location_kinds: list[str or ~ignos.api.client.models.LocationKindDto]
        :return: list of LocationDto
        :rtype: list[~ignos.api.client.models.LocationDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LocationDto]] = kwargs.pop("cls", None)

        _request = build_locations_suggestions_locations_request(
            work_order_id=work_order_id,
            location_kinds=location_kinds,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[LocationDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MachineAlarmsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`machine_alarms` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_machine_alarms(
        self,
        *,
        alarm_type: Optional[Union[str, _models.MachineAlarmType]] = None,
        asset_id: Optional[int] = None,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        sub_type: Optional[str] = None,
        native_code: Optional[str] = None,
        native_severity: Optional[int] = None,
        name: Optional[str] = None,
        sequence: Optional[str] = None,
        limit: int = 100,
        continuation_token_parameter: Optional[str] = None,
        order_by: Optional[str] = None,
        sort_direction: Optional[str] = None,
        **kwargs: Any
    ) -> _models.MachineAlarmDtoPagedResult:
        """list_machine_alarms.

        :keyword alarm_type: Known values are: "Fault" and "Warning". Default value is None.
        :paramtype alarm_type: str or ~ignos.api.client.models.MachineAlarmType
        :keyword asset_id: Default value is None.
        :paramtype asset_id: int
        :keyword start_time: Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: Default value is None.
        :paramtype end_time: ~datetime.datetime
        :keyword sub_type: Default value is None.
        :paramtype sub_type: str
        :keyword native_code: Default value is None.
        :paramtype native_code: str
        :keyword native_severity: Default value is None.
        :paramtype native_severity: int
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword sequence: Default value is None.
        :paramtype sequence: str
        :keyword limit: Default value is 100.
        :paramtype limit: int
        :keyword continuation_token_parameter: Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword order_by: Default value is None.
        :paramtype order_by: str
        :keyword sort_direction: Default value is None.
        :paramtype sort_direction: str
        :return: MachineAlarmDtoPagedResult
        :rtype: ~ignos.api.client.models.MachineAlarmDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MachineAlarmDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_machine_alarms_list_machine_alarms_request(
            alarm_type=alarm_type,
            asset_id=asset_id,
            start_time=start_time,
            end_time=end_time,
            sub_type=sub_type,
            native_code=native_code,
            native_severity=native_severity,
            name=name,
            sequence=sequence,
            limit=limit,
            continuation_token_parameter=continuation_token_parameter,
            order_by=order_by,
            sort_direction=sort_direction,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MachineAlarmDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_alarms_per_machine(
        self,
        *,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> List[_models.MachineAlarmSummaryDto]:
        """list_alarms_per_machine.

        :keyword start_time: Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: Default value is None.
        :paramtype end_time: ~datetime.datetime
        :return: list of MachineAlarmSummaryDto
        :rtype: list[~ignos.api.client.models.MachineAlarmSummaryDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MachineAlarmSummaryDto]] = kwargs.pop("cls", None)

        _request = build_machine_alarms_list_alarms_per_machine_request(
            start_time=start_time,
            end_time=end_time,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MachineAlarmSummaryDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_alarm_severity_occurrences(
        self,
        *,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> List[_models.MachineAlarmSeverityOccurenceDto]:
        """list_alarm_severity_occurrences.

        :keyword start_time: Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: Default value is None.
        :paramtype end_time: ~datetime.datetime
        :return: list of MachineAlarmSeverityOccurenceDto
        :rtype: list[~ignos.api.client.models.MachineAlarmSeverityOccurenceDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MachineAlarmSeverityOccurenceDto]] = kwargs.pop("cls", None)

        _request = build_machine_alarms_list_alarm_severity_occurrences_request(
            start_time=start_time,
            end_time=end_time,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MachineAlarmSeverityOccurenceDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def count_machine_alarms(
        self,
        *,
        alarm_type: Optional[Union[str, _models.MachineAlarmType]] = None,
        asset_id: Optional[int] = None,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        sub_type: Optional[str] = None,
        native_code: Optional[str] = None,
        native_severity: Optional[int] = None,
        name: Optional[str] = None,
        sequence: Optional[str] = None,
        **kwargs: Any
    ) -> _models.MachineAlarmCountDto:
        """count_machine_alarms.

        :keyword alarm_type: Known values are: "Fault" and "Warning". Default value is None.
        :paramtype alarm_type: str or ~ignos.api.client.models.MachineAlarmType
        :keyword asset_id: Default value is None.
        :paramtype asset_id: int
        :keyword start_time: Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: Default value is None.
        :paramtype end_time: ~datetime.datetime
        :keyword sub_type: Default value is None.
        :paramtype sub_type: str
        :keyword native_code: Default value is None.
        :paramtype native_code: str
        :keyword native_severity: Default value is None.
        :paramtype native_severity: int
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword sequence: Default value is None.
        :paramtype sequence: str
        :return: MachineAlarmCountDto
        :rtype: ~ignos.api.client.models.MachineAlarmCountDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MachineAlarmCountDto] = kwargs.pop("cls", None)

        _request = build_machine_alarms_count_machine_alarms_request(
            alarm_type=alarm_type,
            asset_id=asset_id,
            start_time=start_time,
            end_time=end_time,
            sub_type=sub_type,
            native_code=native_code,
            native_severity=native_severity,
            name=name,
            sequence=sequence,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MachineAlarmCountDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_machine_alarm_details(self, id: int, **kwargs: Any) -> _models.MachineAlarmDetailsDto:
        """get_machine_alarm_details.

        :param id: Required.
        :type id: int
        :return: MachineAlarmDetailsDto
        :rtype: ~ignos.api.client.models.MachineAlarmDetailsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MachineAlarmDetailsDto] = kwargs.pop("cls", None)

        _request = build_machine_alarms_get_machine_alarm_details_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MachineAlarmDetailsDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MachinesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`machines` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_machines(self, **kwargs: Any) -> List[_models.MachineDto]:
        """list_machines.

        :return: list of MachineDto
        :rtype: list[~ignos.api.client.models.MachineDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MachineDto]] = kwargs.pop("cls", None)

        _request = build_machines_list_machines_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MachineDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_machine_groups(self, **kwargs: Any) -> List[_models.MachineGroupDto]:
        """list_machine_groups.

        :return: list of MachineGroupDto
        :rtype: list[~ignos.api.client.models.MachineGroupDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MachineGroupDto]] = kwargs.pop("cls", None)

        _request = build_machines_list_machine_groups_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MachineGroupDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_machine_group(
        self,
        body: Optional[_models.CreateMachineGroup] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.CreateMachineGroupResponse:
        """create_machine_group.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateMachineGroup
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreateMachineGroupResponse
        :rtype: ~ignos.api.client.models.CreateMachineGroupResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_machine_group(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreateMachineGroupResponse:
        """create_machine_group.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: CreateMachineGroupResponse
        :rtype: ~ignos.api.client.models.CreateMachineGroupResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_machine_group(
        self, body: Optional[Union[_models.CreateMachineGroup, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.CreateMachineGroupResponse:
        """create_machine_group.

        :param body: Is either a CreateMachineGroup type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CreateMachineGroup or IO[bytes]
        :return: CreateMachineGroupResponse
        :rtype: ~ignos.api.client.models.CreateMachineGroupResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CreateMachineGroupResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateMachineGroup")
            else:
                _json = None

        _request = build_machines_create_machine_group_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CreateMachineGroupResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_machine_group(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[_models.UpdateMachineGroup] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """update_machine_group.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateMachineGroup
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_machine_group(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """update_machine_group.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_machine_group(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[Union[_models.UpdateMachineGroup, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """update_machine_group.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateMachineGroup type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UpdateMachineGroup or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateMachineGroup")
            else:
                _json = None

        _request = build_machines_update_machine_group_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_machine_group(  # pylint: disable=inconsistent-return-statements
        self, id: str, **kwargs: Any
    ) -> None:
        """delete_machine_group.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_machines_delete_machine_group_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_current_machine_states(
        self, *, asset_id: Optional[int] = None, **kwargs: Any
    ) -> _models.MachineStateListDto:
        """list_current_machine_states.

        :keyword asset_id: Default value is None.
        :paramtype asset_id: int
        :return: MachineStateListDto
        :rtype: ~ignos.api.client.models.MachineStateListDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MachineStateListDto] = kwargs.pop("cls", None)

        _request = build_machines_list_current_machine_states_request(
            asset_id=asset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MachineStateListDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_machine_states(
        self,
        id: int,
        *,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> List[_models.MachineStateDatapoint]:
        """list_machine_states.

        :param id: Required.
        :type id: int
        :keyword start_time: Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: Default value is None.
        :paramtype end_time: ~datetime.datetime
        :return: list of MachineStateDatapoint
        :rtype: list[~ignos.api.client.models.MachineStateDatapoint]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MachineStateDatapoint]] = kwargs.pop("cls", None)

        _request = build_machines_list_machine_states_request(
            id=id,
            start_time=start_time,
            end_time=end_time,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MachineStateDatapoint]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_machine_states_summary(
        self,
        id: int,
        *,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> _models.MachineStatesSummaryDto:
        """get_machine_states_summary.

        :param id: Required.
        :type id: int
        :keyword start_time: Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: Default value is None.
        :paramtype end_time: ~datetime.datetime
        :return: MachineStatesSummaryDto
        :rtype: ~ignos.api.client.models.MachineStatesSummaryDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MachineStatesSummaryDto] = kwargs.pop("cls", None)

        _request = build_machines_get_machine_states_summary_request(
            id=id,
            start_time=start_time,
            end_time=end_time,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MachineStatesSummaryDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_machine_erp_data(self, **kwargs: Any) -> _models.MachineErpDataListDto:
        """list_machine_erp_data.

        :return: MachineErpDataListDto
        :rtype: ~ignos.api.client.models.MachineErpDataListDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MachineErpDataListDto] = kwargs.pop("cls", None)

        _request = build_machines_list_machine_erp_data_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MachineErpDataListDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_machine_erp_data(self, id: int, **kwargs: Any) -> _models.MachineErpDataDto:
        """get_machine_erp_data.

        :param id: Required.
        :type id: int
        :return: MachineErpDataDto
        :rtype: ~ignos.api.client.models.MachineErpDataDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MachineErpDataDto] = kwargs.pop("cls", None)

        _request = build_machines_get_machine_erp_data_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MachineErpDataDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_machine_utilization_summary(self, **kwargs: Any) -> _models.UtilizationSummaryDto:
        """get_machine_utilization_summary.

        :return: UtilizationSummaryDto
        :rtype: ~ignos.api.client.models.UtilizationSummaryDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.UtilizationSummaryDto] = kwargs.pop("cls", None)

        _request = build_machines_get_machine_utilization_summary_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("UtilizationSummaryDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_current_machine_operators(
        self, *, machine_external_id: Optional[str] = None, operator_name_query: Optional[str] = None, **kwargs: Any
    ) -> List[_models.OperatorAndMachineDto]:
        """list_current_machine_operators.

        :keyword machine_external_id: Default value is None.
        :paramtype machine_external_id: str
        :keyword operator_name_query: Default value is None.
        :paramtype operator_name_query: str
        :return: list of OperatorAndMachineDto
        :rtype: list[~ignos.api.client.models.OperatorAndMachineDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.OperatorAndMachineDto]] = kwargs.pop("cls", None)

        _request = build_machines_list_current_machine_operators_request(
            machine_external_id=machine_external_id,
            operator_name_query=operator_name_query,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[OperatorAndMachineDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_machine_without_resource(  # pylint: disable=inconsistent-return-statements
        self,
        body: Optional[_models.CreateMachineWithoutResource] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """create_machine_without_resource.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateMachineWithoutResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_machine_without_resource(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """create_machine_without_resource.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_machine_without_resource(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.CreateMachineWithoutResource, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """create_machine_without_resource.

        :param body: Is either a CreateMachineWithoutResource type or a IO[bytes] type. Default value
         is None.
        :type body: ~ignos.api.client.models.CreateMachineWithoutResource or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateMachineWithoutResource")
            else:
                _json = None

        _request = build_machines_create_machine_without_resource_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def create_resource_without_machine(  # pylint: disable=inconsistent-return-statements
        self,
        body: Optional[_models.CreateResourceWithoutMachine] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """create_resource_without_machine.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateResourceWithoutMachine
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_resource_without_machine(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """create_resource_without_machine.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_resource_without_machine(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.CreateResourceWithoutMachine, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """create_resource_without_machine.

        :param body: Is either a CreateResourceWithoutMachine type or a IO[bytes] type. Default value
         is None.
        :type body: ~ignos.api.client.models.CreateResourceWithoutMachine or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateResourceWithoutMachine")
            else:
                _json = None

        _request = build_machines_create_resource_without_machine_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def create_resource_with_machine(  # pylint: disable=inconsistent-return-statements
        self,
        body: Optional[_models.CreateResourceWithMachine] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """create_resource_with_machine.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateResourceWithMachine
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_resource_with_machine(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """create_resource_with_machine.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_resource_with_machine(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.CreateResourceWithMachine, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """create_resource_with_machine.

        :param body: Is either a CreateResourceWithMachine type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.CreateResourceWithMachine or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateResourceWithMachine")
            else:
                _json = None

        _request = build_machines_create_resource_with_machine_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class MachineUtilizationOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`machine_utilization` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_machine_utilizations(
        self,
        *,
        asset_id: Optional[int] = None,
        favorites: bool = False,
        start_time_today: Optional[datetime.datetime] = None,
        utc_offset: Optional[float] = None,
        **kwargs: Any
    ) -> _models.UtilizationListDto:
        """Get machine utilization data. Historic utilizations start from now, whereas the start for
        current utilization is
        calculated based on startTimeToday or utcOffset. An UTC offset is
        obtained either from startTimeToday, utcOffset or the server's local
        time zone. The current utilization is calculated starting from the start of the current date
        offset from UTC
        by the offset used. Pass in utcOffset to avoid problems relating to clock drift between
        client and server.

        Get machine utilization data. Historic utilizations start from now, whereas the start for
        current utilization is
        calculated based on startTimeToday or utcOffset. An UTC offset is
        obtained either from startTimeToday, utcOffset or the server's local
        time zone. The current utilization is calculated starting from the start of the current date
        offset from UTC
        by the offset used. Pass in utcOffset to avoid problems relating to clock drift between
        client and server.

        :keyword asset_id: Default value is None.
        :paramtype asset_id: int
        :keyword favorites: Default value is False.
        :paramtype favorites: bool
        :keyword start_time_today: UTC offset for start of today's utilization is extracted from this
         value. Default value is None.
        :paramtype start_time_today: ~datetime.datetime
        :keyword utc_offset: Explicit UTC offset for start of today's utilization. Default value is
         None.
        :paramtype utc_offset: float
        :return: UtilizationListDto
        :rtype: ~ignos.api.client.models.UtilizationListDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.UtilizationListDto] = kwargs.pop("cls", None)

        _request = build_machine_utilization_get_machine_utilizations_request(
            asset_id=asset_id,
            favorites=favorites,
            start_time_today=start_time_today,
            utc_offset=utc_offset,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("UtilizationListDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_machine_utilization(
        self,
        id: int,
        *,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> _models.UtilizationDetailsDto:
        """get_machine_utilization.

        :param id: Required.
        :type id: int
        :keyword start_time: Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: Default value is None.
        :paramtype end_time: ~datetime.datetime
        :return: UtilizationDetailsDto
        :rtype: ~ignos.api.client.models.UtilizationDetailsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.UtilizationDetailsDto] = kwargs.pop("cls", None)

        _request = build_machine_utilization_get_machine_utilization_request(
            id=id,
            start_time=start_time,
            end_time=end_time,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("UtilizationDetailsDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_utilization_details_for_machine(
        self,
        id: int,
        *,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> _models.MachineStatesSummaryDto:
        """get_utilization_details_for_machine.

        :param id: Required.
        :type id: int
        :keyword start_time: Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: Default value is None.
        :paramtype end_time: ~datetime.datetime
        :return: MachineStatesSummaryDto
        :rtype: ~ignos.api.client.models.MachineStatesSummaryDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MachineStatesSummaryDto] = kwargs.pop("cls", None)

        _request = build_machine_utilization_get_utilization_details_for_machine_request(
            id=id,
            start_time=start_time,
            end_time=end_time,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MachineStatesSummaryDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_machine_states(
        self,
        id: int,
        *,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> List[_models.MachineStateDatapoint]:
        """list_machine_states.

        :param id: Required.
        :type id: int
        :keyword start_time: Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: Default value is None.
        :paramtype end_time: ~datetime.datetime
        :return: list of MachineStateDatapoint
        :rtype: list[~ignos.api.client.models.MachineStateDatapoint]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MachineStateDatapoint]] = kwargs.pop("cls", None)

        _request = build_machine_utilization_list_machine_states_request(
            id=id,
            start_time=start_time,
            end_time=end_time,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MachineStateDatapoint]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_machine_states_summary(
        self,
        id: int,
        *,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> _models.MachineStatesSummaryDto:
        """get_machine_states_summary.

        :param id: Required.
        :type id: int
        :keyword start_time: Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: Default value is None.
        :paramtype end_time: ~datetime.datetime
        :return: MachineStatesSummaryDto
        :rtype: ~ignos.api.client.models.MachineStatesSummaryDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MachineStatesSummaryDto] = kwargs.pop("cls", None)

        _request = build_machine_utilization_get_machine_states_summary_request(
            id=id,
            start_time=start_time,
            end_time=end_time,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MachineStatesSummaryDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def list_machine_uptimes_today(
        self,
        body: Optional[_models.ListMachineUptimesTodayRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MachineUptimesAggregateDto:
        """list_machine_uptimes_today.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListMachineUptimesTodayRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MachineUptimesAggregateDto
        :rtype: ~ignos.api.client.models.MachineUptimesAggregateDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def list_machine_uptimes_today(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MachineUptimesAggregateDto:
        """list_machine_uptimes_today.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MachineUptimesAggregateDto
        :rtype: ~ignos.api.client.models.MachineUptimesAggregateDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def list_machine_uptimes_today(
        self, body: Optional[Union[_models.ListMachineUptimesTodayRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MachineUptimesAggregateDto:
        """list_machine_uptimes_today.

        :param body: Is either a ListMachineUptimesTodayRequest type or a IO[bytes] type. Default value
         is None.
        :type body: ~ignos.api.client.models.ListMachineUptimesTodayRequest or IO[bytes]
        :return: MachineUptimesAggregateDto
        :rtype: ~ignos.api.client.models.MachineUptimesAggregateDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MachineUptimesAggregateDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListMachineUptimesTodayRequest")
            else:
                _json = None

        _request = build_machine_utilization_list_machine_uptimes_today_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MachineUptimesAggregateDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_power_on_utilization_datapoints(
        self,
        *,
        id: Optional[int] = None,
        external_id: Optional[str] = None,
        n_days: Optional[int] = None,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> _models.PowerOnUtilizationList:
        """list_power_on_utilization_datapoints.

        :keyword id: Default value is None.
        :paramtype id: int
        :keyword external_id: Default value is None.
        :paramtype external_id: str
        :keyword n_days: Default value is None.
        :paramtype n_days: int
        :keyword start_time: Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: Default value is None.
        :paramtype end_time: ~datetime.datetime
        :return: PowerOnUtilizationList
        :rtype: ~ignos.api.client.models.PowerOnUtilizationList
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PowerOnUtilizationList] = kwargs.pop("cls", None)

        _request = build_machine_utilization_list_power_on_utilization_datapoints_request(
            id=id,
            external_id=external_id,
            n_days=n_days,
            start_time=start_time,
            end_time=end_time,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("PowerOnUtilizationList", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_factory_utilization(self, **kwargs: Any) -> _models.PowerOnUtilizationDto:
        """get_factory_utilization.

        :return: PowerOnUtilizationDto
        :rtype: ~ignos.api.client.models.PowerOnUtilizationDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PowerOnUtilizationDto] = kwargs.pop("cls", None)

        _request = build_machine_utilization_get_factory_utilization_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("PowerOnUtilizationDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MeOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`me` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_my_apps(self, **kwargs: Any) -> List[_models.UserAppDto]:
        """get_my_apps.

        :return: list of UserAppDto
        :rtype: list[~ignos.api.client.models.UserAppDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.UserAppDto]] = kwargs.pop("cls", None)

        _request = build_me_get_my_apps_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[UserAppDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_current_user(self, **kwargs: Any) -> _models.UserDetailsDto:
        """get_current_user.

        :return: UserDetailsDto
        :rtype: ~ignos.api.client.models.UserDetailsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.UserDetailsDto] = kwargs.pop("cls", None)

        _request = build_me_get_current_user_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("UserDetailsDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def set_is_beta_tester(
        self,
        body: Optional[_models.SetIsBetaTesterRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.UserDto:
        """set_is_beta_tester.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.SetIsBetaTesterRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: UserDto
        :rtype: ~ignos.api.client.models.UserDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def set_is_beta_tester(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.UserDto:
        """set_is_beta_tester.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: UserDto
        :rtype: ~ignos.api.client.models.UserDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def set_is_beta_tester(
        self, body: Optional[Union[_models.SetIsBetaTesterRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.UserDto:
        """set_is_beta_tester.

        :param body: Is either a SetIsBetaTesterRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.SetIsBetaTesterRequest or IO[bytes]
        :return: UserDto
        :rtype: ~ignos.api.client.models.UserDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.UserDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "SetIsBetaTesterRequest")
            else:
                _json = None

        _request = build_me_set_is_beta_tester_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("UserDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def update_current_user_last_seen(  # pylint: disable=inconsistent-return-statements
        self, **kwargs: Any
    ) -> None:
        """update_current_user_last_seen.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_me_update_current_user_last_seen_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class MeasurementFormSchemasOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`measurement_form_schemas` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_measurment_form_schemas(
        self,
        *,
        page_size: int = 50,
        customer_id: Optional[str] = None,
        customer_name: Optional[str] = None,
        part_number: Optional[str] = None,
        part_revision: Optional[str] = None,
        drawing: Optional[str] = None,
        drawing_revision: Optional[str] = None,
        filter: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any
    ) -> _models.MeasurementFormListDtoPagedResult:
        """list_measurment_form_schemas.

        :keyword page_size: Default value is 50.
        :paramtype page_size: int
        :keyword customer_id: Default value is None.
        :paramtype customer_id: str
        :keyword customer_name: Default value is None.
        :paramtype customer_name: str
        :keyword part_number: Default value is None.
        :paramtype part_number: str
        :keyword part_revision: Default value is None.
        :paramtype part_revision: str
        :keyword drawing: Default value is None.
        :paramtype drawing: str
        :keyword drawing_revision: Default value is None.
        :paramtype drawing_revision: str
        :keyword filter: Default value is None.
        :paramtype filter: str
        :keyword continuation_token_parameter: Default value is None.
        :paramtype continuation_token_parameter: str
        :return: MeasurementFormListDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormListDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_list_measurment_form_schemas_request(
            page_size=page_size,
            customer_id=customer_id,
            customer_name=customer_name,
            part_number=part_number,
            part_revision=part_revision,
            drawing=drawing,
            drawing_revision=drawing_revision,
            filter=filter,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormListDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_measurement_form(
        self,
        body: Optional[_models.CreateMeasurementFormSchema] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormDto:
        """create_measurement_form.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateMeasurementFormSchema
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormDto
        :rtype: ~ignos.api.client.models.MeasurementFormDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_measurement_form(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormDto:
        """create_measurement_form.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormDto
        :rtype: ~ignos.api.client.models.MeasurementFormDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_measurement_form(
        self, body: Optional[Union[_models.CreateMeasurementFormSchema, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasurementFormDto:
        """create_measurement_form.

        :param body: Is either a CreateMeasurementFormSchema type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.CreateMeasurementFormSchema or IO[bytes]
        :return: MeasurementFormDto
        :rtype: ~ignos.api.client.models.MeasurementFormDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateMeasurementFormSchema")
            else:
                _json = None

        _request = build_measurement_form_schemas_create_measurement_form_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_list_measurement_form_schemas(
        self,
        body: Optional[_models.ListMeasurementFormSchemasRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormListDtoPagedResult:
        """post_list_measurement_form_schemas.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListMeasurementFormSchemasRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormListDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_measurement_form_schemas(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormListDtoPagedResult:
        """post_list_measurement_form_schemas.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormListDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_measurement_form_schemas(
        self, body: Optional[Union[_models.ListMeasurementFormSchemasRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasurementFormListDtoPagedResult:
        """post_list_measurement_form_schemas.

        :param body: Is either a ListMeasurementFormSchemasRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.ListMeasurementFormSchemasRequest or IO[bytes]
        :return: MeasurementFormListDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormListDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListMeasurementFormSchemasRequest")
            else:
                _json = None

        _request = build_measurement_form_schemas_post_list_measurement_form_schemas_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormListDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_measurement_form_schema(self, id: str, **kwargs: Any) -> _models.MeasurementFormSchemaDto:
        """get_measurement_form_schema.

        :param id: Required.
        :type id: str
        :return: MeasurementFormSchemaDto
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormSchemaDto] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_get_measurement_form_schema_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormSchemaDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_measurement_form_schema(
        self,
        id: str,
        body: Optional[_models.UpdateMeasurementFormSchemaRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormSchemaDto:
        """update_measurement_form_schema.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateMeasurementFormSchemaRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormSchemaDto
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_measurement_form_schema(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormSchemaDto:
        """update_measurement_form_schema.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormSchemaDto
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_measurement_form_schema(
        self,
        id: str,
        body: Optional[Union[_models.UpdateMeasurementFormSchemaRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.MeasurementFormSchemaDto:
        """update_measurement_form_schema.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateMeasurementFormSchemaRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.UpdateMeasurementFormSchemaRequest or IO[bytes]
        :return: MeasurementFormSchemaDto
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormSchemaDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateMeasurementFormSchemaRequest")
            else:
                _json = None

        _request = build_measurement_form_schemas_update_measurement_form_schema_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormSchemaDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_schema_grouped_elements(
        self,
        id: str,
        body: Optional[_models.UpdateSchemaGroupedElementsRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormSchemaDto:
        """update_schema_grouped_elements.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateSchemaGroupedElementsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormSchemaDto
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_schema_grouped_elements(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormSchemaDto:
        """update_schema_grouped_elements.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormSchemaDto
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_schema_grouped_elements(
        self,
        id: str,
        body: Optional[Union[_models.UpdateSchemaGroupedElementsRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.MeasurementFormSchemaDto:
        """update_schema_grouped_elements.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateSchemaGroupedElementsRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.UpdateSchemaGroupedElementsRequest or IO[bytes]
        :return: MeasurementFormSchemaDto
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormSchemaDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateSchemaGroupedElementsRequest")
            else:
                _json = None

        _request = build_measurement_form_schemas_update_schema_grouped_elements_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormSchemaDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def upload_schema_drawing(
        self,
        id: str,
        body: Optional[_models.UploadDrawingRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormSchemaDto:
        """upload_schema_drawing.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UploadDrawingRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormSchemaDto
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def upload_schema_drawing(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormSchemaDto:
        """upload_schema_drawing.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormSchemaDto
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def upload_schema_drawing(
        self, id: str, body: Optional[Union[_models.UploadDrawingRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasurementFormSchemaDto:
        """upload_schema_drawing.

        :param id: Required.
        :type id: str
        :param body: Is either a UploadDrawingRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UploadDrawingRequest or IO[bytes]
        :return: MeasurementFormSchemaDto
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormSchemaDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UploadDrawingRequest")
            else:
                _json = None

        _request = build_measurement_form_schemas_upload_schema_drawing_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormSchemaDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def upload_schema_attachment(
        self,
        id: str,
        body: Optional[_models.UploadRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormSchemaDto:
        """upload_schema_attachment.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UploadRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormSchemaDto
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def upload_schema_attachment(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormSchemaDto:
        """upload_schema_attachment.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormSchemaDto
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def upload_schema_attachment(
        self, id: str, body: Optional[Union[_models.UploadRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasurementFormSchemaDto:
        """upload_schema_attachment.

        :param id: Required.
        :type id: str
        :param body: Is either a UploadRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UploadRequest or IO[bytes]
        :return: MeasurementFormSchemaDto
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormSchemaDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UploadRequest")
            else:
                _json = None

        _request = build_measurement_form_schemas_upload_schema_attachment_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormSchemaDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_measurement_form_import_status(
        self, id: str, **kwargs: Any
    ) -> _models.MeasurementFormImportStatusDto:
        """get_measurement_form_import_status.

        :param id: Required.
        :type id: str
        :return: MeasurementFormImportStatusDto
        :rtype: ~ignos.api.client.models.MeasurementFormImportStatusDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormImportStatusDto] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_get_measurement_form_import_status_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormImportStatusDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_schema_element(
        self,
        schema_id: str,
        body: Optional[_models.CreateSchemaElement] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormElementDto:
        """create_schema_element.

        :param schema_id: Required.
        :type schema_id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateSchemaElement
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormElementDto
        :rtype: ~ignos.api.client.models.MeasurementFormElementDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_schema_element(
        self, schema_id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormElementDto:
        """create_schema_element.

        :param schema_id: Required.
        :type schema_id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormElementDto
        :rtype: ~ignos.api.client.models.MeasurementFormElementDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_schema_element(
        self, schema_id: str, body: Optional[Union[_models.CreateSchemaElement, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasurementFormElementDto:
        """create_schema_element.

        :param schema_id: Required.
        :type schema_id: str
        :param body: Is either a CreateSchemaElement type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CreateSchemaElement or IO[bytes]
        :return: MeasurementFormElementDto
        :rtype: ~ignos.api.client.models.MeasurementFormElementDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormElementDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateSchemaElement")
            else:
                _json = None

        _request = build_measurement_form_schemas_create_schema_element_request(
            schema_id=schema_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormElementDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_linkable_measurement_form_schemas(
        self,
        schema_id: str,
        *,
        page_size: int = 50,
        filter: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any
    ) -> _models.MeasurementFormListDtoPagedResult:
        """list_linkable_measurement_form_schemas.

        :param schema_id: Required.
        :type schema_id: str
        :keyword page_size: Default value is 50.
        :paramtype page_size: int
        :keyword filter: Default value is None.
        :paramtype filter: str
        :keyword continuation_token_parameter: Default value is None.
        :paramtype continuation_token_parameter: str
        :return: MeasurementFormListDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormListDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_list_linkable_measurement_form_schemas_request(
            schema_id=schema_id,
            page_size=page_size,
            filter=filter,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormListDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_list_linkable_measurement_form_schemas(  # pylint: disable=name-too-long
        self,
        body: Optional[_models.ListLinkableMeasurementFormSchemasRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormListDtoPagedResult:
        """post_list_linkable_measurement_form_schemas.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListLinkableMeasurementFormSchemasRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormListDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_linkable_measurement_form_schemas(  # pylint: disable=name-too-long
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormListDtoPagedResult:
        """post_list_linkable_measurement_form_schemas.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormListDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_linkable_measurement_form_schemas(  # pylint: disable=name-too-long
        self, body: Optional[Union[_models.ListLinkableMeasurementFormSchemasRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasurementFormListDtoPagedResult:
        """post_list_linkable_measurement_form_schemas.

        :param body: Is either a ListLinkableMeasurementFormSchemasRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.ListLinkableMeasurementFormSchemasRequest or IO[bytes]
        :return: MeasurementFormListDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormListDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListLinkableMeasurementFormSchemasRequest")
            else:
                _json = None

        _request = build_measurement_form_schemas_post_list_linkable_measurement_form_schemas_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormListDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_measurement_form_schema_link(
        self,
        schema_id: str,
        body: Optional[_models.CreateMeasurementFormSchemaLinkRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormDto:
        """create_measurement_form_schema_link.

        :param schema_id: Required.
        :type schema_id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateMeasurementFormSchemaLinkRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormDto
        :rtype: ~ignos.api.client.models.MeasurementFormDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_measurement_form_schema_link(
        self, schema_id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormDto:
        """create_measurement_form_schema_link.

        :param schema_id: Required.
        :type schema_id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormDto
        :rtype: ~ignos.api.client.models.MeasurementFormDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_measurement_form_schema_link(
        self,
        schema_id: str,
        body: Optional[Union[_models.CreateMeasurementFormSchemaLinkRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.MeasurementFormDto:
        """create_measurement_form_schema_link.

        :param schema_id: Required.
        :type schema_id: str
        :param body: Is either a CreateMeasurementFormSchemaLinkRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.CreateMeasurementFormSchemaLinkRequest or IO[bytes]
        :return: MeasurementFormDto
        :rtype: ~ignos.api.client.models.MeasurementFormDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateMeasurementFormSchemaLinkRequest")
            else:
                _json = None

        _request = build_measurement_form_schemas_create_measurement_form_schema_link_request(
            schema_id=schema_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_measurement_form_schema_link(  # pylint: disable=inconsistent-return-statements
        self, schema_id: str, linked_schema_id: str, **kwargs: Any
    ) -> None:
        """delete_measurement_form_schema_link.

        :param schema_id: Required.
        :type schema_id: str
        :param linked_schema_id: Required.
        :type linked_schema_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_delete_measurement_form_schema_link_request(
            schema_id=schema_id,
            linked_schema_id=linked_schema_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def release_schema(self, schema_id: str, **kwargs: Any) -> _models.MeasurementFormDto:
        """release_schema.

        :param schema_id: Required.
        :type schema_id: str
        :return: MeasurementFormDto
        :rtype: ~ignos.api.client.models.MeasurementFormDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormDto] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_release_schema_request(
            schema_id=schema_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def revoke_schema(self, schema_id: str, **kwargs: Any) -> _models.MeasurementFormDto:
        """revoke_schema.

        :param schema_id: Required.
        :type schema_id: str
        :return: MeasurementFormDto
        :rtype: ~ignos.api.client.models.MeasurementFormDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormDto] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_revoke_schema_request(
            schema_id=schema_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def create_draft_version(self, schema_id: str, **kwargs: Any) -> _models.MeasurementFormDto:
        """create_draft_version.

        :param schema_id: Required.
        :type schema_id: str
        :return: MeasurementFormDto
        :rtype: ~ignos.api.client.models.MeasurementFormDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormDto] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_create_draft_version_request(
            schema_id=schema_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def is_mapping_from_previous_version_required(  # pylint: disable=name-too-long
        self, schema_id: str, **kwargs: Any
    ) -> bool:
        """is_mapping_from_previous_version_required.

        :param schema_id: Required.
        :type schema_id: str
        :return: bool
        :rtype: bool
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[bool] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_is_mapping_from_previous_version_required_request(
            schema_id=schema_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("bool", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_measurement_form_settings(self, **kwargs: Any) -> _models.MeasurementFormSettingsDto:
        """get_measurement_form_settings.

        :return: MeasurementFormSettingsDto
        :rtype: ~ignos.api.client.models.MeasurementFormSettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormSettingsDto] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_get_measurement_form_settings_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormSettingsDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_measurement_form_settings(
        self,
        body: Optional[_models.UpdateMeasurementFormSettings] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormSettingsDto:
        """update_measurement_form_settings.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateMeasurementFormSettings
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormSettingsDto
        :rtype: ~ignos.api.client.models.MeasurementFormSettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_measurement_form_settings(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormSettingsDto:
        """update_measurement_form_settings.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormSettingsDto
        :rtype: ~ignos.api.client.models.MeasurementFormSettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_measurement_form_settings(
        self, body: Optional[Union[_models.UpdateMeasurementFormSettings, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasurementFormSettingsDto:
        """update_measurement_form_settings.

        :param body: Is either a UpdateMeasurementFormSettings type or a IO[bytes] type. Default value
         is None.
        :type body: ~ignos.api.client.models.UpdateMeasurementFormSettings or IO[bytes]
        :return: MeasurementFormSettingsDto
        :rtype: ~ignos.api.client.models.MeasurementFormSettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormSettingsDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateMeasurementFormSettings")
            else:
                _json = None

        _request = build_measurement_form_schemas_update_measurement_form_settings_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormSettingsDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_measurement_form_customer_settings(
        self, id: str, **kwargs: Any
    ) -> _models.MeasurementFormCustomerSettingsDto:
        """get_measurement_form_customer_settings.

        :param id: Required.
        :type id: str
        :return: MeasurementFormCustomerSettingsDto
        :rtype: ~ignos.api.client.models.MeasurementFormCustomerSettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormCustomerSettingsDto] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_get_measurement_form_customer_settings_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormCustomerSettingsDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_measurement_form_customer_settings(  # pylint: disable=name-too-long
        self,
        body: Optional[_models.UpdateMeasurementFormCustomerSettings] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormCustomerSettingsDto:
        """update_measurement_form_customer_settings.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateMeasurementFormCustomerSettings
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormCustomerSettingsDto
        :rtype: ~ignos.api.client.models.MeasurementFormCustomerSettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_measurement_form_customer_settings(  # pylint: disable=name-too-long
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormCustomerSettingsDto:
        """update_measurement_form_customer_settings.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormCustomerSettingsDto
        :rtype: ~ignos.api.client.models.MeasurementFormCustomerSettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_measurement_form_customer_settings(  # pylint: disable=name-too-long
        self, body: Optional[Union[_models.UpdateMeasurementFormCustomerSettings, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasurementFormCustomerSettingsDto:
        """update_measurement_form_customer_settings.

        :param body: Is either a UpdateMeasurementFormCustomerSettings type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.UpdateMeasurementFormCustomerSettings or IO[bytes]
        :return: MeasurementFormCustomerSettingsDto
        :rtype: ~ignos.api.client.models.MeasurementFormCustomerSettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormCustomerSettingsDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateMeasurementFormCustomerSettings")
            else:
                _json = None

        _request = build_measurement_form_schemas_update_measurement_form_customer_settings_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormCustomerSettingsDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_measurement_form_mappings_from_schema(  # pylint: disable=name-too-long
        self, *, target_id: str, **kwargs: Any
    ) -> List[_models.MeasurementFormMappingDto]:
        """list_measurement_form_mappings_from_schema.

        :keyword target_id: Required.
        :paramtype target_id: str
        :return: list of MeasurementFormMappingDto
        :rtype: list[~ignos.api.client.models.MeasurementFormMappingDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MeasurementFormMappingDto]] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_list_measurement_form_mappings_from_schema_request(
            target_id=target_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MeasurementFormMappingDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_measurement_form_mapping(
        self,
        body: Optional[_models.CreateMeasurementFormMapping] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.MeasurementFormMappingDto, _models.ProblemDetails]:
        """create_measurement_form_mapping.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateMeasurementFormMapping
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormMappingDto or ProblemDetails
        :rtype: ~ignos.api.client.models.MeasurementFormMappingDto or
         ~ignos.api.client.models.ProblemDetails
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_measurement_form_mapping(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.MeasurementFormMappingDto, _models.ProblemDetails]:
        """create_measurement_form_mapping.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormMappingDto or ProblemDetails
        :rtype: ~ignos.api.client.models.MeasurementFormMappingDto or
         ~ignos.api.client.models.ProblemDetails
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_measurement_form_mapping(
        self, body: Optional[Union[_models.CreateMeasurementFormMapping, IO[bytes]]] = None, **kwargs: Any
    ) -> Union[_models.MeasurementFormMappingDto, _models.ProblemDetails]:
        """create_measurement_form_mapping.

        :param body: Is either a CreateMeasurementFormMapping type or a IO[bytes] type. Default value
         is None.
        :type body: ~ignos.api.client.models.CreateMeasurementFormMapping or IO[bytes]
        :return: MeasurementFormMappingDto or ProblemDetails
        :rtype: ~ignos.api.client.models.MeasurementFormMappingDto or
         ~ignos.api.client.models.ProblemDetails
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Union[_models.MeasurementFormMappingDto, _models.ProblemDetails]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateMeasurementFormMapping")
            else:
                _json = None

        _request = build_measurement_form_schemas_create_measurement_form_mapping_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 409]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            deserialized = self._deserialize("MeasurementFormMappingDto", pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize("ProblemDetails", pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize("ProblemDetails", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_measurement_form_mapping(self, id: str, **kwargs: Any) -> _models.MeasurementFormMappingDto:
        """get_measurement_form_mapping.

        :param id: Required.
        :type id: str
        :return: MeasurementFormMappingDto
        :rtype: ~ignos.api.client.models.MeasurementFormMappingDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormMappingDto] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_get_measurement_form_mapping_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormMappingDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_measurement_form_mapping(  # pylint: disable=inconsistent-return-statements
        self, id: str, **kwargs: Any
    ) -> None:
        """delete_measurement_form_mapping.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_delete_measurement_form_mapping_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def set_measurement_form_mapping_balloons(
        self,
        id: str,
        body: Optional[List[_models.MeasurementFormBalloonMappingRequestDto]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormMappingDto:
        """set_measurement_form_mapping_balloons.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: list[~ignos.api.client.models.MeasurementFormBalloonMappingRequestDto]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormMappingDto
        :rtype: ~ignos.api.client.models.MeasurementFormMappingDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def set_measurement_form_mapping_balloons(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormMappingDto:
        """set_measurement_form_mapping_balloons.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormMappingDto
        :rtype: ~ignos.api.client.models.MeasurementFormMappingDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def set_measurement_form_mapping_balloons(
        self,
        id: str,
        body: Optional[Union[List[_models.MeasurementFormBalloonMappingRequestDto], IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.MeasurementFormMappingDto:
        """set_measurement_form_mapping_balloons.

        :param id: Required.
        :type id: str
        :param body: Is either a [MeasurementFormBalloonMappingRequestDto] type or a IO[bytes] type.
         Default value is None.
        :type body: list[~ignos.api.client.models.MeasurementFormBalloonMappingRequestDto] or IO[bytes]
        :return: MeasurementFormMappingDto
        :rtype: ~ignos.api.client.models.MeasurementFormMappingDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormMappingDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "[MeasurementFormBalloonMappingRequestDto]")
            else:
                _json = None

        _request = build_measurement_form_schemas_set_measurement_form_mapping_balloons_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormMappingDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def set_measurement_form_mapping_balloons_v2(
        self,
        id: str,
        body: Optional[_models.SetMeasurementFormMappingBalloonsRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormMappingDto:
        """set_measurement_form_mapping_balloons_v2.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.SetMeasurementFormMappingBalloonsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormMappingDto
        :rtype: ~ignos.api.client.models.MeasurementFormMappingDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def set_measurement_form_mapping_balloons_v2(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormMappingDto:
        """set_measurement_form_mapping_balloons_v2.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormMappingDto
        :rtype: ~ignos.api.client.models.MeasurementFormMappingDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def set_measurement_form_mapping_balloons_v2(
        self,
        id: str,
        body: Optional[Union[_models.SetMeasurementFormMappingBalloonsRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.MeasurementFormMappingDto:
        """set_measurement_form_mapping_balloons_v2.

        :param id: Required.
        :type id: str
        :param body: Is either a SetMeasurementFormMappingBalloonsRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.SetMeasurementFormMappingBalloonsRequest or IO[bytes]
        :return: MeasurementFormMappingDto
        :rtype: ~ignos.api.client.models.MeasurementFormMappingDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormMappingDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "SetMeasurementFormMappingBalloonsRequest")
            else:
                _json = None

        _request = build_measurement_form_schemas_set_measurement_form_mapping_balloons_v2_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormMappingDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_measurement_form_mapping_suggestion(
        self, *, target_id: str, source_id: Optional[str] = None, **kwargs: Any
    ) -> _models.MeasurementFormMappingSuggestionDto:
        """get_measurement_form_mapping_suggestion.

        :keyword target_id: Required.
        :paramtype target_id: str
        :keyword source_id: Default value is None.
        :paramtype source_id: str
        :return: MeasurementFormMappingSuggestionDto
        :rtype: ~ignos.api.client.models.MeasurementFormMappingSuggestionDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormMappingSuggestionDto] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_get_measurement_form_mapping_suggestion_request(
            target_id=target_id,
            source_id=source_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormMappingSuggestionDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def import_measurement_form_schema(
        self,
        body: Optional[_models.ImportMeasurementFormSchema] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormDto:
        """Custom api for initial import. Not to be used more than once per customer.

        Custom api for initial import. Not to be used more than once per customer.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ImportMeasurementFormSchema
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormDto
        :rtype: ~ignos.api.client.models.MeasurementFormDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def import_measurement_form_schema(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormDto:
        """Custom api for initial import. Not to be used more than once per customer.

        Custom api for initial import. Not to be used more than once per customer.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormDto
        :rtype: ~ignos.api.client.models.MeasurementFormDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def import_measurement_form_schema(
        self, body: Optional[Union[_models.ImportMeasurementFormSchema, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasurementFormDto:
        """Custom api for initial import. Not to be used more than once per customer.

        Custom api for initial import. Not to be used more than once per customer.

        :param body: Is either a ImportMeasurementFormSchema type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.ImportMeasurementFormSchema or IO[bytes]
        :return: MeasurementFormDto
        :rtype: ~ignos.api.client.models.MeasurementFormDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ImportMeasurementFormSchema")
            else:
                _json = None

        _request = build_measurement_form_schemas_import_measurement_form_schema_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_measurement_form_needs(
        self,
        *,
        page_size: int = 50,
        customer_id: Optional[str] = None,
        customer_name: Optional[str] = None,
        part_number: Optional[str] = None,
        part_revision: Optional[str] = None,
        drawing: Optional[str] = None,
        drawing_revision: Optional[str] = None,
        filter: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        only_without_drawing_url: Optional[bool] = None,
        **kwargs: Any
    ) -> _models.MeasurementFormNeedDtoPagedResult:
        """list_measurement_form_needs.

        :keyword page_size: Default value is 50.
        :paramtype page_size: int
        :keyword customer_id: Default value is None.
        :paramtype customer_id: str
        :keyword customer_name: Default value is None.
        :paramtype customer_name: str
        :keyword part_number: Default value is None.
        :paramtype part_number: str
        :keyword part_revision: Default value is None.
        :paramtype part_revision: str
        :keyword drawing: Default value is None.
        :paramtype drawing: str
        :keyword drawing_revision: Default value is None.
        :paramtype drawing_revision: str
        :keyword filter: Default value is None.
        :paramtype filter: str
        :keyword continuation_token_parameter: Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword only_without_drawing_url: Default value is None.
        :paramtype only_without_drawing_url: bool
        :return: MeasurementFormNeedDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormNeedDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormNeedDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_list_measurement_form_needs_request(
            page_size=page_size,
            customer_id=customer_id,
            customer_name=customer_name,
            part_number=part_number,
            part_revision=part_revision,
            drawing=drawing,
            drawing_revision=drawing_revision,
            filter=filter,
            continuation_token_parameter=continuation_token_parameter,
            only_without_drawing_url=only_without_drawing_url,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormNeedDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_list_measurement_form_needs(
        self,
        body: Optional[_models.ListMeasurementFormNeedsRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormNeedDtoPagedResult:
        """post_list_measurement_form_needs.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListMeasurementFormNeedsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormNeedDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormNeedDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_measurement_form_needs(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormNeedDtoPagedResult:
        """post_list_measurement_form_needs.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormNeedDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormNeedDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_measurement_form_needs(
        self, body: Optional[Union[_models.ListMeasurementFormNeedsRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasurementFormNeedDtoPagedResult:
        """post_list_measurement_form_needs.

        :param body: Is either a ListMeasurementFormNeedsRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.ListMeasurementFormNeedsRequest or IO[bytes]
        :return: MeasurementFormNeedDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormNeedDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormNeedDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListMeasurementFormNeedsRequest")
            else:
                _json = None

        _request = build_measurement_form_schemas_post_list_measurement_form_needs_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormNeedDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def set_measurement_form_need_user(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[_models.SetMeasurementFormNeedUserRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """set_measurement_form_need_user.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.SetMeasurementFormNeedUserRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def set_measurement_form_need_user(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """set_measurement_form_need_user.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def set_measurement_form_need_user(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[Union[_models.SetMeasurementFormNeedUserRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """set_measurement_form_need_user.

        :param id: Required.
        :type id: str
        :param body: Is either a SetMeasurementFormNeedUserRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.SetMeasurementFormNeedUserRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "SetMeasurementFormNeedUserRequest")
            else:
                _json = None

        _request = build_measurement_form_schemas_set_measurement_form_need_user_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def set_measurement_form_need_as_not_needed(
        self,
        id: str,
        body: Optional[_models.SetMeasurementFormNeedAsNotNeededRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormSchemaNotNeededDto:
        """set_measurement_form_need_as_not_needed.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.SetMeasurementFormNeedAsNotNeededRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormSchemaNotNeededDto
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaNotNeededDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def set_measurement_form_need_as_not_needed(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormSchemaNotNeededDto:
        """set_measurement_form_need_as_not_needed.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormSchemaNotNeededDto
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaNotNeededDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def set_measurement_form_need_as_not_needed(
        self,
        id: str,
        body: Optional[Union[_models.SetMeasurementFormNeedAsNotNeededRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.MeasurementFormSchemaNotNeededDto:
        """set_measurement_form_need_as_not_needed.

        :param id: Required.
        :type id: str
        :param body: Is either a SetMeasurementFormNeedAsNotNeededRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.SetMeasurementFormNeedAsNotNeededRequest or IO[bytes]
        :return: MeasurementFormSchemaNotNeededDto
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaNotNeededDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormSchemaNotNeededDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "SetMeasurementFormNeedAsNotNeededRequest")
            else:
                _json = None

        _request = build_measurement_form_schemas_set_measurement_form_need_as_not_needed_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormSchemaNotNeededDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def create_measurement_form_schema_from_need(self, id: str, **kwargs: Any) -> _models.MeasurementFormDto:
        """create_measurement_form_schema_from_need.

        :param id: Required.
        :type id: str
        :return: MeasurementFormDto
        :rtype: ~ignos.api.client.models.MeasurementFormDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormDto] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_create_measurement_form_schema_from_need_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def upload_need_drawing(
        self,
        id: str,
        body: Optional[_models.UploadDrawingRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormNeedDto:
        """upload_need_drawing.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UploadDrawingRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormNeedDto
        :rtype: ~ignos.api.client.models.MeasurementFormNeedDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def upload_need_drawing(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormNeedDto:
        """upload_need_drawing.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormNeedDto
        :rtype: ~ignos.api.client.models.MeasurementFormNeedDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def upload_need_drawing(
        self, id: str, body: Optional[Union[_models.UploadDrawingRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasurementFormNeedDto:
        """upload_need_drawing.

        :param id: Required.
        :type id: str
        :param body: Is either a UploadDrawingRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UploadDrawingRequest or IO[bytes]
        :return: MeasurementFormNeedDto
        :rtype: ~ignos.api.client.models.MeasurementFormNeedDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormNeedDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UploadDrawingRequest")
            else:
                _json = None

        _request = build_measurement_form_schemas_upload_need_drawing_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormNeedDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_measurment_form_schemas_not_needed(
        self,
        *,
        page_size: int = 50,
        customer_id: Optional[str] = None,
        customer_name: Optional[str] = None,
        part_number: Optional[str] = None,
        part_revision: Optional[str] = None,
        drawing: Optional[str] = None,
        drawing_revision: Optional[str] = None,
        filter: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any
    ) -> _models.MeasurementFormSchemaNotNeededDtoPagedResult:
        """list_measurment_form_schemas_not_needed.

        :keyword page_size: Default value is 50.
        :paramtype page_size: int
        :keyword customer_id: Default value is None.
        :paramtype customer_id: str
        :keyword customer_name: Default value is None.
        :paramtype customer_name: str
        :keyword part_number: Default value is None.
        :paramtype part_number: str
        :keyword part_revision: Default value is None.
        :paramtype part_revision: str
        :keyword drawing: Default value is None.
        :paramtype drawing: str
        :keyword drawing_revision: Default value is None.
        :paramtype drawing_revision: str
        :keyword filter: Default value is None.
        :paramtype filter: str
        :keyword continuation_token_parameter: Default value is None.
        :paramtype continuation_token_parameter: str
        :return: MeasurementFormSchemaNotNeededDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaNotNeededDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormSchemaNotNeededDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_list_measurment_form_schemas_not_needed_request(
            page_size=page_size,
            customer_id=customer_id,
            customer_name=customer_name,
            part_number=part_number,
            part_revision=part_revision,
            drawing=drawing,
            drawing_revision=drawing_revision,
            filter=filter,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormSchemaNotNeededDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_list_measurement_form_schemas_not_needed(  # pylint: disable=name-too-long
        self,
        body: Optional[_models.ListMeasurementFormSchemasNotNeededRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormSchemaNotNeededDtoPagedResult:
        """post_list_measurement_form_schemas_not_needed.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListMeasurementFormSchemasNotNeededRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormSchemaNotNeededDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaNotNeededDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_measurement_form_schemas_not_needed(  # pylint: disable=name-too-long
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormSchemaNotNeededDtoPagedResult:
        """post_list_measurement_form_schemas_not_needed.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormSchemaNotNeededDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaNotNeededDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_measurement_form_schemas_not_needed(  # pylint: disable=name-too-long
        self, body: Optional[Union[_models.ListMeasurementFormSchemasNotNeededRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasurementFormSchemaNotNeededDtoPagedResult:
        """post_list_measurement_form_schemas_not_needed.

        :param body: Is either a ListMeasurementFormSchemasNotNeededRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.ListMeasurementFormSchemasNotNeededRequest or IO[bytes]
        :return: MeasurementFormSchemaNotNeededDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormSchemaNotNeededDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormSchemaNotNeededDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListMeasurementFormSchemasNotNeededRequest")
            else:
                _json = None

        _request = build_measurement_form_schemas_post_list_measurement_form_schemas_not_needed_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormSchemaNotNeededDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_measurment_form_schemas_not_needed(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, id: str, **kwargs: Any
    ) -> None:
        """delete_measurment_form_schemas_not_needed.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_delete_measurment_form_schemas_not_needed_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_resource_types_for_needs_generator(
        self, **kwargs: Any
    ) -> List[_models.MeasurementFormResourceTypeGeneratorDto]:
        """list_resource_types_for_needs_generator.

        :return: list of MeasurementFormResourceTypeGeneratorDto
        :rtype: list[~ignos.api.client.models.MeasurementFormResourceTypeGeneratorDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MeasurementFormResourceTypeGeneratorDto]] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_list_resource_types_for_needs_generator_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MeasurementFormResourceTypeGeneratorDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def add_resource_type_for_needs_generator(
        self,
        body: Optional[_models.AddResourceTypeForNeedsGenerator] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormResourceTypeGeneratorDto:
        """add_resource_type_for_needs_generator.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.AddResourceTypeForNeedsGenerator
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormResourceTypeGeneratorDto
        :rtype: ~ignos.api.client.models.MeasurementFormResourceTypeGeneratorDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_resource_type_for_needs_generator(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormResourceTypeGeneratorDto:
        """add_resource_type_for_needs_generator.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormResourceTypeGeneratorDto
        :rtype: ~ignos.api.client.models.MeasurementFormResourceTypeGeneratorDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_resource_type_for_needs_generator(
        self, body: Optional[Union[_models.AddResourceTypeForNeedsGenerator, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasurementFormResourceTypeGeneratorDto:
        """add_resource_type_for_needs_generator.

        :param body: Is either a AddResourceTypeForNeedsGenerator type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.AddResourceTypeForNeedsGenerator or IO[bytes]
        :return: MeasurementFormResourceTypeGeneratorDto
        :rtype: ~ignos.api.client.models.MeasurementFormResourceTypeGeneratorDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormResourceTypeGeneratorDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "AddResourceTypeForNeedsGenerator")
            else:
                _json = None

        _request = build_measurement_form_schemas_add_resource_type_for_needs_generator_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormResourceTypeGeneratorDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_resource_type_for_needs_generator(  # pylint: disable=inconsistent-return-statements
        self, resource_type: str, **kwargs: Any
    ) -> None:
        """delete_resource_type_for_needs_generator.

        :param resource_type: Required.
        :type resource_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_delete_resource_type_for_needs_generator_request(
            resource_type=resource_type,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_frequencies(self, **kwargs: Any) -> List[_models.MeasurementFrequencyDto]:
        """list_frequencies.

        :return: list of MeasurementFrequencyDto
        :rtype: list[~ignos.api.client.models.MeasurementFrequencyDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MeasurementFrequencyDto]] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_list_frequencies_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MeasurementFrequencyDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_measurement_form_instance_schema_feedback(  # pylint: disable=name-too-long
        self,
        *,
        page_size: int = 50,
        search: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any
    ) -> _models.SchemaFeedbackDtoPagedResult:
        """list_measurement_form_instance_schema_feedback.

        :keyword page_size: Default value is 50.
        :paramtype page_size: int
        :keyword search: Default value is None.
        :paramtype search: str
        :keyword continuation_token_parameter: Default value is None.
        :paramtype continuation_token_parameter: str
        :return: SchemaFeedbackDtoPagedResult
        :rtype: ~ignos.api.client.models.SchemaFeedbackDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SchemaFeedbackDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_list_measurement_form_instance_schema_feedback_request(
            page_size=page_size,
            search=search,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("SchemaFeedbackDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_list_measurement_form_instance_schema_feedback(  # pylint: disable=name-too-long
        self,
        body: Optional[_models.ListMeasurementFormInstanceSchemaFeedbackRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SchemaFeedbackDtoPagedResult:
        """post_list_measurement_form_instance_schema_feedback.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListMeasurementFormInstanceSchemaFeedbackRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SchemaFeedbackDtoPagedResult
        :rtype: ~ignos.api.client.models.SchemaFeedbackDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_measurement_form_instance_schema_feedback(  # pylint: disable=name-too-long
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SchemaFeedbackDtoPagedResult:
        """post_list_measurement_form_instance_schema_feedback.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: SchemaFeedbackDtoPagedResult
        :rtype: ~ignos.api.client.models.SchemaFeedbackDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_measurement_form_instance_schema_feedback(  # pylint: disable=name-too-long
        self,
        body: Optional[Union[_models.ListMeasurementFormInstanceSchemaFeedbackRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.SchemaFeedbackDtoPagedResult:
        """post_list_measurement_form_instance_schema_feedback.

        :param body: Is either a ListMeasurementFormInstanceSchemaFeedbackRequest type or a IO[bytes]
         type. Default value is None.
        :type body: ~ignos.api.client.models.ListMeasurementFormInstanceSchemaFeedbackRequest or
         IO[bytes]
        :return: SchemaFeedbackDtoPagedResult
        :rtype: ~ignos.api.client.models.SchemaFeedbackDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SchemaFeedbackDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListMeasurementFormInstanceSchemaFeedbackRequest")
            else:
                _json = None

        _request = build_measurement_form_schemas_post_list_measurement_form_instance_schema_feedback_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("SchemaFeedbackDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_measurement_form_instance_schema_feedback(  # pylint: disable=name-too-long
        self, id: str, **kwargs: Any
    ) -> _models.SchemaFeedbackDto:
        """get_measurement_form_instance_schema_feedback.

        :param id: Required.
        :type id: str
        :return: SchemaFeedbackDto
        :rtype: ~ignos.api.client.models.SchemaFeedbackDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SchemaFeedbackDto] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_get_measurement_form_instance_schema_feedback_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("SchemaFeedbackDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_measurement_form_instance_schema_feedback(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, id: str, **kwargs: Any
    ) -> None:
        """delete_measurement_form_instance_schema_feedback.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_delete_measurement_form_instance_schema_feedback_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def set_measurement_form_instance_schema_feedback_user(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        id: str,
        body: Optional[_models.SetMeasurementFormSchemaFeedbackUserRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """set_measurement_form_instance_schema_feedback_user.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.SetMeasurementFormSchemaFeedbackUserRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def set_measurement_form_instance_schema_feedback_user(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """set_measurement_form_instance_schema_feedback_user.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def set_measurement_form_instance_schema_feedback_user(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        id: str,
        body: Optional[Union[_models.SetMeasurementFormSchemaFeedbackUserRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """set_measurement_form_instance_schema_feedback_user.

        :param id: Required.
        :type id: str
        :param body: Is either a SetMeasurementFormSchemaFeedbackUserRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.SetMeasurementFormSchemaFeedbackUserRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "SetMeasurementFormSchemaFeedbackUserRequest")
            else:
                _json = None

        _request = build_measurement_form_schemas_set_measurement_form_instance_schema_feedback_user_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_measurment_form_schemas_with_history(  # pylint: disable=name-too-long
        self,
        *,
        page_size: int = 50,
        customer_id: Optional[str] = None,
        part_number: Optional[str] = None,
        part_revision: Optional[str] = None,
        drawing: Optional[str] = None,
        drawing_revision: Optional[str] = None,
        version: Optional[int] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any
    ) -> _models.MeasurementFormListDtoPagedResult:
        """list_measurment_form_schemas_with_history.

        :keyword page_size: Default value is 50.
        :paramtype page_size: int
        :keyword customer_id: Default value is None.
        :paramtype customer_id: str
        :keyword part_number: Default value is None.
        :paramtype part_number: str
        :keyword part_revision: Default value is None.
        :paramtype part_revision: str
        :keyword drawing: Default value is None.
        :paramtype drawing: str
        :keyword drawing_revision: Default value is None.
        :paramtype drawing_revision: str
        :keyword version: Default value is None.
        :paramtype version: int
        :keyword continuation_token_parameter: Default value is None.
        :paramtype continuation_token_parameter: str
        :return: MeasurementFormListDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormListDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_measurement_form_schemas_list_measurment_form_schemas_with_history_request(
            page_size=page_size,
            customer_id=customer_id,
            part_number=part_number,
            part_revision=part_revision,
            drawing=drawing,
            drawing_revision=drawing_revision,
            version=version,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormListDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_list_measurement_form_schemas_with_history(  # pylint: disable=name-too-long
        self,
        body: Optional[_models.ListMeasurementFormSchemasWithHistoryRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormListDtoPagedResult:
        """post_list_measurement_form_schemas_with_history.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListMeasurementFormSchemasWithHistoryRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormListDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_measurement_form_schemas_with_history(  # pylint: disable=name-too-long
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormListDtoPagedResult:
        """post_list_measurement_form_schemas_with_history.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormListDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_measurement_form_schemas_with_history(  # pylint: disable=name-too-long
        self,
        body: Optional[Union[_models.ListMeasurementFormSchemasWithHistoryRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.MeasurementFormListDtoPagedResult:
        """post_list_measurement_form_schemas_with_history.

        :param body: Is either a ListMeasurementFormSchemasWithHistoryRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.ListMeasurementFormSchemasWithHistoryRequest or IO[bytes]
        :return: MeasurementFormListDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormListDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListMeasurementFormSchemasWithHistoryRequest")
            else:
                _json = None

        _request = build_measurement_form_schemas_post_list_measurement_form_schemas_with_history_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormListDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MeasurementFormsInstancesOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`measurement_forms_instances` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_measurement_forms(
        self,
        *,
        page_size: int = 50,
        search: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        tenant_id: Optional[str] = None,
        inactive: Optional[bool] = None,
        include_inactive_supplier_access: Optional[bool] = None,
        **kwargs: Any
    ) -> _models.MeasurementFormInstanceOverviewDtoPagedResult:
        """list_measurement_forms.

        :keyword page_size: Default value is 50.
        :paramtype page_size: int
        :keyword search: Default value is None.
        :paramtype search: str
        :keyword continuation_token_parameter: Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :keyword inactive: Default value is None.
        :paramtype inactive: bool
        :keyword include_inactive_supplier_access: Default value is None.
        :paramtype include_inactive_supplier_access: bool
        :return: MeasurementFormInstanceOverviewDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceOverviewDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormInstanceOverviewDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_list_measurement_forms_request(
            page_size=page_size,
            search=search,
            continuation_token_parameter=continuation_token_parameter,
            tenant_id=tenant_id,
            inactive=inactive,
            include_inactive_supplier_access=include_inactive_supplier_access,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormInstanceOverviewDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_list_measurement_forms(
        self,
        body: Optional[_models.ListMeasurementFormsRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormInstanceOverviewDtoPagedResult:
        """post_list_measurement_forms.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListMeasurementFormsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormInstanceOverviewDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceOverviewDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_measurement_forms(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormInstanceOverviewDtoPagedResult:
        """post_list_measurement_forms.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormInstanceOverviewDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceOverviewDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_measurement_forms(
        self, body: Optional[Union[_models.ListMeasurementFormsRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasurementFormInstanceOverviewDtoPagedResult:
        """post_list_measurement_forms.

        :param body: Is either a ListMeasurementFormsRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.ListMeasurementFormsRequest or IO[bytes]
        :return: MeasurementFormInstanceOverviewDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceOverviewDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormInstanceOverviewDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListMeasurementFormsRequest")
            else:
                _json = None

        _request = build_measurement_forms_instances_post_list_measurement_forms_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormInstanceOverviewDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_measurement_forms_by_status(
        self,
        *,
        status: Optional[Union[str, _models.MeasurementFormInstanceStatus]] = None,
        status_changed_since: Optional[datetime.datetime] = None,
        only_with_reports: Optional[bool] = None,
        page_size: int = 50,
        search: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any
    ) -> _models.MeasurementFormInstanceDtoPagedResult:
        """list_measurement_forms_by_status.

        :keyword status: Known values are: "Active", "Cancelled", "Completed", and "Approved". Default
         value is None.
        :paramtype status: str or ~ignos.api.client.models.MeasurementFormInstanceStatus
        :keyword status_changed_since: Default value is None.
        :paramtype status_changed_since: ~datetime.datetime
        :keyword only_with_reports: Default value is None.
        :paramtype only_with_reports: bool
        :keyword page_size: Default value is 50.
        :paramtype page_size: int
        :keyword search: Default value is None.
        :paramtype search: str
        :keyword continuation_token_parameter: Default value is None.
        :paramtype continuation_token_parameter: str
        :return: MeasurementFormInstanceDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormInstanceDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_list_measurement_forms_by_status_request(
            status=status,
            status_changed_since=status_changed_since,
            only_with_reports=only_with_reports,
            page_size=page_size,
            search=search,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormInstanceDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_list_measurement_forms_by_status(
        self,
        body: Optional[_models.ListMeasurementFormsByStatusRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormInstanceDtoPagedResult:
        """post_list_measurement_forms_by_status.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListMeasurementFormsByStatusRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormInstanceDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_measurement_forms_by_status(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormInstanceDtoPagedResult:
        """post_list_measurement_forms_by_status.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormInstanceDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_measurement_forms_by_status(
        self, body: Optional[Union[_models.ListMeasurementFormsByStatusRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasurementFormInstanceDtoPagedResult:
        """post_list_measurement_forms_by_status.

        :param body: Is either a ListMeasurementFormsByStatusRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.ListMeasurementFormsByStatusRequest or IO[bytes]
        :return: MeasurementFormInstanceDtoPagedResult
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormInstanceDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListMeasurementFormsByStatusRequest")
            else:
                _json = None

        _request = build_measurement_forms_instances_post_list_measurement_forms_by_status_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormInstanceDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_measurement_form_instance(
        self, id: str, *, tenant_id: Optional[str] = None, **kwargs: Any
    ) -> _models.MeasurementFormInstanceDto:
        """get_measurement_form_instance.

        :param id: Required.
        :type id: str
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :return: MeasurementFormInstanceDto
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormInstanceDto] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_get_measurement_form_instance_request(
            id=id,
            tenant_id=tenant_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormInstanceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def create_measurement_form_instance(self, id: str, **kwargs: Any) -> _models.MeasurementFormInstanceDto:
        """create_measurement_form_instance.

        :param id: Required.
        :type id: str
        :return: MeasurementFormInstanceDto
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormInstanceDto] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_create_measurement_form_instance_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormInstanceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_measurement_form_instance(
        self,
        id: str,
        body: Optional[_models.UpdateMeasurementFormInstanceRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormInstanceDto:
        """update_measurement_form_instance.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateMeasurementFormInstanceRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormInstanceDto
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_measurement_form_instance(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormInstanceDto:
        """update_measurement_form_instance.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormInstanceDto
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_measurement_form_instance(
        self,
        id: str,
        body: Optional[Union[_models.UpdateMeasurementFormInstanceRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.MeasurementFormInstanceDto:
        """update_measurement_form_instance.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateMeasurementFormInstanceRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.UpdateMeasurementFormInstanceRequest or IO[bytes]
        :return: MeasurementFormInstanceDto
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormInstanceDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateMeasurementFormInstanceRequest")
            else:
                _json = None

        _request = build_measurement_forms_instances_update_measurement_form_instance_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormInstanceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_measurement_form_instance_feedback(
        self, id: str, **kwargs: Any
    ) -> List[_models.MeasurementFormInstanceFeedbackDto]:
        """list_measurement_form_instance_feedback.

        :param id: Required.
        :type id: str
        :return: list of MeasurementFormInstanceFeedbackDto
        :rtype: list[~ignos.api.client.models.MeasurementFormInstanceFeedbackDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MeasurementFormInstanceFeedbackDto]] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_list_measurement_form_instance_feedback_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MeasurementFormInstanceFeedbackDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def complete_measurement_form_instance(
        self, id: str, *, tenant_id: Optional[str] = None, **kwargs: Any
    ) -> _models.MeasurementFormInstanceDto:
        """complete_measurement_form_instance.

        :param id: Required.
        :type id: str
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :return: MeasurementFormInstanceDto
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormInstanceDto] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_complete_measurement_form_instance_request(
            id=id,
            tenant_id=tenant_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormInstanceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def reactivate_measurement_form_instance(self, id: str, **kwargs: Any) -> _models.MeasurementFormInstanceDto:
        """reactivate_measurement_form_instance.

        :param id: Required.
        :type id: str
        :return: MeasurementFormInstanceDto
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormInstanceDto] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_reactivate_measurement_form_instance_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormInstanceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def approve_measurement_form_instance(self, id: str, **kwargs: Any) -> _models.MeasurementFormInstanceDto:
        """approve_measurement_form_instance.

        :param id: Required.
        :type id: str
        :return: MeasurementFormInstanceDto
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormInstanceDto] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_approve_measurement_form_instance_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormInstanceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def disapprove_measurement_form_instance(self, id: str, **kwargs: Any) -> _models.MeasurementFormInstanceDto:
        """disapprove_measurement_form_instance.

        :param id: Required.
        :type id: str
        :return: MeasurementFormInstanceDto
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormInstanceDto] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_disapprove_measurement_form_instance_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormInstanceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def cancel_measurement_form_instance(self, id: str, **kwargs: Any) -> _models.MeasurementFormInstanceDto:
        """cancel_measurement_form_instance.

        :param id: Required.
        :type id: str
        :return: MeasurementFormInstanceDto
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormInstanceDto] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_cancel_measurement_form_instance_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormInstanceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_measurement_form_instance_schema(
        self, id: str, schema_id: str, *, sequence: Optional[str] = None, tenant_id: Optional[str] = None, **kwargs: Any
    ) -> _models.MeasurementFormInstanceSchemaDto:
        """get_measurement_form_instance_schema.

        :param id: Required.
        :type id: str
        :param schema_id: Required.
        :type schema_id: str
        :keyword sequence: Default value is None.
        :paramtype sequence: str
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :return: MeasurementFormInstanceSchemaDto
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceSchemaDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormInstanceSchemaDto] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_get_measurement_form_instance_schema_request(
            id=id,
            schema_id=schema_id,
            sequence=sequence,
            tenant_id=tenant_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormInstanceSchemaDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_workorder_measurement_form_progress(
        self, id: str, *, tenant_id: Optional[str] = None, **kwargs: Any
    ) -> _models.MeasurementFormInstanceProgressDto:
        """get_workorder_measurement_form_progress.

        :param id: Required.
        :type id: str
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :return: MeasurementFormInstanceProgressDto
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceProgressDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasurementFormInstanceProgressDto] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_get_workorder_measurement_form_progress_request(
            id=id,
            tenant_id=tenant_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormInstanceProgressDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_audit_log(
        self,
        id: str,
        *,
        tenant_id: Optional[str] = None,
        schema_id: Optional[str] = None,
        sequence: Optional[str] = None,
        element_id: Optional[str] = None,
        **kwargs: Any
    ) -> List[_models.MeasurementFormElementValueAuditDto]:
        """get_audit_log.

        :param id: Required.
        :type id: str
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :keyword schema_id: Default value is None.
        :paramtype schema_id: str
        :keyword sequence: Default value is None.
        :paramtype sequence: str
        :keyword element_id: Default value is None.
        :paramtype element_id: str
        :return: list of MeasurementFormElementValueAuditDto
        :rtype: list[~ignos.api.client.models.MeasurementFormElementValueAuditDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MeasurementFormElementValueAuditDto]] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_get_audit_log_request(
            id=id,
            tenant_id=tenant_id,
            schema_id=schema_id,
            sequence=sequence,
            element_id=element_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MeasurementFormElementValueAuditDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_validation_rules(self, **kwargs: Any) -> List[_models.ValidationRuleDto]:
        """get_validation_rules.

        :return: list of ValidationRuleDto
        :rtype: list[~ignos.api.client.models.ValidationRuleDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ValidationRuleDto]] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_get_validation_rules_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[ValidationRuleDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def save_value(
        self,
        id: str,
        body: Optional[_models.SaveValueRequest] = None,
        *,
        tenant_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SaveValueResponseDto:
        """save_value.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.SaveValueRequest
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SaveValueResponseDto
        :rtype: ~ignos.api.client.models.SaveValueResponseDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def save_value(
        self,
        id: str,
        body: Optional[IO[bytes]] = None,
        *,
        tenant_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SaveValueResponseDto:
        """save_value.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: SaveValueResponseDto
        :rtype: ~ignos.api.client.models.SaveValueResponseDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def save_value(
        self,
        id: str,
        body: Optional[Union[_models.SaveValueRequest, IO[bytes]]] = None,
        *,
        tenant_id: Optional[str] = None,
        **kwargs: Any
    ) -> _models.SaveValueResponseDto:
        """save_value.

        :param id: Required.
        :type id: str
        :param body: Is either a SaveValueRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.SaveValueRequest or IO[bytes]
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :return: SaveValueResponseDto
        :rtype: ~ignos.api.client.models.SaveValueResponseDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SaveValueResponseDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "SaveValueRequest")
            else:
                _json = None

        _request = build_measurement_forms_instances_save_value_request(
            id=id,
            tenant_id=tenant_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("SaveValueResponseDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def save_tool(
        self,
        id: str,
        body: Optional[_models.SaveToolRequest] = None,
        *,
        tenant_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SaveValueResponseDto:
        """save_tool.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.SaveToolRequest
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SaveValueResponseDto
        :rtype: ~ignos.api.client.models.SaveValueResponseDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def save_tool(
        self,
        id: str,
        body: Optional[IO[bytes]] = None,
        *,
        tenant_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SaveValueResponseDto:
        """save_tool.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: SaveValueResponseDto
        :rtype: ~ignos.api.client.models.SaveValueResponseDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def save_tool(
        self,
        id: str,
        body: Optional[Union[_models.SaveToolRequest, IO[bytes]]] = None,
        *,
        tenant_id: Optional[str] = None,
        **kwargs: Any
    ) -> _models.SaveValueResponseDto:
        """save_tool.

        :param id: Required.
        :type id: str
        :param body: Is either a SaveToolRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.SaveToolRequest or IO[bytes]
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :return: SaveValueResponseDto
        :rtype: ~ignos.api.client.models.SaveValueResponseDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SaveValueResponseDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "SaveToolRequest")
            else:
                _json = None

        _request = build_measurement_forms_instances_save_tool_request(
            id=id,
            tenant_id=tenant_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("SaveValueResponseDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def save_comment(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[_models.SaveCommentRequest] = None,
        *,
        tenant_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """save_comment.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.SaveCommentRequest
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def save_comment(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[IO[bytes]] = None,
        *,
        tenant_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """save_comment.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def save_comment(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[Union[_models.SaveCommentRequest, IO[bytes]]] = None,
        *,
        tenant_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """save_comment.

        :param id: Required.
        :type id: str
        :param body: Is either a SaveCommentRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.SaveCommentRequest or IO[bytes]
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "SaveCommentRequest")
            else:
                _json = None

        _request = build_measurement_forms_instances_save_comment_request(
            id=id,
            tenant_id=tenant_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def batch_insert_values(
        self,
        id: str,
        body: Optional[_models.BatchInsertValueRequest] = None,
        *,
        tenant_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BatchInsertValuesResponseDto:
        """batch_insert_values.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.BatchInsertValueRequest
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: BatchInsertValuesResponseDto
        :rtype: ~ignos.api.client.models.BatchInsertValuesResponseDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def batch_insert_values(
        self,
        id: str,
        body: Optional[IO[bytes]] = None,
        *,
        tenant_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.BatchInsertValuesResponseDto:
        """batch_insert_values.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: BatchInsertValuesResponseDto
        :rtype: ~ignos.api.client.models.BatchInsertValuesResponseDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def batch_insert_values(
        self,
        id: str,
        body: Optional[Union[_models.BatchInsertValueRequest, IO[bytes]]] = None,
        *,
        tenant_id: Optional[str] = None,
        **kwargs: Any
    ) -> _models.BatchInsertValuesResponseDto:
        """batch_insert_values.

        :param id: Required.
        :type id: str
        :param body: Is either a BatchInsertValueRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.BatchInsertValueRequest or IO[bytes]
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :return: BatchInsertValuesResponseDto
        :rtype: ~ignos.api.client.models.BatchInsertValuesResponseDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.BatchInsertValuesResponseDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "BatchInsertValueRequest")
            else:
                _json = None

        _request = build_measurement_forms_instances_batch_insert_values_request(
            id=id,
            tenant_id=tenant_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("BatchInsertValuesResponseDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def save_measurement_form_instance_schema_comment(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        id: str,
        schema_id: str,
        body: Optional[_models.SaveMeasurementFormInstanceSchemaCommentRequest] = None,
        *,
        tenant_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """save_measurement_form_instance_schema_comment.

        :param id: Required.
        :type id: str
        :param schema_id: Required.
        :type schema_id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.SaveMeasurementFormInstanceSchemaCommentRequest
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def save_measurement_form_instance_schema_comment(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        id: str,
        schema_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        tenant_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """save_measurement_form_instance_schema_comment.

        :param id: Required.
        :type id: str
        :param schema_id: Required.
        :type schema_id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def save_measurement_form_instance_schema_comment(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        id: str,
        schema_id: str,
        body: Optional[Union[_models.SaveMeasurementFormInstanceSchemaCommentRequest, IO[bytes]]] = None,
        *,
        tenant_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """save_measurement_form_instance_schema_comment.

        :param id: Required.
        :type id: str
        :param schema_id: Required.
        :type schema_id: str
        :param body: Is either a SaveMeasurementFormInstanceSchemaCommentRequest type or a IO[bytes]
         type. Default value is None.
        :type body: ~ignos.api.client.models.SaveMeasurementFormInstanceSchemaCommentRequest or
         IO[bytes]
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "SaveMeasurementFormInstanceSchemaCommentRequest")
            else:
                _json = None

        _request = build_measurement_forms_instances_save_measurement_form_instance_schema_comment_request(
            id=id,
            schema_id=schema_id,
            tenant_id=tenant_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def create_measurement_form_instance_schema_feedback(  # pylint: disable=name-too-long
        self,
        id: str,
        schema_id: str,
        body: Optional[_models.CreateMeasurementFormSchemaFeedbackRequest] = None,
        *,
        tenant_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SchemaFeedbackCreatedDto:
        """create_measurement_form_instance_schema_feedback.

        :param id: Required.
        :type id: str
        :param schema_id: Required.
        :type schema_id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateMeasurementFormSchemaFeedbackRequest
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SchemaFeedbackCreatedDto
        :rtype: ~ignos.api.client.models.SchemaFeedbackCreatedDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_measurement_form_instance_schema_feedback(  # pylint: disable=name-too-long
        self,
        id: str,
        schema_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        tenant_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SchemaFeedbackCreatedDto:
        """create_measurement_form_instance_schema_feedback.

        :param id: Required.
        :type id: str
        :param schema_id: Required.
        :type schema_id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: SchemaFeedbackCreatedDto
        :rtype: ~ignos.api.client.models.SchemaFeedbackCreatedDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_measurement_form_instance_schema_feedback(  # pylint: disable=name-too-long
        self,
        id: str,
        schema_id: str,
        body: Optional[Union[_models.CreateMeasurementFormSchemaFeedbackRequest, IO[bytes]]] = None,
        *,
        tenant_id: Optional[str] = None,
        **kwargs: Any
    ) -> _models.SchemaFeedbackCreatedDto:
        """create_measurement_form_instance_schema_feedback.

        :param id: Required.
        :type id: str
        :param schema_id: Required.
        :type schema_id: str
        :param body: Is either a CreateMeasurementFormSchemaFeedbackRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.CreateMeasurementFormSchemaFeedbackRequest or IO[bytes]
        :keyword tenant_id: Default value is None.
        :paramtype tenant_id: str
        :return: SchemaFeedbackCreatedDto
        :rtype: ~ignos.api.client.models.SchemaFeedbackCreatedDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SchemaFeedbackCreatedDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateMeasurementFormSchemaFeedbackRequest")
            else:
                _json = None

        _request = build_measurement_forms_instances_create_measurement_form_instance_schema_feedback_request(
            id=id,
            schema_id=schema_id,
            tenant_id=tenant_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("SchemaFeedbackCreatedDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_supplier_measurement_form_instances(
        self, supplier_id: str, **kwargs: Any
    ) -> List[_models.MeasurementFormSupplierAccessInstanceDto]:
        """list_supplier_measurement_form_instances.

        :param supplier_id: Required.
        :type supplier_id: str
        :return: list of MeasurementFormSupplierAccessInstanceDto
        :rtype: list[~ignos.api.client.models.MeasurementFormSupplierAccessInstanceDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MeasurementFormSupplierAccessInstanceDto]] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_list_supplier_measurement_form_instances_request(
            supplier_id=supplier_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MeasurementFormSupplierAccessInstanceDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def upsert_supplier_to_measurment_form_instance(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        id: str,
        supplier_id: str,
        body: Optional[_models.UpsertSupplierToMeasurementFormInstanceRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """upsert_supplier_to_measurment_form_instance.

        :param id: Required.
        :type id: str
        :param supplier_id: Required.
        :type supplier_id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpsertSupplierToMeasurementFormInstanceRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def upsert_supplier_to_measurment_form_instance(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        id: str,
        supplier_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """upsert_supplier_to_measurment_form_instance.

        :param id: Required.
        :type id: str
        :param supplier_id: Required.
        :type supplier_id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def upsert_supplier_to_measurment_form_instance(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        id: str,
        supplier_id: str,
        body: Optional[Union[_models.UpsertSupplierToMeasurementFormInstanceRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """upsert_supplier_to_measurment_form_instance.

        :param id: Required.
        :type id: str
        :param supplier_id: Required.
        :type supplier_id: str
        :param body: Is either a UpsertSupplierToMeasurementFormInstanceRequest type or a IO[bytes]
         type. Default value is None.
        :type body: ~ignos.api.client.models.UpsertSupplierToMeasurementFormInstanceRequest or
         IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpsertSupplierToMeasurementFormInstanceRequest")
            else:
                _json = None

        _request = build_measurement_forms_instances_upsert_supplier_to_measurment_form_instance_request(
            id=id,
            supplier_id=supplier_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def remove_supplier_from_measurment_form_instance(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, id: str, supplier_id: str, **kwargs: Any
    ) -> None:
        """remove_supplier_from_measurment_form_instance.

        :param id: Required.
        :type id: str
        :param supplier_id: Required.
        :type supplier_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_remove_supplier_from_measurment_form_instance_request(
            id=id,
            supplier_id=supplier_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def export_dimension_report(
        self,
        id: str,
        body: Optional[_models.ExportDimensionReportRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DownloadDto:
        """export_dimension_report.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ExportDimensionReportRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DownloadDto
        :rtype: ~ignos.api.client.models.DownloadDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def export_dimension_report(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DownloadDto:
        """export_dimension_report.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: DownloadDto
        :rtype: ~ignos.api.client.models.DownloadDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def export_dimension_report(
        self, id: str, body: Optional[Union[_models.ExportDimensionReportRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.DownloadDto:
        """export_dimension_report.

        :param id: Required.
        :type id: str
        :param body: Is either a ExportDimensionReportRequest type or a IO[bytes] type. Default value
         is None.
        :type body: ~ignos.api.client.models.ExportDimensionReportRequest or IO[bytes]
        :return: DownloadDto
        :rtype: ~ignos.api.client.models.DownloadDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DownloadDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ExportDimensionReportRequest")
            else:
                _json = None

        _request = build_measurement_forms_instances_export_dimension_report_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("DownloadDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_schema_instance_elements(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        schema_id: str,
        body: Optional[_models.UpdateSchemaInstanceElementsRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """update_schema_instance_elements.

        :param id: Required.
        :type id: str
        :param schema_id: Required.
        :type schema_id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateSchemaInstanceElementsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_schema_instance_elements(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        schema_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """update_schema_instance_elements.

        :param id: Required.
        :type id: str
        :param schema_id: Required.
        :type schema_id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_schema_instance_elements(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        schema_id: str,
        body: Optional[Union[_models.UpdateSchemaInstanceElementsRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """update_schema_instance_elements.

        :param id: Required.
        :type id: str
        :param schema_id: Required.
        :type schema_id: str
        :param body: Is either a UpdateSchemaInstanceElementsRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.UpdateSchemaInstanceElementsRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateSchemaInstanceElementsRequest")
            else:
                _json = None

        _request = build_measurement_forms_instances_update_schema_instance_elements_request(
            id=id,
            schema_id=schema_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_schema_instance_elements(
        self, id: str, schema_id: str, **kwargs: Any
    ) -> List[_models.SchemaInstanceElementDto]:
        """get_schema_instance_elements.

        :param id: Required.
        :type id: str
        :param schema_id: Required.
        :type schema_id: str
        :return: list of SchemaInstanceElementDto
        :rtype: list[~ignos.api.client.models.SchemaInstanceElementDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SchemaInstanceElementDto]] = kwargs.pop("cls", None)

        _request = build_measurement_forms_instances_get_schema_instance_elements_request(
            id=id,
            schema_id=schema_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[SchemaInstanceElementDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def import_measurement_form_instance(
        self,
        id: str,
        body: Optional[_models.ImportMeasurementFormInstanceRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasurementFormInstanceDto:
        """import_measurement_form_instance.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ImportMeasurementFormInstanceRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasurementFormInstanceDto
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def import_measurement_form_instance(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasurementFormInstanceDto:
        """import_measurement_form_instance.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasurementFormInstanceDto
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def import_measurement_form_instance(
        self,
        id: str,
        body: Optional[Union[_models.ImportMeasurementFormInstanceRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.MeasurementFormInstanceDto:
        """import_measurement_form_instance.

        :param id: Required.
        :type id: str
        :param body: Is either a ImportMeasurementFormInstanceRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.ImportMeasurementFormInstanceRequest or IO[bytes]
        :return: MeasurementFormInstanceDto
        :rtype: ~ignos.api.client.models.MeasurementFormInstanceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasurementFormInstanceDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ImportMeasurementFormInstanceRequest")
            else:
                _json = None

        _request = build_measurement_forms_instances_import_measurement_form_instance_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasurementFormInstanceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MeasuringToolsOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`measuring_tools` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_measuring_tools(
        self,
        *,
        page: Optional[int] = None,
        page_size: int = 100,
        tool_id: Optional[str] = None,
        tool_name: Optional[str] = None,
        type_id: Optional[str] = None,
        sub_type_id: Optional[str] = None,
        order_by: Optional[str] = None,
        sort_direction: Optional[str] = None,
        include_deprecated: bool = False,
        **kwargs: Any
    ) -> _models.MeasuringToolDtoPagedData:
        """list_measuring_tools.

        :keyword page: Default value is None.
        :paramtype page: int
        :keyword page_size: Default value is 100.
        :paramtype page_size: int
        :keyword tool_id: Default value is None.
        :paramtype tool_id: str
        :keyword tool_name: Default value is None.
        :paramtype tool_name: str
        :keyword type_id: Default value is None.
        :paramtype type_id: str
        :keyword sub_type_id: Default value is None.
        :paramtype sub_type_id: str
        :keyword order_by: Default value is None.
        :paramtype order_by: str
        :keyword sort_direction: Default value is None.
        :paramtype sort_direction: str
        :keyword include_deprecated: Default value is False.
        :paramtype include_deprecated: bool
        :return: MeasuringToolDtoPagedData
        :rtype: ~ignos.api.client.models.MeasuringToolDtoPagedData
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasuringToolDtoPagedData] = kwargs.pop("cls", None)

        _request = build_measuring_tools_list_measuring_tools_request(
            page=page,
            page_size=page_size,
            tool_id=tool_id,
            tool_name=tool_name,
            type_id=type_id,
            sub_type_id=sub_type_id,
            order_by=order_by,
            sort_direction=sort_direction,
            include_deprecated=include_deprecated,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasuringToolDtoPagedData", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_measuring_tool(
        self,
        body: Optional[_models.CreateMeasuringToolRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasuringToolDetailDto:
        """create_measuring_tool.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateMeasuringToolRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasuringToolDetailDto
        :rtype: ~ignos.api.client.models.MeasuringToolDetailDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_measuring_tool(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasuringToolDetailDto:
        """create_measuring_tool.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasuringToolDetailDto
        :rtype: ~ignos.api.client.models.MeasuringToolDetailDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_measuring_tool(
        self, body: Optional[Union[_models.CreateMeasuringToolRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasuringToolDetailDto:
        """create_measuring_tool.

        :param body: Is either a CreateMeasuringToolRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.CreateMeasuringToolRequest or IO[bytes]
        :return: MeasuringToolDetailDto
        :rtype: ~ignos.api.client.models.MeasuringToolDetailDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasuringToolDetailDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateMeasuringToolRequest")
            else:
                _json = None

        _request = build_measuring_tools_create_measuring_tool_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasuringToolDetailDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_measuring_tool(
        self,
        id: str,
        body: Optional[_models.UpdateMeasuringToolRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasuringToolDetailDto:
        """update_measuring_tool.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateMeasuringToolRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasuringToolDetailDto
        :rtype: ~ignos.api.client.models.MeasuringToolDetailDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_measuring_tool(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasuringToolDetailDto:
        """update_measuring_tool.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasuringToolDetailDto
        :rtype: ~ignos.api.client.models.MeasuringToolDetailDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_measuring_tool(
        self, id: str, body: Optional[Union[_models.UpdateMeasuringToolRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasuringToolDetailDto:
        """update_measuring_tool.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateMeasuringToolRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.UpdateMeasuringToolRequest or IO[bytes]
        :return: MeasuringToolDetailDto
        :rtype: ~ignos.api.client.models.MeasuringToolDetailDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasuringToolDetailDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateMeasuringToolRequest")
            else:
                _json = None

        _request = build_measuring_tools_update_measuring_tool_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasuringToolDetailDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_measuring_tool(self, id: str, **kwargs: Any) -> _models.MeasuringToolDetailDto:
        """get_measuring_tool.

        :param id: Required.
        :type id: str
        :return: MeasuringToolDetailDto
        :rtype: ~ignos.api.client.models.MeasuringToolDetailDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasuringToolDetailDto] = kwargs.pop("cls", None)

        _request = build_measuring_tools_get_measuring_tool_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasuringToolDetailDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_calibrations(self, id: str, **kwargs: Any) -> List[_models.MeasuringToolCalibrationDto]:
        """list_calibrations.

        :param id: Required.
        :type id: str
        :return: list of MeasuringToolCalibrationDto
        :rtype: list[~ignos.api.client.models.MeasuringToolCalibrationDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MeasuringToolCalibrationDto]] = kwargs.pop("cls", None)

        _request = build_measuring_tools_list_calibrations_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MeasuringToolCalibrationDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def register_calibration(
        self,
        id: str,
        body: Optional[_models.RegisterMeasuringToolCalibrationRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasuringToolCalibrationDto:
        """register_calibration.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.RegisterMeasuringToolCalibrationRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasuringToolCalibrationDto
        :rtype: ~ignos.api.client.models.MeasuringToolCalibrationDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def register_calibration(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasuringToolCalibrationDto:
        """register_calibration.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasuringToolCalibrationDto
        :rtype: ~ignos.api.client.models.MeasuringToolCalibrationDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def register_calibration(
        self,
        id: str,
        body: Optional[Union[_models.RegisterMeasuringToolCalibrationRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.MeasuringToolCalibrationDto:
        """register_calibration.

        :param id: Required.
        :type id: str
        :param body: Is either a RegisterMeasuringToolCalibrationRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.RegisterMeasuringToolCalibrationRequest or IO[bytes]
        :return: MeasuringToolCalibrationDto
        :rtype: ~ignos.api.client.models.MeasuringToolCalibrationDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasuringToolCalibrationDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "RegisterMeasuringToolCalibrationRequest")
            else:
                _json = None

        _request = build_measuring_tools_register_calibration_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasuringToolCalibrationDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def attach_calibration_certificate(
        self,
        id: str,
        calibration_id: str,
        body: Optional[_models.AttachCalibrationCertificateRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasuringToolCalibrationDto:
        """attach_calibration_certificate.

        :param id: Required.
        :type id: str
        :param calibration_id: Required.
        :type calibration_id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.AttachCalibrationCertificateRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasuringToolCalibrationDto
        :rtype: ~ignos.api.client.models.MeasuringToolCalibrationDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def attach_calibration_certificate(
        self,
        id: str,
        calibration_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasuringToolCalibrationDto:
        """attach_calibration_certificate.

        :param id: Required.
        :type id: str
        :param calibration_id: Required.
        :type calibration_id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasuringToolCalibrationDto
        :rtype: ~ignos.api.client.models.MeasuringToolCalibrationDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def attach_calibration_certificate(
        self,
        id: str,
        calibration_id: str,
        body: Optional[Union[_models.AttachCalibrationCertificateRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.MeasuringToolCalibrationDto:
        """attach_calibration_certificate.

        :param id: Required.
        :type id: str
        :param calibration_id: Required.
        :type calibration_id: str
        :param body: Is either a AttachCalibrationCertificateRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.AttachCalibrationCertificateRequest or IO[bytes]
        :return: MeasuringToolCalibrationDto
        :rtype: ~ignos.api.client.models.MeasuringToolCalibrationDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasuringToolCalibrationDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "AttachCalibrationCertificateRequest")
            else:
                _json = None

        _request = build_measuring_tools_attach_calibration_certificate_request(
            id=id,
            calibration_id=calibration_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasuringToolCalibrationDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_calibration_certificate(  # pylint: disable=inconsistent-return-statements
        self, id: str, calibration_id: str, **kwargs: Any
    ) -> None:
        """delete_calibration_certificate.

        :param id: Required.
        :type id: str
        :param calibration_id: Required.
        :type calibration_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_measuring_tools_delete_calibration_certificate_request(
            id=id,
            calibration_id=calibration_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_manufacturers(self, **kwargs: Any) -> List[_models.ManufacturerDto]:
        """list_manufacturers.

        :return: list of ManufacturerDto
        :rtype: list[~ignos.api.client.models.ManufacturerDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ManufacturerDto]] = kwargs.pop("cls", None)

        _request = build_measuring_tools_list_manufacturers_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[ManufacturerDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_manufacturer(
        self,
        body: Optional[_models.CreateMeasuringToolManufacturer] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ManufacturerDto:
        """create_manufacturer.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateMeasuringToolManufacturer
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ManufacturerDto
        :rtype: ~ignos.api.client.models.ManufacturerDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_manufacturer(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ManufacturerDto:
        """create_manufacturer.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: ManufacturerDto
        :rtype: ~ignos.api.client.models.ManufacturerDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_manufacturer(
        self, body: Optional[Union[_models.CreateMeasuringToolManufacturer, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.ManufacturerDto:
        """create_manufacturer.

        :param body: Is either a CreateMeasuringToolManufacturer type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.CreateMeasuringToolManufacturer or IO[bytes]
        :return: ManufacturerDto
        :rtype: ~ignos.api.client.models.ManufacturerDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ManufacturerDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateMeasuringToolManufacturer")
            else:
                _json = None

        _request = build_measuring_tools_create_manufacturer_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ManufacturerDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_measuring_tool_types(self, **kwargs: Any) -> List[_models.MeasuringToolTypeDto]:
        """list_measuring_tool_types.

        :return: list of MeasuringToolTypeDto
        :rtype: list[~ignos.api.client.models.MeasuringToolTypeDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MeasuringToolTypeDto]] = kwargs.pop("cls", None)

        _request = build_measuring_tools_list_measuring_tool_types_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MeasuringToolTypeDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_measuring_tool_type(
        self,
        body: Optional[_models.CreateMeasuringToolType] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasuringToolTypeDto:
        """create_measuring_tool_type.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateMeasuringToolType
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasuringToolTypeDto
        :rtype: ~ignos.api.client.models.MeasuringToolTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_measuring_tool_type(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasuringToolTypeDto:
        """create_measuring_tool_type.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasuringToolTypeDto
        :rtype: ~ignos.api.client.models.MeasuringToolTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_measuring_tool_type(
        self, body: Optional[Union[_models.CreateMeasuringToolType, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasuringToolTypeDto:
        """create_measuring_tool_type.

        :param body: Is either a CreateMeasuringToolType type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.CreateMeasuringToolType or IO[bytes]
        :return: MeasuringToolTypeDto
        :rtype: ~ignos.api.client.models.MeasuringToolTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasuringToolTypeDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateMeasuringToolType")
            else:
                _json = None

        _request = build_measuring_tools_create_measuring_tool_type_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasuringToolTypeDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_measuring_tool_type(
        self,
        id: str,
        body: Optional[_models.UpdateMeasuringToolTypeRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasuringToolTypeDto:
        """update_measuring_tool_type.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateMeasuringToolTypeRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasuringToolTypeDto
        :rtype: ~ignos.api.client.models.MeasuringToolTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_measuring_tool_type(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasuringToolTypeDto:
        """update_measuring_tool_type.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasuringToolTypeDto
        :rtype: ~ignos.api.client.models.MeasuringToolTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_measuring_tool_type(
        self, id: str, body: Optional[Union[_models.UpdateMeasuringToolTypeRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasuringToolTypeDto:
        """update_measuring_tool_type.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateMeasuringToolTypeRequest type or a IO[bytes] type. Default value
         is None.
        :type body: ~ignos.api.client.models.UpdateMeasuringToolTypeRequest or IO[bytes]
        :return: MeasuringToolTypeDto
        :rtype: ~ignos.api.client.models.MeasuringToolTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasuringToolTypeDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateMeasuringToolTypeRequest")
            else:
                _json = None

        _request = build_measuring_tools_update_measuring_tool_type_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasuringToolTypeDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_measuring_tool_type(  # pylint: disable=inconsistent-return-statements
        self, id: str, **kwargs: Any
    ) -> None:
        """delete_measuring_tool_type.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_measuring_tools_delete_measuring_tool_type_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_measuring_tool_sub_types(self, type_id: str, **kwargs: Any) -> List[_models.MeasuringToolSubTypeDto]:
        """list_measuring_tool_sub_types.

        :param type_id: Required.
        :type type_id: str
        :return: list of MeasuringToolSubTypeDto
        :rtype: list[~ignos.api.client.models.MeasuringToolSubTypeDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MeasuringToolSubTypeDto]] = kwargs.pop("cls", None)

        _request = build_measuring_tools_list_measuring_tool_sub_types_request(
            type_id=type_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MeasuringToolSubTypeDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_measuring_tool_sub_type(
        self,
        type_id: str,
        body: Optional[_models.CreateMeasuringToolSubTypeRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasuringToolSubTypeDto:
        """create_measuring_tool_sub_type.

        :param type_id: Required.
        :type type_id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateMeasuringToolSubTypeRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasuringToolSubTypeDto
        :rtype: ~ignos.api.client.models.MeasuringToolSubTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_measuring_tool_sub_type(
        self, type_id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasuringToolSubTypeDto:
        """create_measuring_tool_sub_type.

        :param type_id: Required.
        :type type_id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasuringToolSubTypeDto
        :rtype: ~ignos.api.client.models.MeasuringToolSubTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_measuring_tool_sub_type(
        self,
        type_id: str,
        body: Optional[Union[_models.CreateMeasuringToolSubTypeRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.MeasuringToolSubTypeDto:
        """create_measuring_tool_sub_type.

        :param type_id: Required.
        :type type_id: str
        :param body: Is either a CreateMeasuringToolSubTypeRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.CreateMeasuringToolSubTypeRequest or IO[bytes]
        :return: MeasuringToolSubTypeDto
        :rtype: ~ignos.api.client.models.MeasuringToolSubTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasuringToolSubTypeDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateMeasuringToolSubTypeRequest")
            else:
                _json = None

        _request = build_measuring_tools_create_measuring_tool_sub_type_request(
            type_id=type_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasuringToolSubTypeDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_measuring_tool_sub_type(
        self,
        type_id: str,
        id: str,
        body: Optional[_models.UpdateMeasuringToolSubTypeRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasuringToolSubTypeDto:
        """update_measuring_tool_sub_type.

        :param type_id: Required.
        :type type_id: str
        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateMeasuringToolSubTypeRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasuringToolSubTypeDto
        :rtype: ~ignos.api.client.models.MeasuringToolSubTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_measuring_tool_sub_type(
        self,
        type_id: str,
        id: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasuringToolSubTypeDto:
        """update_measuring_tool_sub_type.

        :param type_id: Required.
        :type type_id: str
        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasuringToolSubTypeDto
        :rtype: ~ignos.api.client.models.MeasuringToolSubTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_measuring_tool_sub_type(
        self,
        type_id: str,
        id: str,
        body: Optional[Union[_models.UpdateMeasuringToolSubTypeRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.MeasuringToolSubTypeDto:
        """update_measuring_tool_sub_type.

        :param type_id: Required.
        :type type_id: str
        :param id: Required.
        :type id: str
        :param body: Is either a UpdateMeasuringToolSubTypeRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.UpdateMeasuringToolSubTypeRequest or IO[bytes]
        :return: MeasuringToolSubTypeDto
        :rtype: ~ignos.api.client.models.MeasuringToolSubTypeDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasuringToolSubTypeDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateMeasuringToolSubTypeRequest")
            else:
                _json = None

        _request = build_measuring_tools_update_measuring_tool_sub_type_request(
            type_id=type_id,
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasuringToolSubTypeDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_measuring_tool_sub_type(  # pylint: disable=inconsistent-return-statements
        self, type_id: str, id: str, **kwargs: Any
    ) -> None:
        """delete_measuring_tool_sub_type.

        :param type_id: Required.
        :type type_id: str
        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_measuring_tools_delete_measuring_tool_sub_type_request(
            type_id=type_id,
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_measuring_units(self, **kwargs: Any) -> List[_models.MeasuringUnitDto]:
        """list_measuring_units.

        :return: list of MeasuringUnitDto
        :rtype: list[~ignos.api.client.models.MeasuringUnitDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MeasuringUnitDto]] = kwargs.pop("cls", None)

        _request = build_measuring_tools_list_measuring_units_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MeasuringUnitDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_measuring_unit(
        self,
        body: Optional[_models.CreateMeasuringUnit] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasuringUnitDto:
        """create_measuring_unit.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateMeasuringUnit
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasuringUnitDto
        :rtype: ~ignos.api.client.models.MeasuringUnitDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_measuring_unit(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasuringUnitDto:
        """create_measuring_unit.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasuringUnitDto
        :rtype: ~ignos.api.client.models.MeasuringUnitDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_measuring_unit(
        self, body: Optional[Union[_models.CreateMeasuringUnit, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasuringUnitDto:
        """create_measuring_unit.

        :param body: Is either a CreateMeasuringUnit type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CreateMeasuringUnit or IO[bytes]
        :return: MeasuringUnitDto
        :rtype: ~ignos.api.client.models.MeasuringUnitDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasuringUnitDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateMeasuringUnit")
            else:
                _json = None

        _request = build_measuring_tools_create_measuring_unit_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasuringUnitDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_measuring_unit(  # pylint: disable=inconsistent-return-statements
        self, id: str, **kwargs: Any
    ) -> None:
        """delete_measuring_unit.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_measuring_tools_delete_measuring_unit_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_measuring_tool_whitelist(
        self,
        *,
        page: Optional[int] = None,
        page_size: int = 100,
        filter: Optional[str] = None,
        order_by: Optional[str] = None,
        sort_direction: Optional[str] = None,
        **kwargs: Any
    ) -> _models.MeasuringToolWhitelistDtoPagedData:
        """get_measuring_tool_whitelist.

        :keyword page: Default value is None.
        :paramtype page: int
        :keyword page_size: Default value is 100.
        :paramtype page_size: int
        :keyword filter: Default value is None.
        :paramtype filter: str
        :keyword order_by: Default value is None.
        :paramtype order_by: str
        :keyword sort_direction: Default value is None.
        :paramtype sort_direction: str
        :return: MeasuringToolWhitelistDtoPagedData
        :rtype: ~ignos.api.client.models.MeasuringToolWhitelistDtoPagedData
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasuringToolWhitelistDtoPagedData] = kwargs.pop("cls", None)

        _request = build_measuring_tools_get_measuring_tool_whitelist_request(
            page=page,
            page_size=page_size,
            filter=filter,
            order_by=order_by,
            sort_direction=sort_direction,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasuringToolWhitelistDtoPagedData", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def whitelist_measuring_tool(
        self,
        body: Optional[_models.WhitelistMeasuringTool] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasuringToolWhitelistDto:
        """whitelist_measuring_tool.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.WhitelistMeasuringTool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasuringToolWhitelistDto
        :rtype: ~ignos.api.client.models.MeasuringToolWhitelistDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def whitelist_measuring_tool(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasuringToolWhitelistDto:
        """whitelist_measuring_tool.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasuringToolWhitelistDto
        :rtype: ~ignos.api.client.models.MeasuringToolWhitelistDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def whitelist_measuring_tool(
        self, body: Optional[Union[_models.WhitelistMeasuringTool, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasuringToolWhitelistDto:
        """whitelist_measuring_tool.

        :param body: Is either a WhitelistMeasuringTool type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.WhitelistMeasuringTool or IO[bytes]
        :return: MeasuringToolWhitelistDto
        :rtype: ~ignos.api.client.models.MeasuringToolWhitelistDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasuringToolWhitelistDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "WhitelistMeasuringTool")
            else:
                _json = None

        _request = build_measuring_tools_whitelist_measuring_tool_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasuringToolWhitelistDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_whitelisted_measuring_tool(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[_models.UpdateWhitelistedMeasuringTool] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """update_whitelisted_measuring_tool.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateWhitelistedMeasuringTool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_whitelisted_measuring_tool(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """update_whitelisted_measuring_tool.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_whitelisted_measuring_tool(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[Union[_models.UpdateWhitelistedMeasuringTool, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """update_whitelisted_measuring_tool.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateWhitelistedMeasuringTool type or a IO[bytes] type. Default value
         is None.
        :type body: ~ignos.api.client.models.UpdateWhitelistedMeasuringTool or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateWhitelistedMeasuringTool")
            else:
                _json = None

        _request = build_measuring_tools_update_whitelisted_measuring_tool_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def remove_measuring_tool_from_whitelist(self, id: str, **kwargs: Any) -> Optional[_models.ProblemDetails]:
        """remove_measuring_tool_from_whitelist.

        :param id: Required.
        :type id: str
        :return: ProblemDetails or None
        :rtype: ~ignos.api.client.models.ProblemDetails or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ProblemDetails]] = kwargs.pop("cls", None)

        _request = build_measuring_tools_remove_measuring_tool_from_whitelist_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 404:
            deserialized = self._deserialize("ProblemDetails", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_unregistered_tool_values(self, **kwargs: Any) -> List[_models.UnregisteredToolValueDto]:
        """list_unregistered_tool_values.

        :return: list of UnregisteredToolValueDto
        :rtype: list[~ignos.api.client.models.UnregisteredToolValueDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.UnregisteredToolValueDto]] = kwargs.pop("cls", None)

        _request = build_measuring_tools_list_unregistered_tool_values_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[UnregisteredToolValueDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def deprecate_tool(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[_models.DeprecateToolRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """deprecate_tool.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.DeprecateToolRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def deprecate_tool(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """deprecate_tool.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def deprecate_tool(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[Union[_models.DeprecateToolRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """deprecate_tool.

        :param id: Required.
        :type id: str
        :param body: Is either a DeprecateToolRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.DeprecateToolRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "DeprecateToolRequest")
            else:
                _json = None

        _request = build_measuring_tools_deprecate_tool_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_calibration_list(
        self, *, status: Optional[Union[str, _models.CalibrationListStatus]] = None, **kwargs: Any
    ) -> List[_models.CalibrationListToolDto]:
        """get_calibration_list.

        :keyword status: Known values are: "SoonDue" and "Expired". Default value is None.
        :paramtype status: str or ~ignos.api.client.models.CalibrationListStatus
        :return: list of CalibrationListToolDto
        :rtype: list[~ignos.api.client.models.CalibrationListToolDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CalibrationListToolDto]] = kwargs.pop("cls", None)

        _request = build_measuring_tools_get_calibration_list_request(
            status=status,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[CalibrationListToolDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def import_measuring_tool(
        self,
        body: Optional[_models.ImportMeasuringTool] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MeasuringToolDetailDto:
        """import_measuring_tool.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ImportMeasuringTool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasuringToolDetailDto
        :rtype: ~ignos.api.client.models.MeasuringToolDetailDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def import_measuring_tool(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MeasuringToolDetailDto:
        """import_measuring_tool.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MeasuringToolDetailDto
        :rtype: ~ignos.api.client.models.MeasuringToolDetailDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def import_measuring_tool(
        self, body: Optional[Union[_models.ImportMeasuringTool, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MeasuringToolDetailDto:
        """import_measuring_tool.

        :param body: Is either a ImportMeasuringTool type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.ImportMeasuringTool or IO[bytes]
        :return: MeasuringToolDetailDto
        :rtype: ~ignos.api.client.models.MeasuringToolDetailDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MeasuringToolDetailDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ImportMeasuringTool")
            else:
                _json = None

        _request = build_measuring_tools_import_measuring_tool_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasuringToolDetailDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_measuring_tool_settings(  # pylint: disable=inconsistent-return-statements
        self,
        body: Optional[_models.UpdateMeasuringToolSettings] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """update_measuring_tool_settings.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateMeasuringToolSettings
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_measuring_tool_settings(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """update_measuring_tool_settings.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_measuring_tool_settings(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.UpdateMeasuringToolSettings, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """update_measuring_tool_settings.

        :param body: Is either a UpdateMeasuringToolSettings type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.UpdateMeasuringToolSettings or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateMeasuringToolSettings")
            else:
                _json = None

        _request = build_measuring_tools_update_measuring_tool_settings_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_measuring_tool_settings(self, **kwargs: Any) -> _models.MeasuringToolSettingsDto:
        """get_measuring_tool_settings.

        :return: MeasuringToolSettingsDto
        :rtype: ~ignos.api.client.models.MeasuringToolSettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MeasuringToolSettingsDto] = kwargs.pop("cls", None)

        _request = build_measuring_tools_get_measuring_tool_settings_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MeasuringToolSettingsDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`mes` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_worker_details_for_current_user(self, **kwargs: Any) -> _models.WorkerDto:
        """get_worker_details_for_current_user.

        :return: WorkerDto
        :rtype: ~ignos.api.client.models.WorkerDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkerDto] = kwargs.pop("cls", None)

        _request = build_mes_get_worker_details_for_current_user_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkerDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MesDocumentsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`mes_documents` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_document(self, drawing_number: str, id: str, **kwargs: Any) -> _models.DocumentLinkDto:
        """get_document.

        :param drawing_number: Required.
        :type drawing_number: str
        :param id: Required.
        :type id: str
        :return: DocumentLinkDto
        :rtype: ~ignos.api.client.models.DocumentLinkDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DocumentLinkDto] = kwargs.pop("cls", None)

        _request = build_mes_documents_get_document_request(
            drawing_number=drawing_number,
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("DocumentLinkDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MesLinksOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`mes_links` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def add_mes_link(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[_models.AddMesLink] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """add_mes_link.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.AddMesLink
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_mes_link(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """add_mes_link.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_mes_link(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.AddMesLink, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """add_mes_link.

        :param body: Is either a AddMesLink type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.AddMesLink or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "AddMesLink")
            else:
                _json = None

        _request = build_mes_links_add_mes_link_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_mes_links(
        self,
        *,
        types: Optional[List[Union[str, _models.MesLinkTypeDto]]] = None,
        work_order_id: Optional[str] = None,
        operation: Optional[int] = None,
        **kwargs: Any
    ) -> List[_models.MesLinkDto]:
        """list_mes_links.

        :keyword types: Default value is None.
        :paramtype types: list[str or ~ignos.api.client.models.MesLinkTypeDto]
        :keyword work_order_id: Default value is None.
        :paramtype work_order_id: str
        :keyword operation: Default value is None.
        :paramtype operation: int
        :return: list of MesLinkDto
        :rtype: list[~ignos.api.client.models.MesLinkDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MesLinkDto]] = kwargs.pop("cls", None)

        _request = build_mes_links_list_mes_links_request(
            types=types,
            work_order_id=work_order_id,
            operation=operation,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MesLinkDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_unmapped_mes_links(self, **kwargs: Any) -> List[_models.MesLinkDto]:
        """list_unmapped_mes_links.

        :return: list of MesLinkDto
        :rtype: list[~ignos.api.client.models.MesLinkDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MesLinkDto]] = kwargs.pop("cls", None)

        _request = build_mes_links_list_unmapped_mes_links_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MesLinkDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_mes_link(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[_models.UpdateMesLink] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """update_mes_link.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateMesLink
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_mes_link(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """update_mes_link.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_mes_link(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[Union[_models.UpdateMesLink, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """update_mes_link.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateMesLink type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UpdateMesLink or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateMesLink")
            else:
                _json = None

        _request = build_mes_links_update_mes_link_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_mes_link(self, id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """delete_mes_link.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_mes_links_delete_mes_link_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class MesProductionOrderOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`mes_production_order` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_production_order(self, id: str, **kwargs: Any) -> _models.ProductionOrderDto:
        """get_production_order.

        :param id: Required.
        :type id: str
        :return: ProductionOrderDto
        :rtype: ~ignos.api.client.models.ProductionOrderDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProductionOrderDto] = kwargs.pop("cls", None)

        _request = build_mes_production_order_get_production_order_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ProductionOrderDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_production_order_bom(
        self, id: str, *, operation: Optional[int] = None, **kwargs: Any
    ) -> List[_models.ProductionOrderBomDto]:
        """get_production_order_bom.

        :param id: Required.
        :type id: str
        :keyword operation: Default value is None.
        :paramtype operation: int
        :return: list of ProductionOrderBomDto
        :rtype: list[~ignos.api.client.models.ProductionOrderBomDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProductionOrderBomDto]] = kwargs.pop("cls", None)

        _request = build_mes_production_order_get_production_order_bom_request(
            id=id,
            operation=operation,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[ProductionOrderBomDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_production_order_pick_list_suggestion(  # pylint: disable=name-too-long
        self, id: str, *, operation: Optional[int] = None, **kwargs: Any
    ) -> List[_models.PickListSuggestionDto]:
        """get_production_order_pick_list_suggestion.

        :param id: Required.
        :type id: str
        :keyword operation: Default value is None.
        :paramtype operation: int
        :return: list of PickListSuggestionDto
        :rtype: list[~ignos.api.client.models.PickListSuggestionDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PickListSuggestionDto]] = kwargs.pop("cls", None)

        _request = build_mes_production_order_get_production_order_pick_list_suggestion_request(
            id=id,
            operation=operation,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[PickListSuggestionDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def check_production_order_for_open_non_conformances(  # pylint: disable=name-too-long
        self, id: str, **kwargs: Any
    ) -> bool:
        """check_production_order_for_open_non_conformances.

        :param id: Required.
        :type id: str
        :return: bool
        :rtype: bool
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[bool] = kwargs.pop("cls", None)

        _request = build_mes_production_order_check_production_order_for_open_non_conformances_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("bool", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_production_order_open_non_conformances(  # pylint: disable=name-too-long
        self, id: str, *, only_open: bool = True, **kwargs: Any
    ) -> List[_models.NonConformanceDto]:
        """get_production_order_open_non_conformances.

        :param id: Required.
        :type id: str
        :keyword only_open: Default value is True.
        :paramtype only_open: bool
        :return: list of NonConformanceDto
        :rtype: list[~ignos.api.client.models.NonConformanceDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.NonConformanceDto]] = kwargs.pop("cls", None)

        _request = build_mes_production_order_get_production_order_open_non_conformances_request(
            id=id,
            only_open=only_open,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[NonConformanceDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_material_pick_list(
        self,
        id: str,
        operation_number: int,
        body: _models.PostMaterialPickListRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MaterialPickListResultDto:
        """post_material_pick_list.

        :param id: Required.
        :type id: str
        :param operation_number: Required.
        :type operation_number: int
        :param body: Required.
        :type body: ~ignos.api.client.models.PostMaterialPickListRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MaterialPickListResultDto
        :rtype: ~ignos.api.client.models.MaterialPickListResultDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_material_pick_list(
        self, id: str, operation_number: int, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MaterialPickListResultDto:
        """post_material_pick_list.

        :param id: Required.
        :type id: str
        :param operation_number: Required.
        :type operation_number: int
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MaterialPickListResultDto
        :rtype: ~ignos.api.client.models.MaterialPickListResultDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_material_pick_list(
        self, id: str, operation_number: int, body: Union[_models.PostMaterialPickListRequest, IO[bytes]], **kwargs: Any
    ) -> _models.MaterialPickListResultDto:
        """post_material_pick_list.

        :param id: Required.
        :type id: str
        :param operation_number: Required.
        :type operation_number: int
        :param body: Is either a PostMaterialPickListRequest type or a IO[bytes] type. Required.
        :type body: ~ignos.api.client.models.PostMaterialPickListRequest or IO[bytes]
        :return: MaterialPickListResultDto
        :rtype: ~ignos.api.client.models.MaterialPickListResultDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MaterialPickListResultDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "PostMaterialPickListRequest")

        _request = build_mes_production_order_post_material_pick_list_request(
            id=id,
            operation_number=operation_number,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MaterialPickListResultDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_production_order_activities(
        self, id: str, *, operation: Optional[int] = None, **kwargs: Any
    ) -> List[_models.ProductionOrderOperationActivityDto]:
        """list_production_order_activities.

        :param id: Required.
        :type id: str
        :keyword operation: Default value is None.
        :paramtype operation: int
        :return: list of ProductionOrderOperationActivityDto
        :rtype: list[~ignos.api.client.models.ProductionOrderOperationActivityDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProductionOrderOperationActivityDto]] = kwargs.pop("cls", None)

        _request = build_mes_production_order_list_production_order_activities_request(
            id=id,
            operation=operation,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[ProductionOrderOperationActivityDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MesProductionScheduleOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`mes_production_schedule` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_production_schedule_operations(
        self,
        *,
        resource_group: Optional[str] = None,
        resource_id: Optional[str] = None,
        page_size: int = 50,
        continuation_token_parameter: Optional[str] = None,
        work_order_id: Optional[str] = None,
        project_id: Optional[str] = None,
        part_number: Optional[str] = None,
        part_name: Optional[str] = None,
        material: Optional[str] = None,
        **kwargs: Any
    ) -> _models.ProductionScheduleOperationDtoPagedResult:
        """list_production_schedule_operations.

        :keyword resource_group: Default value is None.
        :paramtype resource_group: str
        :keyword resource_id: Default value is None.
        :paramtype resource_id: str
        :keyword page_size: Default value is 50.
        :paramtype page_size: int
        :keyword continuation_token_parameter: Default value is None.
        :paramtype continuation_token_parameter: str
        :keyword work_order_id: Default value is None.
        :paramtype work_order_id: str
        :keyword project_id: Default value is None.
        :paramtype project_id: str
        :keyword part_number: Default value is None.
        :paramtype part_number: str
        :keyword part_name: Default value is None.
        :paramtype part_name: str
        :keyword material: Default value is None.
        :paramtype material: str
        :return: ProductionScheduleOperationDtoPagedResult
        :rtype: ~ignos.api.client.models.ProductionScheduleOperationDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProductionScheduleOperationDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_mes_production_schedule_list_production_schedule_operations_request(
            resource_group=resource_group,
            resource_id=resource_id,
            page_size=page_size,
            continuation_token_parameter=continuation_token_parameter,
            work_order_id=work_order_id,
            project_id=project_id,
            part_number=part_number,
            part_name=part_name,
            material=material,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ProductionScheduleOperationDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_list_production_schedule_operations(
        self,
        body: Optional[_models.ListProductionScheduleOperationsRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProductionScheduleOperationDtoPagedResult:
        """post_list_production_schedule_operations.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListProductionScheduleOperationsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProductionScheduleOperationDtoPagedResult
        :rtype: ~ignos.api.client.models.ProductionScheduleOperationDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_production_schedule_operations(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProductionScheduleOperationDtoPagedResult:
        """post_list_production_schedule_operations.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: ProductionScheduleOperationDtoPagedResult
        :rtype: ~ignos.api.client.models.ProductionScheduleOperationDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_production_schedule_operations(
        self, body: Optional[Union[_models.ListProductionScheduleOperationsRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.ProductionScheduleOperationDtoPagedResult:
        """post_list_production_schedule_operations.

        :param body: Is either a ListProductionScheduleOperationsRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.ListProductionScheduleOperationsRequest or IO[bytes]
        :return: ProductionScheduleOperationDtoPagedResult
        :rtype: ~ignos.api.client.models.ProductionScheduleOperationDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProductionScheduleOperationDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListProductionScheduleOperationsRequest")
            else:
                _json = None

        _request = build_mes_production_schedule_post_list_production_schedule_operations_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ProductionScheduleOperationDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def get_available_production_schedule_filters(  # pylint: disable=name-too-long
        self,
        body: Optional[_models.GetAvailableProductionScheduleFiltersRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProductionScheduleFiltersDto:
        """get_available_production_schedule_filters.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.GetAvailableProductionScheduleFiltersRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProductionScheduleFiltersDto
        :rtype: ~ignos.api.client.models.ProductionScheduleFiltersDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def get_available_production_schedule_filters(  # pylint: disable=name-too-long
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProductionScheduleFiltersDto:
        """get_available_production_schedule_filters.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: ProductionScheduleFiltersDto
        :rtype: ~ignos.api.client.models.ProductionScheduleFiltersDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def get_available_production_schedule_filters(  # pylint: disable=name-too-long
        self,
        body: Optional[Union[_models.GetAvailableProductionScheduleFiltersRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.ProductionScheduleFiltersDto:
        """get_available_production_schedule_filters.

        :param body: Is either a GetAvailableProductionScheduleFiltersRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.GetAvailableProductionScheduleFiltersRequest or IO[bytes]
        :return: ProductionScheduleFiltersDto
        :rtype: ~ignos.api.client.models.ProductionScheduleFiltersDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProductionScheduleFiltersDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "GetAvailableProductionScheduleFiltersRequest")
            else:
                _json = None

        _request = build_mes_production_schedule_get_available_production_schedule_filters_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ProductionScheduleFiltersDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_my_current_work_activities(self, **kwargs: Any) -> _models.CurrentWorkActivityDto:
        """list_my_current_work_activities.

        :return: CurrentWorkActivityDto
        :rtype: ~ignos.api.client.models.CurrentWorkActivityDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CurrentWorkActivityDto] = kwargs.pop("cls", None)

        _request = build_mes_production_schedule_list_my_current_work_activities_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CurrentWorkActivityDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_my_current_work_activities_v2(self, **kwargs: Any) -> _models.CurrentWorkActivityDto:
        """list_my_current_work_activities_v2.

        :return: CurrentWorkActivityDto
        :rtype: ~ignos.api.client.models.CurrentWorkActivityDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CurrentWorkActivityDto] = kwargs.pop("cls", None)

        _request = build_mes_production_schedule_list_my_current_work_activities_v2_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CurrentWorkActivityDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def start_operations(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[_models.StartOperations] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """start_operations.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.StartOperations
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def start_operations(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """start_operations.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def start_operations(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.StartOperations, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """start_operations.

        :param body: Is either a StartOperations type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.StartOperations or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "StartOperations")
            else:
                _json = None

        _request = build_mes_production_schedule_start_operations_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def report_operation_progress(  # pylint: disable=inconsistent-return-statements
        self,
        body: Optional[_models.ReportOperationProgress] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """report_operation_progress.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ReportOperationProgress
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def report_operation_progress(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """report_operation_progress.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def report_operation_progress(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.ReportOperationProgress, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """report_operation_progress.

        :param body: Is either a ReportOperationProgress type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.ReportOperationProgress or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ReportOperationProgress")
            else:
                _json = None

        _request = build_mes_production_schedule_report_operation_progress_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_scheduled_work_summary(
        self, *, resource_group: Optional[str] = None, resource_id: Optional[str] = None, **kwargs: Any
    ) -> _models.ScheduledWorkSummaryDto:
        """get_scheduled_work_summary.

        :keyword resource_group: Default value is None.
        :paramtype resource_group: str
        :keyword resource_id: Default value is None.
        :paramtype resource_id: str
        :return: ScheduledWorkSummaryDto
        :rtype: ~ignos.api.client.models.ScheduledWorkSummaryDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ScheduledWorkSummaryDto] = kwargs.pop("cls", None)

        _request = build_mes_production_schedule_get_scheduled_work_summary_request(
            resource_group=resource_group,
            resource_id=resource_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ScheduledWorkSummaryDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MesProjectsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`mes_projects` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def list_projects(
        self,
        body: Optional[_models.ListProjectsRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkOrderProjectDtoPagedResult:
        """list_projects.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListProjectsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkOrderProjectDtoPagedResult
        :rtype: ~ignos.api.client.models.WorkOrderProjectDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def list_projects(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.WorkOrderProjectDtoPagedResult:
        """list_projects.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: WorkOrderProjectDtoPagedResult
        :rtype: ~ignos.api.client.models.WorkOrderProjectDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def list_projects(
        self, body: Optional[Union[_models.ListProjectsRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.WorkOrderProjectDtoPagedResult:
        """list_projects.

        :param body: Is either a ListProjectsRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.ListProjectsRequest or IO[bytes]
        :return: WorkOrderProjectDtoPagedResult
        :rtype: ~ignos.api.client.models.WorkOrderProjectDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkOrderProjectDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListProjectsRequest")
            else:
                _json = None

        _request = build_mes_projects_list_projects_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkOrderProjectDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def list_order_schedule(
        self,
        body: Optional[_models.ListOrderScheduleRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkorderDtoPagedResult:
        """list_order_schedule.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListOrderScheduleRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkorderDtoPagedResult
        :rtype: ~ignos.api.client.models.WorkorderDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def list_order_schedule(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.WorkorderDtoPagedResult:
        """list_order_schedule.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: WorkorderDtoPagedResult
        :rtype: ~ignos.api.client.models.WorkorderDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def list_order_schedule(
        self, body: Optional[Union[_models.ListOrderScheduleRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.WorkorderDtoPagedResult:
        """list_order_schedule.

        :param body: Is either a ListOrderScheduleRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.ListOrderScheduleRequest or IO[bytes]
        :return: WorkorderDtoPagedResult
        :rtype: ~ignos.api.client.models.WorkorderDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkorderDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListOrderScheduleRequest")
            else:
                _json = None

        _request = build_mes_projects_list_order_schedule_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkorderDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MesResourceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`mes_resource` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_resource_groups(
        self, *, include_resources: bool = False, **kwargs: Any
    ) -> List[_models.ResourceGroupDto]:
        """list_resource_groups.

        :keyword include_resources: Default value is False.
        :paramtype include_resources: bool
        :return: list of ResourceGroupDto
        :rtype: list[~ignos.api.client.models.ResourceGroupDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ResourceGroupDto]] = kwargs.pop("cls", None)

        _request = build_mes_resource_list_resource_groups_request(
            include_resources=include_resources,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[ResourceGroupDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_resource_group_resources(self, id: str, **kwargs: Any) -> List[_models.ProductionResourceDto]:
        """list_resource_group_resources.

        :param id: Required.
        :type id: str
        :return: list of ProductionResourceDto
        :rtype: list[~ignos.api.client.models.ProductionResourceDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProductionResourceDto]] = kwargs.pop("cls", None)

        _request = build_mes_resource_list_resource_group_resources_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[ProductionResourceDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MrbOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`mrb` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_mrb_instances(
        self, *, customer_order: Optional[str] = None, customer_order_line: Optional[int] = None, **kwargs: Any
    ) -> List[_models.MrbInstanceDto]:
        """list_mrb_instances.

        :keyword customer_order: Default value is None.
        :paramtype customer_order: str
        :keyword customer_order_line: Default value is None.
        :paramtype customer_order_line: int
        :return: list of MrbInstanceDto
        :rtype: list[~ignos.api.client.models.MrbInstanceDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MrbInstanceDto]] = kwargs.pop("cls", None)

        _request = build_mrb_list_mrb_instances_request(
            customer_order=customer_order,
            customer_order_line=customer_order_line,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MrbInstanceDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_mrb(
        self, body: Optional[_models.CreateMrb] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MrbInstanceJobDto:
        """create_mrb.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateMrb
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MrbInstanceJobDto
        :rtype: ~ignos.api.client.models.MrbInstanceJobDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_mrb(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MrbInstanceJobDto:
        """create_mrb.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MrbInstanceJobDto
        :rtype: ~ignos.api.client.models.MrbInstanceJobDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_mrb(
        self, body: Optional[Union[_models.CreateMrb, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MrbInstanceJobDto:
        """create_mrb.

        :param body: Is either a CreateMrb type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CreateMrb or IO[bytes]
        :return: MrbInstanceJobDto
        :rtype: ~ignos.api.client.models.MrbInstanceJobDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MrbInstanceJobDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateMrb")
            else:
                _json = None

        _request = build_mrb_create_mrb_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MrbInstanceJobDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_recent_mrb_intances(self, **kwargs: Any) -> List[_models.MrbInstanceDto]:
        """list_recent_mrb_intances.

        :return: list of MrbInstanceDto
        :rtype: list[~ignos.api.client.models.MrbInstanceDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MrbInstanceDto]] = kwargs.pop("cls", None)

        _request = build_mrb_list_recent_mrb_intances_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MrbInstanceDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_mrb_instance(self, id: str, **kwargs: Any) -> _models.MrbInstanceDto:
        """get_mrb_instance.

        :param id: Required.
        :type id: str
        :return: MrbInstanceDto
        :rtype: ~ignos.api.client.models.MrbInstanceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MrbInstanceDto] = kwargs.pop("cls", None)

        _request = build_mrb_get_mrb_instance_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MrbInstanceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_mrb_instance_revisions(self, id: str, **kwargs: Any) -> List[_models.MrbInstanceRevisionDto]:
        """list_mrb_instance_revisions.

        :param id: Required.
        :type id: str
        :return: list of MrbInstanceRevisionDto
        :rtype: list[~ignos.api.client.models.MrbInstanceRevisionDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MrbInstanceRevisionDto]] = kwargs.pop("cls", None)

        _request = build_mrb_list_mrb_instance_revisions_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MrbInstanceRevisionDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_mrb_revision(
        self,
        id: str,
        body: Optional[_models.CreateMrbRevisionRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MrbInstanceJobDto:
        """create_mrb_revision.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateMrbRevisionRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MrbInstanceJobDto
        :rtype: ~ignos.api.client.models.MrbInstanceJobDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_mrb_revision(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MrbInstanceJobDto:
        """create_mrb_revision.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MrbInstanceJobDto
        :rtype: ~ignos.api.client.models.MrbInstanceJobDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_mrb_revision(
        self, id: str, body: Optional[Union[_models.CreateMrbRevisionRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MrbInstanceJobDto:
        """create_mrb_revision.

        :param id: Required.
        :type id: str
        :param body: Is either a CreateMrbRevisionRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.CreateMrbRevisionRequest or IO[bytes]
        :return: MrbInstanceJobDto
        :rtype: ~ignos.api.client.models.MrbInstanceJobDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MrbInstanceJobDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateMrbRevisionRequest")
            else:
                _json = None

        _request = build_mrb_create_mrb_revision_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MrbInstanceJobDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_mrb_revision_content(self, id: str, revision_id: int, **kwargs: Any) -> _models.MrbContentDto:
        """get_mrb_revision_content.

        :param id: Required.
        :type id: str
        :param revision_id: Required.
        :type revision_id: int
        :return: MrbContentDto
        :rtype: ~ignos.api.client.models.MrbContentDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MrbContentDto] = kwargs.pop("cls", None)

        _request = build_mrb_get_mrb_revision_content_request(
            id=id,
            revision_id=revision_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MrbContentDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def approve_mrb_revision(  # pylint: disable=inconsistent-return-statements
        self, id: str, revision_id: int, **kwargs: Any
    ) -> None:
        """approve_mrb_revision.

        :param id: Required.
        :type id: str
        :param revision_id: Required.
        :type revision_id: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_mrb_approve_mrb_revision_request(
            id=id,
            revision_id=revision_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def reject_mrb_revision(  # pylint: disable=inconsistent-return-statements
        self, id: str, revision_id: int, **kwargs: Any
    ) -> None:
        """reject_mrb_revision.

        :param id: Required.
        :type id: str
        :param revision_id: Required.
        :type revision_id: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_mrb_reject_mrb_revision_request(
            id=id,
            revision_id=revision_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def create_mrb_revision_pdf(self, id: str, revision_id: int, **kwargs: Any) -> _models.MrbPdfExportJobDto:
        """create_mrb_revision_pdf.

        :param id: Required.
        :type id: str
        :param revision_id: Required.
        :type revision_id: int
        :return: MrbPdfExportJobDto
        :rtype: ~ignos.api.client.models.MrbPdfExportJobDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MrbPdfExportJobDto] = kwargs.pop("cls", None)

        _request = build_mrb_create_mrb_revision_pdf_request(
            id=id,
            revision_id=revision_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MrbPdfExportJobDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def refresh_mrb_revision_content(self, id: str, revision_id: int, **kwargs: Any) -> _models.MrbInstanceJobDto:
        """refresh_mrb_revision_content.

        :param id: Required.
        :type id: str
        :param revision_id: Required.
        :type revision_id: int
        :return: MrbInstanceJobDto
        :rtype: ~ignos.api.client.models.MrbInstanceJobDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MrbInstanceJobDto] = kwargs.pop("cls", None)

        _request = build_mrb_refresh_mrb_revision_content_request(
            id=id,
            revision_id=revision_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MrbInstanceJobDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def include_mrb_revision_content(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        revision_id: int,
        body: Optional[_models.IncludeExcludeMrbRevisionContentRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """include_mrb_revision_content.

        :param id: Required.
        :type id: str
        :param revision_id: Required.
        :type revision_id: int
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.IncludeExcludeMrbRevisionContentRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def include_mrb_revision_content(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        revision_id: int,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """include_mrb_revision_content.

        :param id: Required.
        :type id: str
        :param revision_id: Required.
        :type revision_id: int
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def include_mrb_revision_content(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        revision_id: int,
        body: Optional[Union[_models.IncludeExcludeMrbRevisionContentRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """include_mrb_revision_content.

        :param id: Required.
        :type id: str
        :param revision_id: Required.
        :type revision_id: int
        :param body: Is either a IncludeExcludeMrbRevisionContentRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.IncludeExcludeMrbRevisionContentRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "IncludeExcludeMrbRevisionContentRequest")
            else:
                _json = None

        _request = build_mrb_include_mrb_revision_content_request(
            id=id,
            revision_id=revision_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def exclude_mrb_revision_content(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        revision_id: int,
        body: Optional[_models.IncludeExcludeMrbRevisionContentRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """exclude_mrb_revision_content.

        :param id: Required.
        :type id: str
        :param revision_id: Required.
        :type revision_id: int
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.IncludeExcludeMrbRevisionContentRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def exclude_mrb_revision_content(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        revision_id: int,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """exclude_mrb_revision_content.

        :param id: Required.
        :type id: str
        :param revision_id: Required.
        :type revision_id: int
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def exclude_mrb_revision_content(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        revision_id: int,
        body: Optional[Union[_models.IncludeExcludeMrbRevisionContentRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """exclude_mrb_revision_content.

        :param id: Required.
        :type id: str
        :param revision_id: Required.
        :type revision_id: int
        :param body: Is either a IncludeExcludeMrbRevisionContentRequest type or a IO[bytes] type.
         Default value is None.
        :type body: ~ignos.api.client.models.IncludeExcludeMrbRevisionContentRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "IncludeExcludeMrbRevisionContentRequest")
            else:
                _json = None

        _request = build_mrb_exclude_mrb_revision_content_request(
            id=id,
            revision_id=revision_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def upload_mrb_revision_pdf(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        revision_id: int,
        body: Optional[_models.AttachPdfRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """upload_mrb_revision_pdf.

        :param id: Required.
        :type id: str
        :param revision_id: Required.
        :type revision_id: int
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.AttachPdfRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def upload_mrb_revision_pdf(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        revision_id: int,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """upload_mrb_revision_pdf.

        :param id: Required.
        :type id: str
        :param revision_id: Required.
        :type revision_id: int
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def upload_mrb_revision_pdf(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        revision_id: int,
        body: Optional[Union[_models.AttachPdfRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """upload_mrb_revision_pdf.

        :param id: Required.
        :type id: str
        :param revision_id: Required.
        :type revision_id: int
        :param body: Is either a AttachPdfRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.AttachPdfRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "AttachPdfRequest")
            else:
                _json = None

        _request = build_mrb_upload_mrb_revision_pdf_request(
            id=id,
            revision_id=revision_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def mark_mrb_revision_as_sent(  # pylint: disable=inconsistent-return-statements
        self, id: str, revision_id: int, **kwargs: Any
    ) -> None:
        """mark_mrb_revision_as_sent.

        :param id: Required.
        :type id: str
        :param revision_id: Required.
        :type revision_id: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_mrb_mark_mrb_revision_as_sent_request(
            id=id,
            revision_id=revision_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def create_mrb_revision_link(self, id: str, revision_id: int, **kwargs: Any) -> _models.DownloadDto:
        """create_mrb_revision_link.

        :param id: Required.
        :type id: str
        :param revision_id: Required.
        :type revision_id: int
        :return: DownloadDto
        :rtype: ~ignos.api.client.models.DownloadDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DownloadDto] = kwargs.pop("cls", None)

        _request = build_mrb_create_mrb_revision_link_request(
            id=id,
            revision_id=revision_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("DownloadDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_mrb_instance_job_status(self, job_id: str, **kwargs: Any) -> _models.MrbInstanceJobDto:
        """get_mrb_instance_job_status.

        :param job_id: Required.
        :type job_id: str
        :return: MrbInstanceJobDto
        :rtype: ~ignos.api.client.models.MrbInstanceJobDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MrbInstanceJobDto] = kwargs.pop("cls", None)

        _request = build_mrb_get_mrb_instance_job_status_request(
            job_id=job_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MrbInstanceJobDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_mrb_pdf_export_job_status(self, job_id: str, **kwargs: Any) -> _models.MrbPdfExportJobDto:
        """get_mrb_pdf_export_job_status.

        :param job_id: Required.
        :type job_id: str
        :return: MrbPdfExportJobDto
        :rtype: ~ignos.api.client.models.MrbPdfExportJobDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MrbPdfExportJobDto] = kwargs.pop("cls", None)

        _request = build_mrb_get_mrb_pdf_export_job_status_request(
            job_id=job_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MrbPdfExportJobDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_mrb_instance_reports(
        self, *, page_size: int = 50, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> _models.MrbInstanceReportDtoPagedResult:
        """list_mrb_instance_reports.

        :keyword page_size: Default value is 50.
        :paramtype page_size: int
        :keyword continuation_token_parameter: Default value is None.
        :paramtype continuation_token_parameter: str
        :return: MrbInstanceReportDtoPagedResult
        :rtype: ~ignos.api.client.models.MrbInstanceReportDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MrbInstanceReportDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_mrb_list_mrb_instance_reports_request(
            page_size=page_size,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MrbInstanceReportDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_list_mrb_instance_reports(
        self,
        body: Optional[_models.ListMrbInstanceReportsRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MrbInstanceReportDtoPagedResult:
        """post_list_mrb_instance_reports.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListMrbInstanceReportsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MrbInstanceReportDtoPagedResult
        :rtype: ~ignos.api.client.models.MrbInstanceReportDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_mrb_instance_reports(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MrbInstanceReportDtoPagedResult:
        """post_list_mrb_instance_reports.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MrbInstanceReportDtoPagedResult
        :rtype: ~ignos.api.client.models.MrbInstanceReportDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_mrb_instance_reports(
        self, body: Optional[Union[_models.ListMrbInstanceReportsRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MrbInstanceReportDtoPagedResult:
        """post_list_mrb_instance_reports.

        :param body: Is either a ListMrbInstanceReportsRequest type or a IO[bytes] type. Default value
         is None.
        :type body: ~ignos.api.client.models.ListMrbInstanceReportsRequest or IO[bytes]
        :return: MrbInstanceReportDtoPagedResult
        :rtype: ~ignos.api.client.models.MrbInstanceReportDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MrbInstanceReportDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListMrbInstanceReportsRequest")
            else:
                _json = None

        _request = build_mrb_post_list_mrb_instance_reports_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MrbInstanceReportDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def attach_pdf(  # pylint: disable=inconsistent-return-statements
        self,
        template_id: str,
        body: Optional[_models.AttachPdfRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """attach_pdf.

        :param template_id: Required.
        :type template_id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.AttachPdfRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def attach_pdf(  # pylint: disable=inconsistent-return-statements
        self,
        template_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """attach_pdf.

        :param template_id: Required.
        :type template_id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def attach_pdf(  # pylint: disable=inconsistent-return-statements
        self, template_id: str, body: Optional[Union[_models.AttachPdfRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """attach_pdf.

        :param template_id: Required.
        :type template_id: str
        :param body: Is either a AttachPdfRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.AttachPdfRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "AttachPdfRequest")
            else:
                _json = None

        _request = build_mrb_attach_pdf_request(
            template_id=template_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_mrb_template(self, template_id: str, **kwargs: Any) -> _models.MrbTemplateDto:
        """Get a single MRB template by id.

        Get a single MRB template by id.

        :param template_id: Required.
        :type template_id: str
        :return: MrbTemplateDto
        :rtype: ~ignos.api.client.models.MrbTemplateDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MrbTemplateDto] = kwargs.pop("cls", None)

        _request = build_mrb_get_mrb_template_request(
            template_id=template_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MrbTemplateDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_mrb_templates(
        self, *, customer_id: Optional[str] = None, customer_group_id: Optional[str] = None, **kwargs: Any
    ) -> List[_models.MrbTemplateDto]:
        """Get a list of MRB templates.

        Get a list of MRB templates.

        :keyword customer_id: Default value is None.
        :paramtype customer_id: str
        :keyword customer_group_id: Default value is None.
        :paramtype customer_group_id: str
        :return: list of MrbTemplateDto
        :rtype: list[~ignos.api.client.models.MrbTemplateDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MrbTemplateDto]] = kwargs.pop("cls", None)

        _request = build_mrb_list_mrb_templates_request(
            customer_id=customer_id,
            customer_group_id=customer_group_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MrbTemplateDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_mrb_template(
        self,
        body: Optional[_models.CreateMrbTemplateRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MrbTemplateDto:
        """Create a new MRB template.

        Create a new MRB template.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateMrbTemplateRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MrbTemplateDto
        :rtype: ~ignos.api.client.models.MrbTemplateDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_mrb_template(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MrbTemplateDto:
        """Create a new MRB template.

        Create a new MRB template.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MrbTemplateDto
        :rtype: ~ignos.api.client.models.MrbTemplateDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_mrb_template(
        self, body: Optional[Union[_models.CreateMrbTemplateRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MrbTemplateDto:
        """Create a new MRB template.

        Create a new MRB template.

        :param body: Is either a CreateMrbTemplateRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.CreateMrbTemplateRequest or IO[bytes]
        :return: MrbTemplateDto
        :rtype: ~ignos.api.client.models.MrbTemplateDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MrbTemplateDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateMrbTemplateRequest")
            else:
                _json = None

        _request = build_mrb_create_mrb_template_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MrbTemplateDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_mrb_template(
        self, body: Optional[_models.UpdateMrbTemplate] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MrbTemplateDto:
        """Update an MRB template.

        Update an MRB template.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateMrbTemplate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MrbTemplateDto
        :rtype: ~ignos.api.client.models.MrbTemplateDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_mrb_template(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MrbTemplateDto:
        """Update an MRB template.

        Update an MRB template.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MrbTemplateDto
        :rtype: ~ignos.api.client.models.MrbTemplateDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_mrb_template(
        self, body: Optional[Union[_models.UpdateMrbTemplate, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MrbTemplateDto:
        """Update an MRB template.

        Update an MRB template.

        :param body: Is either a UpdateMrbTemplate type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UpdateMrbTemplate or IO[bytes]
        :return: MrbTemplateDto
        :rtype: ~ignos.api.client.models.MrbTemplateDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MrbTemplateDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateMrbTemplate")
            else:
                _json = None

        _request = build_mrb_update_mrb_template_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MrbTemplateDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def delete_mrb_template(  # pylint: disable=inconsistent-return-statements
        self,
        body: Optional[_models.DeleteMrbTemplateRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Delete an MRB template.

        Delete an MRB template.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.DeleteMrbTemplateRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def delete_mrb_template(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Delete an MRB template.

        Delete an MRB template.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def delete_mrb_template(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.DeleteMrbTemplateRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """Delete an MRB template.

        Delete an MRB template.

        :param body: Is either a DeleteMrbTemplateRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.DeleteMrbTemplateRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "DeleteMrbTemplateRequest")
            else:
                _json = None

        _request = build_mrb_delete_mrb_template_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_mrb_company_settings(self, **kwargs: Any) -> _models.MrbCompanySettingsDto:
        """get_mrb_company_settings.

        :return: MrbCompanySettingsDto
        :rtype: ~ignos.api.client.models.MrbCompanySettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.MrbCompanySettingsDto] = kwargs.pop("cls", None)

        _request = build_mrb_get_mrb_company_settings_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MrbCompanySettingsDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def upsert_mrb_company_settings(
        self,
        body: Optional[_models.UpsertMrbCompanySettings] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MrbCompanySettingsDto:
        """upsert_mrb_company_settings.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpsertMrbCompanySettings
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MrbCompanySettingsDto
        :rtype: ~ignos.api.client.models.MrbCompanySettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def upsert_mrb_company_settings(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MrbCompanySettingsDto:
        """upsert_mrb_company_settings.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MrbCompanySettingsDto
        :rtype: ~ignos.api.client.models.MrbCompanySettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def upsert_mrb_company_settings(
        self, body: Optional[Union[_models.UpsertMrbCompanySettings, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MrbCompanySettingsDto:
        """upsert_mrb_company_settings.

        :param body: Is either a UpsertMrbCompanySettings type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.UpsertMrbCompanySettings or IO[bytes]
        :return: MrbCompanySettingsDto
        :rtype: ~ignos.api.client.models.MrbCompanySettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MrbCompanySettingsDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpsertMrbCompanySettings")
            else:
                _json = None

        _request = build_mrb_upsert_mrb_company_settings_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MrbCompanySettingsDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class OperatorCalculatorsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`operator_calculators` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def calculate_spindle_and_cutting_speed(
        self,
        body: Optional[_models.CalculateSpindleAndCuttingSpeed] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SpindleAndCuttingSpeedDto:
        """Calculate spindle speed from cutting speed or vice versa.

        Calculate spindle speed from cutting speed or vice versa.

        :param body: Contains diameter, and one of cutting speed or spindle speed. Default value is
         None.
        :type body: ~ignos.api.client.models.CalculateSpindleAndCuttingSpeed
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SpindleAndCuttingSpeedDto
        :rtype: ~ignos.api.client.models.SpindleAndCuttingSpeedDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def calculate_spindle_and_cutting_speed(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SpindleAndCuttingSpeedDto:
        """Calculate spindle speed from cutting speed or vice versa.

        Calculate spindle speed from cutting speed or vice versa.

        :param body: Contains diameter, and one of cutting speed or spindle speed. Default value is
         None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: SpindleAndCuttingSpeedDto
        :rtype: ~ignos.api.client.models.SpindleAndCuttingSpeedDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def calculate_spindle_and_cutting_speed(
        self, body: Optional[Union[_models.CalculateSpindleAndCuttingSpeed, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.SpindleAndCuttingSpeedDto:
        """Calculate spindle speed from cutting speed or vice versa.

        Calculate spindle speed from cutting speed or vice versa.

        :param body: Contains diameter, and one of cutting speed or spindle speed. Is either a
         CalculateSpindleAndCuttingSpeed type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CalculateSpindleAndCuttingSpeed or IO[bytes]
        :return: SpindleAndCuttingSpeedDto
        :rtype: ~ignos.api.client.models.SpindleAndCuttingSpeedDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SpindleAndCuttingSpeedDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CalculateSpindleAndCuttingSpeed")
            else:
                _json = None

        _request = build_operator_calculators_calculate_spindle_and_cutting_speed_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("SpindleAndCuttingSpeedDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def calculate_right_angled_triangle(
        self,
        body: Optional[_models.CalculateRightAngledTriangle] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.RightAngledTriangleDto:
        """Calculate right angled triangle dimensions from two of angle, hypotenuse, adjacent side and
        opposite side.

        Calculate right angled triangle dimensions from two of angle, hypotenuse, adjacent side and
        opposite side.

        :param body: Contains the two parameters to calculate from. Default value is None.
        :type body: ~ignos.api.client.models.CalculateRightAngledTriangle
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RightAngledTriangleDto
        :rtype: ~ignos.api.client.models.RightAngledTriangleDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def calculate_right_angled_triangle(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RightAngledTriangleDto:
        """Calculate right angled triangle dimensions from two of angle, hypotenuse, adjacent side and
        opposite side.

        Calculate right angled triangle dimensions from two of angle, hypotenuse, adjacent side and
        opposite side.

        :param body: Contains the two parameters to calculate from. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: RightAngledTriangleDto
        :rtype: ~ignos.api.client.models.RightAngledTriangleDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def calculate_right_angled_triangle(
        self, body: Optional[Union[_models.CalculateRightAngledTriangle, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.RightAngledTriangleDto:
        """Calculate right angled triangle dimensions from two of angle, hypotenuse, adjacent side and
        opposite side.

        Calculate right angled triangle dimensions from two of angle, hypotenuse, adjacent side and
        opposite side.

        :param body: Contains the two parameters to calculate from. Is either a
         CalculateRightAngledTriangle type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CalculateRightAngledTriangle or IO[bytes]
        :return: RightAngledTriangleDto
        :rtype: ~ignos.api.client.models.RightAngledTriangleDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RightAngledTriangleDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CalculateRightAngledTriangle")
            else:
                _json = None

        _request = build_operator_calculators_calculate_right_angled_triangle_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("RightAngledTriangleDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_materials_with_density(self, **kwargs: Any) -> List[_models.MaterialMassDensityDto]:
        """List default material types with mass density.

        List default material types with mass density.

        :return: list of MaterialMassDensityDto
        :rtype: list[~ignos.api.client.models.MaterialMassDensityDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.MaterialMassDensityDto]] = kwargs.pop("cls", None)

        _request = build_operator_calculators_list_materials_with_density_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[MaterialMassDensityDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def calculate_bar_weight(
        self,
        body: Optional[_models.CalculateBarWeight] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.MaterialWeightDto:
        """Calculate weight of bar.

        Calculate weight of bar.

        :param body: Contains dimensions and mass density for given material. Default value is None.
        :type body: ~ignos.api.client.models.CalculateBarWeight
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MaterialWeightDto
        :rtype: ~ignos.api.client.models.MaterialWeightDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def calculate_bar_weight(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.MaterialWeightDto:
        """Calculate weight of bar.

        Calculate weight of bar.

        :param body: Contains dimensions and mass density for given material. Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: MaterialWeightDto
        :rtype: ~ignos.api.client.models.MaterialWeightDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def calculate_bar_weight(
        self, body: Optional[Union[_models.CalculateBarWeight, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.MaterialWeightDto:
        """Calculate weight of bar.

        Calculate weight of bar.

        :param body: Contains dimensions and mass density for given material. Is either a
         CalculateBarWeight type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CalculateBarWeight or IO[bytes]
        :return: MaterialWeightDto
        :rtype: ~ignos.api.client.models.MaterialWeightDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MaterialWeightDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CalculateBarWeight")
            else:
                _json = None

        _request = build_operator_calculators_calculate_bar_weight_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("MaterialWeightDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class PowerOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`power` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_power_regions(self, *, country: Optional[str] = None, **kwargs: Any) -> List[_models.PowerRegionDto]:
        """list_power_regions.

        :keyword country: Default value is None.
        :paramtype country: str
        :return: list of PowerRegionDto
        :rtype: list[~ignos.api.client.models.PowerRegionDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PowerRegionDto]] = kwargs.pop("cls", None)

        _request = build_power_list_power_regions_request(
            country=country,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[PowerRegionDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class PresentationOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`presentation` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_component_settings(self, component_id: str, **kwargs: Any) -> _models.ComponentSettingsDto:
        """get_component_settings.

        :param component_id: Required.
        :type component_id: str
        :return: ComponentSettingsDto
        :rtype: ~ignos.api.client.models.ComponentSettingsDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ComponentSettingsDto] = kwargs.pop("cls", None)

        _request = build_presentation_get_component_settings_request(
            component_id=component_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ComponentSettingsDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class SuppliersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`suppliers` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_supplier_invites(self, **kwargs: Any) -> List[_models.SupplierInviteDto]:
        """list_supplier_invites.

        :return: list of SupplierInviteDto
        :rtype: list[~ignos.api.client.models.SupplierInviteDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.SupplierInviteDto]] = kwargs.pop("cls", None)

        _request = build_suppliers_list_supplier_invites_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[SupplierInviteDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_supplier_invite(
        self,
        body: Optional[_models.CreateSupplierInvite] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SupplierInviteDto:
        """create_supplier_invite.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateSupplierInvite
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SupplierInviteDto
        :rtype: ~ignos.api.client.models.SupplierInviteDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_supplier_invite(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SupplierInviteDto:
        """create_supplier_invite.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: SupplierInviteDto
        :rtype: ~ignos.api.client.models.SupplierInviteDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_supplier_invite(
        self, body: Optional[Union[_models.CreateSupplierInvite, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.SupplierInviteDto:
        """create_supplier_invite.

        :param body: Is either a CreateSupplierInvite type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CreateSupplierInvite or IO[bytes]
        :return: SupplierInviteDto
        :rtype: ~ignos.api.client.models.SupplierInviteDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SupplierInviteDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateSupplierInvite")
            else:
                _json = None

        _request = build_suppliers_create_supplier_invite_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("SupplierInviteDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_supplier_invite(  # pylint: disable=inconsistent-return-statements
        self, id: str, **kwargs: Any
    ) -> None:
        """delete_supplier_invite.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_suppliers_delete_supplier_invite_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_suppliers(self, **kwargs: Any) -> List[_models.ExternalSupplierDto]:
        """list_suppliers.

        :return: list of ExternalSupplierDto
        :rtype: list[~ignos.api.client.models.ExternalSupplierDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ExternalSupplierDto]] = kwargs.pop("cls", None)

        _request = build_suppliers_list_suppliers_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[ExternalSupplierDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_supplier(self, id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """delete_supplier.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_suppliers_delete_supplier_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def import_supplier(
        self, body: Optional[_models.ImportSupplier] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ExternalSupplierDto:
        """import_supplier.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ImportSupplier
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ExternalSupplierDto
        :rtype: ~ignos.api.client.models.ExternalSupplierDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def import_supplier(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ExternalSupplierDto:
        """import_supplier.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: ExternalSupplierDto
        :rtype: ~ignos.api.client.models.ExternalSupplierDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def import_supplier(
        self, body: Optional[Union[_models.ImportSupplier, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.ExternalSupplierDto:
        """import_supplier.

        :param body: Is either a ImportSupplier type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.ImportSupplier or IO[bytes]
        :return: ExternalSupplierDto
        :rtype: ~ignos.api.client.models.ExternalSupplierDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ExternalSupplierDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ImportSupplier")
            else:
                _json = None

        _request = build_suppliers_import_supplier_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ExternalSupplierDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_supplier_mapping(  # pylint: disable=inconsistent-return-statements
        self,
        body: Optional[_models.CreateSupplierMapping] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Creates a mapping between old supplier id and new supplier id.

        Creates a mapping between old supplier id and new supplier id.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateSupplierMapping
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_supplier_mapping(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Creates a mapping between old supplier id and new supplier id.

        Creates a mapping between old supplier id and new supplier id.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_supplier_mapping(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[_models.CreateSupplierMapping, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """Creates a mapping between old supplier id and new supplier id.

        Creates a mapping between old supplier id and new supplier id.

        :param body: Is either a CreateSupplierMapping type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CreateSupplierMapping or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateSupplierMapping")
            else:
                _json = None

        _request = build_suppliers_create_supplier_mapping_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def delete_supplier_mappings(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete all supplier mappings between old supplier ids and new supplier ids.

        Delete all supplier mappings between old supplier ids and new supplier ids.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_suppliers_delete_supplier_mappings_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class SustainabilityOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`sustainability` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def test(self, **kwargs: Any) -> str:
        """test.

        :return: str
        :rtype: str
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[str] = kwargs.pop("cls", None)

        _request = build_sustainability_test_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("str", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def get_consumption(
        self, body: Optional[_models.GetConsumption] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ConsumptionDto:
        """get_consumption.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.GetConsumption
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConsumptionDto
        :rtype: ~ignos.api.client.models.ConsumptionDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def get_consumption(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ConsumptionDto:
        """get_consumption.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: ConsumptionDto
        :rtype: ~ignos.api.client.models.ConsumptionDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def get_consumption(
        self, body: Optional[Union[_models.GetConsumption, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.ConsumptionDto:
        """get_consumption.

        :param body: Is either a GetConsumption type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.GetConsumption or IO[bytes]
        :return: ConsumptionDto
        :rtype: ~ignos.api.client.models.ConsumptionDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ConsumptionDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "GetConsumption")
            else:
                _json = None

        _request = build_sustainability_get_consumption_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("ConsumptionDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def get_power(
        self, body: Optional[_models.GetPower] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PowerDto:
        """get_power.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.GetPower
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PowerDto
        :rtype: ~ignos.api.client.models.PowerDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def get_power(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PowerDto:
        """get_power.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: PowerDto
        :rtype: ~ignos.api.client.models.PowerDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def get_power(
        self, body: Optional[Union[_models.GetPower, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.PowerDto:
        """get_power.

        :param body: Is either a GetPower type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.GetPower or IO[bytes]
        :return: PowerDto
        :rtype: ~ignos.api.client.models.PowerDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PowerDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "GetPower")
            else:
                _json = None

        _request = build_sustainability_get_power_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("PowerDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def get_customer_order_consumption(
        self,
        external_id: str,
        body: Optional[_models.CustomerOrderConsumptionRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """get_customer_order_consumption.

        :param external_id: Required.
        :type external_id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CustomerOrderConsumptionRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def get_customer_order_consumption(
        self,
        external_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """get_customer_order_consumption.

        :param external_id: Required.
        :type external_id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: JSON
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def get_customer_order_consumption(
        self,
        external_id: str,
        body: Optional[Union[_models.CustomerOrderConsumptionRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> JSON:
        """get_customer_order_consumption.

        :param external_id: Required.
        :type external_id: str
        :param body: Is either a CustomerOrderConsumptionRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.CustomerOrderConsumptionRequest or IO[bytes]
        :return: JSON
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CustomerOrderConsumptionRequest")
            else:
                _json = None

        _request = build_sustainability_get_customer_order_consumption_request(
            external_id=external_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_work_order_consumption(self, external_id: str, **kwargs: Any) -> JSON:
        """get_work_order_consumption.

        :param external_id: Required.
        :type external_id: str
        :return: JSON
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_sustainability_get_work_order_consumption_request(
            external_id=external_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_product_consumption(self, external_id: str, **kwargs: Any) -> JSON:
        """get_product_consumption.

        :param external_id: Required.
        :type external_id: str
        :return: JSON
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_sustainability_get_product_consumption_request(
            external_id=external_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("object", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_customer_order_line_ghg_report(
        self,
        body: Optional[_models.CreateCustomerOrderLineGhgReport] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DownloadDto:
        """create_customer_order_line_ghg_report.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateCustomerOrderLineGhgReport
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DownloadDto
        :rtype: ~ignos.api.client.models.DownloadDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_customer_order_line_ghg_report(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DownloadDto:
        """create_customer_order_line_ghg_report.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: DownloadDto
        :rtype: ~ignos.api.client.models.DownloadDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_customer_order_line_ghg_report(
        self, body: Optional[Union[_models.CreateCustomerOrderLineGhgReport, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.DownloadDto:
        """create_customer_order_line_ghg_report.

        :param body: Is either a CreateCustomerOrderLineGhgReport type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.CreateCustomerOrderLineGhgReport or IO[bytes]
        :return: DownloadDto
        :rtype: ~ignos.api.client.models.DownloadDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DownloadDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateCustomerOrderLineGhgReport")
            else:
                _json = None

        _request = build_sustainability_create_customer_order_line_ghg_report_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("DownloadDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class SystemHealthDashboardOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`system_health_dashboard` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_machine_data_health(self, *, asset_id: Optional[int] = None, **kwargs: Any) -> _models.DataHealthDto:
        """get_machine_data_health.

        :keyword asset_id: Default value is None.
        :paramtype asset_id: int
        :return: DataHealthDto
        :rtype: ~ignos.api.client.models.DataHealthDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DataHealthDto] = kwargs.pop("cls", None)

        _request = build_system_health_dashboard_get_machine_data_health_request(
            asset_id=asset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("DataHealthDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class TraceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`trace` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_trace(self, id: str, **kwargs: Any) -> _models.TraceDto:
        """get_trace.

        :param id: Required.
        :type id: str
        :return: TraceDto
        :rtype: ~ignos.api.client.models.TraceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TraceDto] = kwargs.pop("cls", None)

        _request = build_trace_get_trace_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("TraceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_trace(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[_models.UpdateTraceRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """update_trace.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateTraceRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_trace(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """update_trace.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_trace(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[Union[_models.UpdateTraceRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """update_trace.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateTraceRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.UpdateTraceRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateTraceRequest")
            else:
                _json = None

        _request = build_trace_update_trace_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def generate_trace(self, id: str, **kwargs: Any) -> _models.TraceDto:
        """generate_trace.

        :param id: Required.
        :type id: str
        :return: TraceDto
        :rtype: ~ignos.api.client.models.TraceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TraceDto] = kwargs.pop("cls", None)

        _request = build_trace_generate_trace_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("TraceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def add_sequence_to_trace_list(  # pylint: disable=inconsistent-return-statements
        self, id: str, **kwargs: Any
    ) -> None:
        """add_sequence_to_trace_list.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_trace_add_sequence_to_trace_list_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def set_trace_manual_completed(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[_models.UpdateTraceManualCompletionRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """set_trace_manual_completed.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateTraceManualCompletionRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def set_trace_manual_completed(  # pylint: disable=inconsistent-return-statements
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """set_trace_manual_completed.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def set_trace_manual_completed(  # pylint: disable=inconsistent-return-statements
        self,
        id: str,
        body: Optional[Union[_models.UpdateTraceManualCompletionRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """set_trace_manual_completed.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateTraceManualCompletionRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.UpdateTraceManualCompletionRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateTraceManualCompletionRequest")
            else:
                _json = None

        _request = build_trace_set_trace_manual_completed_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_customer_order_line_traces(
        self, *, customer_order: Optional[str] = None, customer_order_line: Optional[int] = None, **kwargs: Any
    ) -> List[_models.CustomerOrderLineTraceItemDto]:
        """list_customer_order_line_traces.

        :keyword customer_order: Default value is None.
        :paramtype customer_order: str
        :keyword customer_order_line: Default value is None.
        :paramtype customer_order_line: int
        :return: list of CustomerOrderLineTraceItemDto
        :rtype: list[~ignos.api.client.models.CustomerOrderLineTraceItemDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CustomerOrderLineTraceItemDto]] = kwargs.pop("cls", None)

        _request = build_trace_list_customer_order_line_traces_request(
            customer_order=customer_order,
            customer_order_line=customer_order_line,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[CustomerOrderLineTraceItemDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_customer_order_trace_status(
        self, id: str, *, line: Optional[int] = None, **kwargs: Any
    ) -> _models.CustomerOrderTraceStatusDto:
        """get_customer_order_trace_status.

        :param id: Required.
        :type id: str
        :keyword line: Default value is None.
        :paramtype line: int
        :return: CustomerOrderTraceStatusDto
        :rtype: ~ignos.api.client.models.CustomerOrderTraceStatusDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CustomerOrderTraceStatusDto] = kwargs.pop("cls", None)

        _request = build_trace_get_customer_order_trace_status_request(
            id=id,
            line=line,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("CustomerOrderTraceStatusDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_trace_workorders(
        self,
        *,
        page_size: int = 50,
        search: Optional[str] = None,
        company_id: Optional[str] = None,
        search_type: Optional[Union[str, _models.SearchTypeDto]] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any
    ) -> _models.TraceWorkOrderListDtoPagedResult:
        """List work orders for trace.

        List work orders for trace.

        :keyword page_size: Number of items per page. Default 50. Use -1 for dynamic page size. Default
         value is 50.
        :paramtype page_size: int
        :keyword search: Searches work order ID, drawing, partnumber or customer order using starts
         with. Default value is None.
        :paramtype search: str
        :keyword company_id: The company the work order belongs to. Default value is None.
        :paramtype company_id: str
        :keyword search_type: The matching strategy when searching on work order ID. The default is
         StartsWith. Known values are: "Contains", "StartsWith", "EndsWith", and "Equals". Default value
         is None.
        :paramtype search_type: str or ~ignos.api.client.models.SearchTypeDto
        :keyword continuation_token_parameter: Continuation token used for pagination. Default value is
         None.
        :paramtype continuation_token_parameter: str
        :return: TraceWorkOrderListDtoPagedResult
        :rtype: ~ignos.api.client.models.TraceWorkOrderListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TraceWorkOrderListDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_trace_list_trace_workorders_request(
            page_size=page_size,
            search=search,
            company_id=company_id,
            search_type=search_type,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("TraceWorkOrderListDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_list_trace_workorders(
        self,
        body: Optional[_models.ListTraceWorkordersRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.TraceWorkOrderListDtoPagedResult:
        """post_list_trace_workorders.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListTraceWorkordersRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TraceWorkOrderListDtoPagedResult
        :rtype: ~ignos.api.client.models.TraceWorkOrderListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_trace_workorders(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.TraceWorkOrderListDtoPagedResult:
        """post_list_trace_workorders.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: TraceWorkOrderListDtoPagedResult
        :rtype: ~ignos.api.client.models.TraceWorkOrderListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_trace_workorders(
        self, body: Optional[Union[_models.ListTraceWorkordersRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.TraceWorkOrderListDtoPagedResult:
        """post_list_trace_workorders.

        :param body: Is either a ListTraceWorkordersRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.ListTraceWorkordersRequest or IO[bytes]
        :return: TraceWorkOrderListDtoPagedResult
        :rtype: ~ignos.api.client.models.TraceWorkOrderListDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.TraceWorkOrderListDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListTraceWorkordersRequest")
            else:
                _json = None

        _request = build_trace_post_list_trace_workorders_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("TraceWorkOrderListDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class TrackingOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`tracking` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_tracking_history(self, tracking_id: str, **kwargs: Any) -> _models.TrackingHistoryDto:
        """list_tracking_history.

        :param tracking_id: Required.
        :type tracking_id: str
        :return: TrackingHistoryDto
        :rtype: ~ignos.api.client.models.TrackingHistoryDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TrackingHistoryDto] = kwargs.pop("cls", None)

        _request = build_tracking_list_tracking_history_request(
            tracking_id=tracking_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("TrackingHistoryDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_work_order_tracking_history(self, work_order_id: str, **kwargs: Any) -> _models.TrackingWorkOrderDto:
        """list_work_order_tracking_history.

        :param work_order_id: Required.
        :type work_order_id: str
        :return: TrackingWorkOrderDto
        :rtype: ~ignos.api.client.models.TrackingWorkOrderDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TrackingWorkOrderDto] = kwargs.pop("cls", None)

        _request = build_tracking_list_work_order_tracking_history_request(
            work_order_id=work_order_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("TrackingWorkOrderDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_tracking_events(  # pylint: disable=inconsistent-return-statements
        self,
        body: Optional[List[_models.TrackingUpdateDto]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """create_tracking_events.

        :param body: Default value is None.
        :type body: list[~ignos.api.client.models.TrackingUpdateDto]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_tracking_events(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """create_tracking_events.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_tracking_events(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[List[_models.TrackingUpdateDto], IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """create_tracking_events.

        :param body: Is either a [TrackingUpdateDto] type or a IO[bytes] type. Default value is None.
        :type body: list[~ignos.api.client.models.TrackingUpdateDto] or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "[TrackingUpdateDto]")
            else:
                _json = None

        _request = build_tracking_create_tracking_events_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def create_tracking_history(  # pylint: disable=inconsistent-return-statements
        self,
        body: Optional[List[_models.TrackingHistoryUpdateDto]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """create_tracking_history.

        :param body: Default value is None.
        :type body: list[~ignos.api.client.models.TrackingHistoryUpdateDto]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_tracking_history(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """create_tracking_history.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_tracking_history(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[List[_models.TrackingHistoryUpdateDto], IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """create_tracking_history.

        :param body: Is either a [TrackingHistoryUpdateDto] type or a IO[bytes] type. Default value is
         None.
        :type body: list[~ignos.api.client.models.TrackingHistoryUpdateDto] or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "[TrackingHistoryUpdateDto]")
            else:
                _json = None

        _request = build_tracking_create_tracking_history_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def delete_tracking_history(  # pylint: disable=inconsistent-return-statements
        self,
        body: Optional[List[_models.TrackingHistoryUpdateDto]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """delete_tracking_history.

        :param body: Default value is None.
        :type body: list[~ignos.api.client.models.TrackingHistoryUpdateDto]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def delete_tracking_history(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """delete_tracking_history.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def delete_tracking_history(  # pylint: disable=inconsistent-return-statements
        self, body: Optional[Union[List[_models.TrackingHistoryUpdateDto], IO[bytes]]] = None, **kwargs: Any
    ) -> None:
        """delete_tracking_history.

        :param body: Is either a [TrackingHistoryUpdateDto] type or a IO[bytes] type. Default value is
         None.
        :type body: list[~ignos.api.client.models.TrackingHistoryUpdateDto] or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "[TrackingHistoryUpdateDto]")
            else:
                _json = None

        _request = build_tracking_delete_tracking_history_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def create_label(  # pylint: disable=inconsistent-return-statements
        self, work_order_id: str, *, pallet_count: Optional[int] = None, **kwargs: Any
    ) -> None:
        """create_label.

        :param work_order_id: Required.
        :type work_order_id: str
        :keyword pallet_count: Default value is None.
        :paramtype pallet_count: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_tracking_create_label_request(
            work_order_id=work_order_id,
            pallet_count=pallet_count,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class UploadOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`upload` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def create_upload_info(self, **kwargs: Any) -> _models.UploadInfoDto:
        """create_upload_info.

        :return: UploadInfoDto
        :rtype: ~ignos.api.client.models.UploadInfoDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.UploadInfoDto] = kwargs.pop("cls", None)

        _request = build_upload_create_upload_info_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("UploadInfoDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class UsersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`users` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list_users(
        self,
        *,
        page_size: int = 50,
        filter: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any
    ) -> _models.UserDtoPagedResult:
        """list_users.

        :keyword page_size: Default value is 50.
        :paramtype page_size: int
        :keyword filter: Default value is None.
        :paramtype filter: str
        :keyword continuation_token_parameter: Default value is None.
        :paramtype continuation_token_parameter: str
        :return: UserDtoPagedResult
        :rtype: ~ignos.api.client.models.UserDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.UserDtoPagedResult] = kwargs.pop("cls", None)

        _request = build_users_list_users_request(
            page_size=page_size,
            filter=filter,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("UserDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def post_list_users(
        self, body: Optional[_models.ListUsersRequest] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.UserDtoPagedResult:
        """post_list_users.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.ListUsersRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: UserDtoPagedResult
        :rtype: ~ignos.api.client.models.UserDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def post_list_users(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.UserDtoPagedResult:
        """post_list_users.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: UserDtoPagedResult
        :rtype: ~ignos.api.client.models.UserDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def post_list_users(
        self, body: Optional[Union[_models.ListUsersRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.UserDtoPagedResult:
        """post_list_users.

        :param body: Is either a ListUsersRequest type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.ListUsersRequest or IO[bytes]
        :return: UserDtoPagedResult
        :rtype: ~ignos.api.client.models.UserDtoPagedResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.UserDtoPagedResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ListUsersRequest")
            else:
                _json = None

        _request = build_users_post_list_users_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("UserDtoPagedResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class WorkspacesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`workspaces` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_my_workspaces(self, **kwargs: Any) -> List[_models.WorkspaceListDto]:
        """get_my_workspaces.

        :return: list of WorkspaceListDto
        :rtype: list[~ignos.api.client.models.WorkspaceListDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkspaceListDto]] = kwargs.pop("cls", None)

        _request = build_workspaces_get_my_workspaces_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[WorkspaceListDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_workspace(
        self, body: Optional[_models.CreateWorkspace] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.WorkspaceDto:
        """create_workspace.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateWorkspace
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_workspace(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.WorkspaceDto:
        """create_workspace.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_workspace(
        self, body: Optional[Union[_models.CreateWorkspace, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.WorkspaceDto:
        """create_workspace.

        :param body: Is either a CreateWorkspace type or a IO[bytes] type. Default value is None.
        :type body: ~ignos.api.client.models.CreateWorkspace or IO[bytes]
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkspaceDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateWorkspace")
            else:
                _json = None

        _request = build_workspaces_create_workspace_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkspaceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_workspace_from_template(
        self,
        body: Optional[_models.CreateWorkspaceFromTemplate] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkspaceDto:
        """create_workspace_from_template.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateWorkspaceFromTemplate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_workspace_from_template(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.WorkspaceDto:
        """create_workspace_from_template.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_workspace_from_template(
        self, body: Optional[Union[_models.CreateWorkspaceFromTemplate, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.WorkspaceDto:
        """create_workspace_from_template.

        :param body: Is either a CreateWorkspaceFromTemplate type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.CreateWorkspaceFromTemplate or IO[bytes]
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkspaceDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateWorkspaceFromTemplate")
            else:
                _json = None

        _request = build_workspaces_create_workspace_from_template_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkspaceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_workspace(self, id: str, **kwargs: Any) -> _models.WorkspaceDto:
        """get_workspace.

        :param id: Required.
        :type id: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkspaceDto] = kwargs.pop("cls", None)

        _request = build_workspaces_get_workspace_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkspaceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_workspace(self, id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """delete_workspace.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workspaces_delete_workspace_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def update_workspace(
        self,
        id: str,
        body: Optional[_models.UpdateWorkspaceRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateWorkspaceRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_workspace(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_workspace(
        self, id: str, body: Optional[Union[_models.UpdateWorkspaceRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateWorkspaceRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.UpdateWorkspaceRequest or IO[bytes]
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkspaceDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateWorkspaceRequest")
            else:
                _json = None

        _request = build_workspaces_update_workspace_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkspaceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_workspace_widgets(
        self,
        id: str,
        body: Optional[_models.UpdateWorkspaceWidgetsRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace_widgets.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateWorkspaceWidgetsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_workspace_widgets(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace_widgets.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_workspace_widgets(
        self, id: str, body: Optional[Union[_models.UpdateWorkspaceWidgetsRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace_widgets.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateWorkspaceWidgetsRequest type or a IO[bytes] type. Default value
         is None.
        :type body: ~ignos.api.client.models.UpdateWorkspaceWidgetsRequest or IO[bytes]
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkspaceDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateWorkspaceWidgetsRequest")
            else:
                _json = None

        _request = build_workspaces_update_workspace_widgets_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkspaceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_workspace_widget_settings(
        self,
        id: str,
        widget_id: str,
        body: Optional[_models.UpdateWorkspaceWidgetSettingsRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace_widget_settings.

        :param id: Required.
        :type id: str
        :param widget_id: Required.
        :type widget_id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateWorkspaceWidgetSettingsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_workspace_widget_settings(
        self,
        id: str,
        widget_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace_widget_settings.

        :param id: Required.
        :type id: str
        :param widget_id: Required.
        :type widget_id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_workspace_widget_settings(
        self,
        id: str,
        widget_id: str,
        body: Optional[Union[_models.UpdateWorkspaceWidgetSettingsRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace_widget_settings.

        :param id: Required.
        :type id: str
        :param widget_id: Required.
        :type widget_id: str
        :param body: Is either a UpdateWorkspaceWidgetSettingsRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.UpdateWorkspaceWidgetSettingsRequest or IO[bytes]
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkspaceDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateWorkspaceWidgetSettingsRequest")
            else:
                _json = None

        _request = build_workspaces_update_workspace_widget_settings_request(
            id=id,
            widget_id=widget_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkspaceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_workspace_widget(self, id: str, widget_id: str, **kwargs: Any) -> _models.WorkspaceDto:
        """delete_workspace_widget.

        :param id: Required.
        :type id: str
        :param widget_id: Required.
        :type widget_id: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkspaceDto] = kwargs.pop("cls", None)

        _request = build_workspaces_delete_workspace_widget_request(
            id=id,
            widget_id=widget_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkspaceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class WorkspaceTemplatesAdminOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`workspace_templates_admin` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create_workspace_template(
        self,
        body: Optional[_models.CreateWorkspaceTemplate] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkspaceDto:
        """create_workspace_template.

        :param body: Default value is None.
        :type body: ~ignos.api.client.models.CreateWorkspaceTemplate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_workspace_template(
        self, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.WorkspaceDto:
        """create_workspace_template.

        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_workspace_template(
        self, body: Optional[Union[_models.CreateWorkspaceTemplate, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.WorkspaceDto:
        """create_workspace_template.

        :param body: Is either a CreateWorkspaceTemplate type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.CreateWorkspaceTemplate or IO[bytes]
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkspaceDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateWorkspaceTemplate")
            else:
                _json = None

        _request = build_workspace_templates_admin_create_workspace_template_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkspaceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_workspace_template(self, id: str, **kwargs: Any) -> _models.WorkspaceDto:
        """get_workspace_template.

        :param id: Required.
        :type id: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkspaceDto] = kwargs.pop("cls", None)

        _request = build_workspace_templates_admin_get_workspace_template_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkspaceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_workspace_template(  # pylint: disable=inconsistent-return-statements
        self, id: str, **kwargs: Any
    ) -> None:
        """delete_workspace_template.

        :param id: Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workspace_templates_admin_delete_workspace_template_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def update_workspace_template(
        self,
        id: str,
        body: Optional[_models.UpdateWorkspaceRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace_template.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateWorkspaceRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_workspace_template(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace_template.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_workspace_template(
        self, id: str, body: Optional[Union[_models.UpdateWorkspaceRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace_template.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateWorkspaceRequest type or a IO[bytes] type. Default value is
         None.
        :type body: ~ignos.api.client.models.UpdateWorkspaceRequest or IO[bytes]
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkspaceDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateWorkspaceRequest")
            else:
                _json = None

        _request = build_workspace_templates_admin_update_workspace_template_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkspaceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_workspace_template_widgets(
        self,
        id: str,
        body: Optional[_models.UpdateWorkspaceWidgetsRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace_template_widgets.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateWorkspaceWidgetsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_workspace_template_widgets(
        self, id: str, body: Optional[IO[bytes]] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace_template_widgets.

        :param id: Required.
        :type id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_workspace_template_widgets(
        self, id: str, body: Optional[Union[_models.UpdateWorkspaceWidgetsRequest, IO[bytes]]] = None, **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace_template_widgets.

        :param id: Required.
        :type id: str
        :param body: Is either a UpdateWorkspaceWidgetsRequest type or a IO[bytes] type. Default value
         is None.
        :type body: ~ignos.api.client.models.UpdateWorkspaceWidgetsRequest or IO[bytes]
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkspaceDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateWorkspaceWidgetsRequest")
            else:
                _json = None

        _request = build_workspace_templates_admin_update_workspace_template_widgets_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkspaceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_workspace_template_widget_settings(  # pylint: disable=name-too-long
        self,
        id: str,
        widget_id: str,
        body: Optional[_models.UpdateWorkspaceWidgetSettingsRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace_template_widget_settings.

        :param id: Required.
        :type id: str
        :param widget_id: Required.
        :type widget_id: str
        :param body: Default value is None.
        :type body: ~ignos.api.client.models.UpdateWorkspaceWidgetSettingsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_workspace_template_widget_settings(  # pylint: disable=name-too-long
        self,
        id: str,
        widget_id: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace_template_widget_settings.

        :param id: Required.
        :type id: str
        :param widget_id: Required.
        :type widget_id: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/*+json', 'application/json', 'text/json'. Default value is
         "application/json".
        :paramtype content_type: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_workspace_template_widget_settings(  # pylint: disable=name-too-long
        self,
        id: str,
        widget_id: str,
        body: Optional[Union[_models.UpdateWorkspaceWidgetSettingsRequest, IO[bytes]]] = None,
        **kwargs: Any
    ) -> _models.WorkspaceDto:
        """update_workspace_template_widget_settings.

        :param id: Required.
        :type id: str
        :param widget_id: Required.
        :type widget_id: str
        :param body: Is either a UpdateWorkspaceWidgetSettingsRequest type or a IO[bytes] type. Default
         value is None.
        :type body: ~ignos.api.client.models.UpdateWorkspaceWidgetSettingsRequest or IO[bytes]
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkspaceDto] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateWorkspaceWidgetSettingsRequest")
            else:
                _json = None

        _request = build_workspace_templates_admin_update_workspace_template_widget_settings_request(
            id=id,
            widget_id=widget_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkspaceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_workspace_template_widget(self, id: str, widget_id: str, **kwargs: Any) -> _models.WorkspaceDto:
        """delete_workspace_template_widget.

        :param id: Required.
        :type id: str
        :param widget_id: Required.
        :type widget_id: str
        :return: WorkspaceDto
        :rtype: ~ignos.api.client.models.WorkspaceDto
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkspaceDto] = kwargs.pop("cls", None)

        _request = build_workspace_templates_admin_delete_workspace_template_widget_request(
            id=id,
            widget_id=widget_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("WorkspaceDto", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class WorkspaceTemplatesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~ignos.api.client.aio.IgnosPortal`'s
        :attr:`workspace_templates` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_workspace_templates(self, **kwargs: Any) -> List[_models.WorkspaceListDto]:
        """get_workspace_templates.

        :return: list of WorkspaceListDto
        :rtype: list[~ignos.api.client.models.WorkspaceListDto]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.WorkspaceListDto]] = kwargs.pop("cls", None)

        _request = build_workspace_templates_get_workspace_templates_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("[WorkspaceListDto]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
