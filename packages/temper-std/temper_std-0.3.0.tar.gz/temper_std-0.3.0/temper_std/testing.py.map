{ "version": 3, "file": "py/std/temper_std/testing.py", "sources": [ "std/testing.temper.md" ], "sourcesContent": [ "# Temper test framework\n\n## Test instance\n\nWe currently convert assert and check macro calls into method calls on a `Test`\ninstance.\n\n    export class Test {\n\nRecommended default Temper assert is soft, meaning that it records failures for\nreporting but doesn't immediately end test execution on a false value. This lets\nyou check multiple conditions more easily.\n\n      @connected(\u0022Test::assert\u0022)\n      public assert(success: Boolean, message: fn (): String): Void {\n        if (!success) {\n          _passing = false;\n          _messages.add(message());\n        }\n      }\n\nTypical hard asserts that end the test on false condition also are available.\n\n      @connected(\u0022Test::assertHard\u0022)\n      public assertHard(\n        success: Boolean,\n        message: fn (): String,\n      ): Void | Bubble {\n        assert(success, message);\n        if (!success) {\n          // Attempt to distinguish assert fails from others.\n          // Sadly, they can still orelse an assert failure, so this isn't\n          // flawless.\n          _failedOnAssert = true;\n          bail();\n        }\n      }\n\nHarden and end current test on any pending failure if not previously hardened.\nBackends typically insert calls to this if needed, but you can also call it\nmanually at any desired point in your test.\n\n      public softFailToHard(): Void | Bubble {\n        if (hasUnhandledFail) {\n          _failedOnAssert = true;\n          bail();\n        }\n      }\n\nProvide a bailing `Bubble` method here that enables backends to customize\nmessage delivery on failure.\n\n      @connected(\u0022Test::bail\u0022)\n      bail(): Bubble {\n        bubble()\n      }\n\nYou can check the current passing state of the test at any time. A test is\ncurrently passing if all soft checks and hard asserts have been succesful.\n\nTODO Does this need to be function call syntax for macro purposes?\n\n      @connected(\u0022Test::passing\u0022)\n      public get passing(): Boolean { _passing }\n\nMessages access is presented as a function because it likely allocates. Also,\nmessages might be automatically constructed in some cases, so it's possibly\nunwise to depend on their exact formatting.\n\n      @connected(\u0022Test::messages\u0022)\n      public messages(): List\u003cString\u003e { _messages.toList() }\n\n### Backend helper methods\n\nAvoid using backend helper methods in user code. Their behavior might be\nunreliable on some backends and/or have high risk of changing in future releases\nof Temper.\n\n      @connected(\u0022Test::failedOnAssert\u0022)\n      public get failedOnAssert(): Boolean { _failedOnAssert }\n\nAdditional helper methods to simplify backend code generation in some contexts.\n\n      public get hasUnhandledFail(): Boolean { !(_failedOnAssert || _passing) }\n\nSimple helper to get multiple messages combined for now. We probably want to do\nfancier things in the future, but this can simplify backends for now.\n\n      public messagesCombined(): String | Null {\n        if (_messages.isEmpty) {\n          // Unexpected, but most backends can do something with null.\n          null\n        } else {\n          _messages.join(\u0022, \u0022) { (it);; it }\n        }\n      }\n\n      private var _failedOnAssert: Boolean = false;\n      private var _passing: Boolean = true;\n      private _messages: ListBuilder\u003cString\u003e = new ListBuilder\u003cString\u003e();\n    }\n\n## Interpreter testing support\n\nNOTICE: Don't directly anything in this section. It just exists for the\nimplementation of testing within the interpreter.\n\n    export let TestCase = Pair\u003cTestName, TestFun\u003e;\n    export let TestFailureMessage = String;\n    export let TestFun = fn (Test): Void | Bubble;\n    export let TestName = String;\n    export let TestResult = Pair\u003cTestName, List\u003cTestFailureMessage\u003e\u003e;\n\n    @connected(\u0022::processTestCases\u0022)\n    export let processTestCases(testCases: List\u003cTestCase\u003e): List\u003cTestResult\u003e {\n      testCases.map { (testCase): TestResult;;\n        let { key, value as fun } = testCase;\n        let test = new Test();\n        // Actually call the test.\n        let hadBubble = do {\n          fun(test);\n          false\n        } orelse true;\n        // Now get the messages.\n        let messages = test.messages();\n        let failures: List\u003cTestFailureMessage\u003e = if (test.passing) {\n          []\n        } else if (hadBubble \u0026\u0026 !test.failedOnAssert) {\n          // Despite having 1+ failure messages, we seem to have failed on some\n          // Bubble separate from asserts, so add that on.\n          let allMessages = messages.toListBuilder();\n          allMessages.add(\u0022Bubble\u0022);\n          allMessages.toList()\n        } else {\n          messages\n        };\n        // Package up with test name.\n        new Pair(key, failures)\n      }\n    }\n\n    @connected(\u0022::reportTestResults\u0022)\n    export let reportTestResults(testResults: List\u003cTestResult\u003e): Void {\n      // TODO Write as junit xml (or tap if we switch to that).\n      for (var i = 0; i \u003c testResults.length; i += 1) {\n        let testResult = testResults[i];\n        let failureMessages = testResult.value;\n        if (failureMessages.isEmpty) {\n          console.log(\u0022\u0024{testResult.key}: Passed\u0022);\n        } else {\n          let message = failureMessages.join(\u0022, \u0022) { (it);; it };\n          console.log(\u0022\u0024{testResult.key}: Failed \u0024{message}\u0022);\n        }\n      }\n    }\n\n    @connected(\u0022::runTestCases\u0022)\n    export let runTestCases(testCases: List\u003cTestCase\u003e): Void {\n      reportTestResults(processTestCases(testCases));\n    }\n\nTODO Is this a better idea than inlining each case? We'd need to generate\n`fun testFunction() { runTest(originalFunctionAsCallback) }` or some such.\n\n    export let runTest(testFun: TestFun): Void | Bubble {\n      let test = new Test();\n      testFun(test);\n      test.softFailToHard();\n    }\n" ], "names": [ "Any", "MutableSequence", "Callable", "Sequence", "Union", "Optional", "LoggingConsole", "Pair", "Pair#1283", "Label", "list_builder_add", "list_builder_add#1254", "list_join", "list_join#1250", "list_map", "list_map#1284", "list_get", "list_get#1263", "str_cat", "str_cat#1273", "bool", "str", "Exception", "int", "RuntimeError", "tuple", "tuple#1282", "list", "list#1279", "len", "len#1262", "console#88", "Test", "passing", "failedOnAssert", "hasUnhandledFail", "_failedOnAssert", "_passing", "_messages", "this", "success", "message", "t#186", "return", "t#291", "t#292", "fn", "it", "constructor", "t#285", "TestName", "TestFun", "TestCase", "TestFailureMessage", "TestResult", "processTestCases", "testCases", "testCase", "t#269", "t#271", "t#168", "key", "fun", "test", "hadBubble", "messages", "failures", "allMessages", "reportTestResults", "testResults", "t#256", "t#257", "t#261", "t#154", "i", "s__1285#1286", "testResult", "failureMessages", "runTestCases", "runTest", "testFun" ], "mappings": "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" }