# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: frequenz/api/common/metrics.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    List,
    Optional,
)

import betterproto


@dataclass(eq=False, repr=False)
class Bounds(betterproto.Message):
    """
    A set of lower and upper bounds for any metric. The units of the bounds are
    always the same as the related metric.
    """

    lower: float = betterproto.float_field(1)
    """The lower bound."""

    upper: float = betterproto.float_field(2)
    """The upper bound."""


@dataclass(eq=False, repr=False)
class Metric(betterproto.Message):
    """A metric's value, with optional limits."""

    value: float = betterproto.float_field(1)
    """The current value of the metric."""

    rated_bounds: "Bounds" = betterproto.message_field(2)
    """
    The manufacturer's rated bounds of the metric. This may differ from
    `system_bounds` as it does not take into account the current state of the
    overall system.
    """

    component_bounds: "Bounds" = betterproto.message_field(3)
    """
    The current bounds of the metric, as imposed by the component this metric
    originates from.
    """

    system_exclusion_bounds: "Bounds" = betterproto.message_field(4)
    """
    These bounds indicate the range of values that are disallowed for the
    metric. If these bounds for a metric are [`lower`, `upper`], then this
    metric's `value` needs to comply with the constraints `value <= lower` OR
    `upper <= value`. It is important to note that these bounds work together
    with `system_inclusion_bounds`. E.g., for the system to accept a charge
    command, clients need to request power values within the bounds
    `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`. This
    means that clients can only request charge commands with values that are
    within the `system_inclusion_bounds`, but not within
    `system_exclusion_bounds`. Similarly, for the system to accept a discharge
    command, clients need to request power values within the bounds
    `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`. The
    following diagram illustrates the relationship between the bounds. ```
    inclusion.lower                              inclusion.upper
    <-------|============|------------------|============|--------->
    exclusion.lower    exclusion.upper ``` ---- values here are disallowed and
    wil be rejected ==== vales here are allowed and will be accepted
    """

    system_inclusion_bounds: "Bounds" = betterproto.message_field(5)
    """
    These bounds indicate the range of values that are allowed for the metric.
    If these bounds for a metric are [`lower`, `upper`], then this metric's
    `value` needs to comply with the constraint `lower <= value <= upper` It is
    important to note that these bounds work together with
    `system_exclusion_bounds`. E.g., for the system to accept a charge command,
    clients need to request power values within the bounds
    `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`. This
    means that clients can only request charge commands with values that are
    within the `system_inclusion_bounds`, but not within
    `system_exclusion_bounds`. Similarly, for the system to accept a discharge
    command, clients need to request power values within the bounds
    `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`. The
    following diagram illustrates the relationship between the bounds. ```
    inclusion.lower                              inclusion.upper
    <-------|============|------------------|============|--------->
    exclusion.lower    exclusion.upper ``` ---- values here are disallowed and
    wil be rejected ==== vales here are allowed and will be accepted
    """


@dataclass(eq=False, repr=False)
class MetricAggregation(betterproto.Message):
    """
    Metrics depicted as a collection of statistical summaries. Useful when a
    component has to report multiple values for the same metric. E.g., a
    battery is a collection of several blocks, and each block has a temperature
    sensor. The battery can report a summary of the values provided by all
    these sensors, like, min, max, avg, etc., and if possible, the entire array
    of temperature values.
    """

    avg: float = betterproto.float_field(1)
    """The average value of the metric."""

    min: Optional[float] = betterproto.float_field(2, optional=True, group="_min")
    """The minimum value of the metric."""

    max: Optional[float] = betterproto.float_field(3, optional=True, group="_max")
    """The maximum value of the metric."""

    raw_values: List[float] = betterproto.float_field(12)
    """The array of all the metric values."""

    rated_bounds: "Bounds" = betterproto.message_field(13)
    """
    The manufacturer's rated bounds of the metric. This may differ from
    `system_bounds` as it does not take into account the current state of the
    overall system.
    """

    component_bounds: "Bounds" = betterproto.message_field(14)
    """
    The current bounds of the metric, as imposed by the component this metric
    originates from.
    """

    system_exclusion_bounds: "Bounds" = betterproto.message_field(4)
    """
    These bounds indicate the range of values that are disallowed for the
    metric. If these bounds for a metric are [`lower`, `upper`], then this
    metric's `value` needs to comply with the constraints `value <= lower` OR
    `upper <= value`. It is important to note that these bounds work together
    with `system_inclusion_bounds`. E.g., for the system to accept a charge
    command, clients need to request power values within the bounds
    `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`. This
    means that clients can only request charge commands with power values that
    are within the `system_inclusion_bounds`, but not within
    `system_exclusion_bounds`. Similarly, for the system to accept a discharge
    command, clients need to request power values within the bounds
    `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`. The
    following diagram illustrates the relationship between the bounds. ```
    inclusion.lower                              inclusion.upper
    <-------|============|------------------|============|--------->
    exclusion.lower    exclusion.upper ``` ---- values here are disallowed and
    wil be rejected ==== vales here are allowed and will be accepted
    """

    system_inclusion_bounds: "Bounds" = betterproto.message_field(5)
    """
    These bounds indicate the range of values that are allowed for the metric.
    If these bounds for a metric are [`lower`, `upper`], then this metric's
    `value` needs to comply with the constraint `lower <= value <= upper` It is
    important to note that these bounds work together with
    `system_exclusion_bounds`. E.g., for the system to accept a charge command,
    clients need to request power values within the bounds
    `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`. This
    means that clients can only request charge commands with power values that
    are within the `system_inclusion_bounds`, but not within
    `system_exclusion_bounds`. Similarly, for the system to accept a discharge
    command, clients need to request power values within the bounds
    `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`. The
    following diagram illustrates the relationship between the bounds. ```
    inclusion.lower                              inclusion.upper
    <-------|============|------------------|============|--------->
    exclusion.lower    exclusion.upper ``` ---- values here are disallowed and
    wil be rejected ==== vales here are allowed and will be accepted
    """
