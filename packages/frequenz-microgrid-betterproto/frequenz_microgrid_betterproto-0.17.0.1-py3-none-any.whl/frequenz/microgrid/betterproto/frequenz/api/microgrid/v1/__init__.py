# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: frequenz/api/microgrid/v1/microgrid.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...common.v1 import (
    metrics as __common_v1_metrics__,
    microgrid as __common_v1_microgrid__,
)
from ...common.v1.microgrid import (
    components as __common_v1_microgrid_components__,
    sensors as __common_v1_microgrid_sensors__,
)


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class ComponentBoundsValidityDuration(betterproto.Enum):
    """The duration for which a given list of bounds will stay in effect."""

    COMPONENT_BOUNDS_VALIDITY_DURATION_UNSPECIFIED = 0
    COMPONENT_BOUNDS_VALIDITY_DURATION_5_SECONDS = 1
    COMPONENT_BOUNDS_VALIDITY_DURATION_1_MINUTE = 2
    COMPONENT_BOUNDS_VALIDITY_DURATION_5_MINUTES = 3
    COMPONENT_BOUNDS_VALIDITY_DURATION_15_MINUTES = 4


@dataclass(eq=False, repr=False)
class GetMicrogridMetadataResponse(betterproto.Message):
    """Metadata that describes a microgrid."""

    microgrid: "__common_v1_microgrid__.Microgrid" = betterproto.message_field(1)
    """The location of the microgrid, in geographical co-ordinates."""


@dataclass(eq=False, repr=False)
class ListComponentsRequest(betterproto.Message):
    """
    Request parameters for the RPC `ListComponents`. Contains filtering
    parameters for listing components.
    """

    component_ids: List[int] = betterproto.uint64_field(1)
    """Return components that have the specified IDs only."""

    categories: List["__common_v1_microgrid_components__.ComponentCategory"] = (
        betterproto.enum_field(2)
    )
    """Return components that have the specified categories only."""


@dataclass(eq=False, repr=False)
class ListComponentsResponse(betterproto.Message):
    """
    A message containing a list of components. Used as the return type in the
    RPC `ListComponents`.
    """

    components: List["__common_v1_microgrid_components__.Component"] = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class ListSensorRequest(betterproto.Message):
    """
    Request parameters for the RPC `ListSensors`. Contains filtering parameters
    for listing sensors.
    """

    sensor_ids: List[int] = betterproto.uint64_field(1)
    """Return sensors that have the specified IDs only."""

    categories: List["__common_v1_microgrid_sensors__.SensorCategory"] = (
        betterproto.enum_field(2)
    )
    """Return sensors that have the specified categories only."""


@dataclass(eq=False, repr=False)
class ListSensorsResponse(betterproto.Message):
    """
    Response message for the RPC `ListSensors`. A message containing a list of
    sensors.
    """

    sensors: List["__common_v1_microgrid_sensors__.Sensor"] = betterproto.message_field(
        1
    )


@dataclass(eq=False, repr=False)
class ListConnectionsRequest(betterproto.Message):
    """
    Request parameters for the RPC `ListConnections`. Contains filtering
    parameters for listing connections.
    """

    starts: List[int] = betterproto.uint64_field(1)
    """
    Only return connections that start from the specified component ID(s): if
    empty, connections with any `start` will be returned
    """

    ends: List[int] = betterproto.uint64_field(2)
    """
    Only return connections that end at the specified component ID(s): if
    empty, connections with any `end` will be returned
    """


@dataclass(eq=False, repr=False)
class ListConnectionsResponse(betterproto.Message):
    """
    Response message for the RPC `ListConnections`. Contains a list of
    connections.
    """

    connections: List["__common_v1_microgrid_components__.ComponentConnection"] = (
        betterproto.message_field(1)
    )
    """The list of connections."""


@dataclass(eq=False, repr=False)
class ReceiveComponentDataStreamRequest(betterproto.Message):
    """Request parameters for the RPC `ReceiveComponentDataStream`."""

    component_id: int = betterproto.uint64_field(1)
    """The component ID to subscribe to."""

    filter: "ReceiveComponentDataStreamRequestComponentDataStreamFilter" = (
        betterproto.message_field(2)
    )
    """
    The filter to apply to the stream. This field is optional. If this is not
    provided, then the stream will return all metrics for the given component.
    If this is provided, then the stream will return only the metrics specified
    in the filter.
    """


@dataclass(eq=False, repr=False)
class ReceiveComponentDataStreamRequestComponentDataStreamFilter(betterproto.Message):
    """A message for specifying a filter to apply to the stream."""

    metrics: List["__common_v1_metrics__.Metric"] = betterproto.enum_field(1)
    """
    List of metrics to return. Only the specified metrics will be returned. !!!
    note     At least one metric must be specified. If no metric is specified,
    then the stream will return an error. !!! note     Components may not
    support all metrics. If a component does not     support a given metric,
    then the returned data stream will not     contain that metric.
    """


@dataclass(eq=False, repr=False)
class ReceiveComponentDataStreamResponse(betterproto.Message):
    """
    A data sample from a component in the microgrid. Components belonging to
    all categories and types can be represented using this message.
    """

    data: "__common_v1_microgrid_components__.ComponentData" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class ReceiveSensorDataStreamRequest(betterproto.Message):
    """Request parameters for the RPC `ReceiveSensorDataStream`."""

    sensor_id: int = betterproto.uint64_field(1)
    """The sensor ID to subscribe to."""

    filter: "ReceiveSensorDataStreamRequestSensorDataStreamFilter" = (
        betterproto.message_field(2)
    )
    """
    The filter to apply to the stream. This field is optional. If this is not
    provided, then the stream will return all metrics for the given component.
    If this is provided, then the stream will return only the metrics specified
    in the filter.
    """


@dataclass(eq=False, repr=False)
class ReceiveSensorDataStreamRequestSensorDataStreamFilter(betterproto.Message):
    """A message for specifying a filter to apply to the stream."""

    metrics: List["__common_v1_metrics__.Metric"] = betterproto.enum_field(1)
    """
    List of metrics to return. Only the specified metrics will be returned. !!!
    note     At least one metric must be specified. If no metric is specified,
    then the stream will return an error. !!! note     Sensors may not support
    all metrics. If a sensor does not support a     given metric, then the
    returned data stream will not contain that     metric.
    """


@dataclass(eq=False, repr=False)
class ReceiveSensorDataStreamResponse(betterproto.Message):
    """A data sample from a sensor in the microgrid."""

    data: "__common_v1_microgrid_sensors__.SensorData" = betterproto.message_field(1)
    """The sensor data."""


@dataclass(eq=False, repr=False)
class AddComponentBoundsRequest(betterproto.Message):
    """Request parameters for the RPC `AddComponentBounds`."""

    component_id: int = betterproto.uint64_field(1)
    """The ID of the target component."""

    target_metric: "__common_v1_metrics__.Metric" = betterproto.enum_field(2)
    """The target metric whose bounds have to be set."""

    bounds: List["__common_v1_metrics__.Bounds"] = betterproto.message_field(3)
    """
    A list of bounds for the target metric. While incorporating these bounds,
    the API will ensure that overlapping pairs of bounds are merged into a
    single pair of bounds, and non-overlapping ones are kept separated.
    """

    validity_duration: "ComponentBoundsValidityDuration" = betterproto.enum_field(4)
    """
    The duration for which the given bounds will stay in effect. If this field
    is not provided, then the bounds will be removed after a default duration
    of 5 seconds.
    """


@dataclass(eq=False, repr=False)
class AddComponentBoundsResponse(betterproto.Message):
    """Response message for the RPC `AddComponentBounds`."""

    ts: datetime = betterproto.message_field(1)
    """The timestamp until which the given bounds will stay in effect."""


@dataclass(eq=False, repr=False)
class SetComponentPowerActiveRequest(betterproto.Message):
    """Request parameters for the RPC `SetComponentPowerActive`."""

    component_id: int = betterproto.uint64_field(1)
    """The ID of the component to set the output active power of."""

    power: float = betterproto.float_field(2)
    """
    The output active power level, in watts. -ve values are for discharging,
    and +ve values are for charging.
    """

    request_lifetime: Optional[int] = betterproto.uint64_field(
        3, optional=True, group="_request_lifetime"
    )
    """
    The duration, in seconds, until which the request will stay in effect. This
    duration has to be between 10 seconds and 15 minutes (including both
    limits), otherwise the request will be rejected. If not provided, it
    defaults to 60s.
    """


@dataclass(eq=False, repr=False)
class SetComponentPowerActiveResponse(betterproto.Message):
    """Response message for the RPC `SetComponentPowerActive`."""

    valid_until: datetime = betterproto.message_field(1)
    """
    The timestamp until which the given power command will stay in effect.
    After this timestamp, the component power will be set to 0, if the API
    receives no further power commands. By default, this timestamp will be set
    to the current time plus 60 seconds.
    """


@dataclass(eq=False, repr=False)
class SetComponentPowerReactiveRequest(betterproto.Message):
    """Request parameters for the RPC `SetComponentPowerReactive`."""

    component_id: int = betterproto.uint64_field(1)
    """The ID of the component to set the output reactive power of."""

    power: float = betterproto.float_field(2)
    """
    The output reactive power level, in VAr. The standard of polarity is as per
    the IEEE 1459-2010 standard definitions: - positive reactive is inductive
    (current is lagging the voltage) - negative reactive is capacitive (current
    is leading the voltage)
    """

    request_lifetime: Optional[int] = betterproto.uint64_field(
        3, optional=True, group="_request_lifetime"
    )
    """
    The duration, in seconds, until which the request will stay in effect. This
    duration has to be between 10 seconds and 15 minutes (including both
    limits), otherwise the request will be rejected. If not provided, it
    defaults to 60s.
    """


@dataclass(eq=False, repr=False)
class SetComponentPowerReactiveResponse(betterproto.Message):
    """Response message for the RPC `SetComponentPowerReactive`."""

    valid_until: datetime = betterproto.message_field(1)
    """
    The timestamp until which the given power command will stay in effect.
    After this timestamp, the component power will be set to 0, if the API
    receives no further power commands. By default, this timestamp will be set
    to the current time plus 60 seconds.
    """


@dataclass(eq=False, repr=False)
class StartComponentRequest(betterproto.Message):
    """Request parameters for the RPC `StartComponent`."""

    component_id: int = betterproto.uint64_field(1)
    """The component ID to start."""


@dataclass(eq=False, repr=False)
class PutComponentInStandbyRequest(betterproto.Message):
    """Request parameters for the RPC `PutComponentInStandby`."""

    component_id: int = betterproto.uint64_field(1)
    """The component ID to set to standby."""


@dataclass(eq=False, repr=False)
class StopComponentRequest(betterproto.Message):
    """Request parameters for the RPC `StopComponent`."""

    component_id: int = betterproto.uint64_field(1)
    """The component ID to stop."""


@dataclass(eq=False, repr=False)
class AckComponentErrorRequest(betterproto.Message):
    """Request parameters for the RPC `AckComponentError`."""

    component_id: int = betterproto.uint64_field(1)
    """The component ID to acknowledge the error for."""


class MicrogridStub(betterproto.ServiceStub):
    async def get_microgrid_metadata(
        self,
        betterproto_lib_google_protobuf_empty: "betterproto_lib_google_protobuf.Empty",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetMicrogridMetadataResponse":
        return await self._unary_unary(
            "/frequenz.api.microgrid.v1.Microgrid/GetMicrogridMetadata",
            betterproto_lib_google_protobuf_empty,
            GetMicrogridMetadataResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_components(
        self,
        list_components_request: "ListComponentsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListComponentsResponse":
        return await self._unary_unary(
            "/frequenz.api.microgrid.v1.Microgrid/ListComponents",
            list_components_request,
            ListComponentsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_sensors(
        self,
        list_sensor_request: "ListSensorRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListSensorsResponse":
        return await self._unary_unary(
            "/frequenz.api.microgrid.v1.Microgrid/ListSensors",
            list_sensor_request,
            ListSensorsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_connections(
        self,
        list_connections_request: "ListConnectionsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListConnectionsResponse":
        return await self._unary_unary(
            "/frequenz.api.microgrid.v1.Microgrid/ListConnections",
            list_connections_request,
            ListConnectionsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def receive_component_data_stream(
        self,
        receive_component_data_stream_request: "ReceiveComponentDataStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ReceiveComponentDataStreamResponse"]:
        async for response in self._unary_stream(
            "/frequenz.api.microgrid.v1.Microgrid/ReceiveComponentDataStream",
            receive_component_data_stream_request,
            ReceiveComponentDataStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def receive_sensor_data_stream(
        self,
        receive_sensor_data_stream_request: "ReceiveSensorDataStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ReceiveSensorDataStreamResponse"]:
        async for response in self._unary_stream(
            "/frequenz.api.microgrid.v1.Microgrid/ReceiveSensorDataStream",
            receive_sensor_data_stream_request,
            ReceiveSensorDataStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def add_component_bounds(
        self,
        add_component_bounds_request: "AddComponentBoundsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AddComponentBoundsResponse":
        return await self._unary_unary(
            "/frequenz.api.microgrid.v1.Microgrid/AddComponentBounds",
            add_component_bounds_request,
            AddComponentBoundsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_component_power_active(
        self,
        set_component_power_active_request: "SetComponentPowerActiveRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetComponentPowerActiveResponse":
        return await self._unary_unary(
            "/frequenz.api.microgrid.v1.Microgrid/SetComponentPowerActive",
            set_component_power_active_request,
            SetComponentPowerActiveResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_component_power_reactive(
        self,
        set_component_power_reactive_request: "SetComponentPowerReactiveRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SetComponentPowerReactiveResponse":
        return await self._unary_unary(
            "/frequenz.api.microgrid.v1.Microgrid/SetComponentPowerReactive",
            set_component_power_reactive_request,
            SetComponentPowerReactiveResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def start_component(
        self,
        start_component_request: "StartComponentRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        return await self._unary_unary(
            "/frequenz.api.microgrid.v1.Microgrid/StartComponent",
            start_component_request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def put_component_in_standby(
        self,
        put_component_in_standby_request: "PutComponentInStandbyRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        return await self._unary_unary(
            "/frequenz.api.microgrid.v1.Microgrid/PutComponentInStandby",
            put_component_in_standby_request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def stop_component(
        self,
        stop_component_request: "StopComponentRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        return await self._unary_unary(
            "/frequenz.api.microgrid.v1.Microgrid/StopComponent",
            stop_component_request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def ack_component_error(
        self,
        ack_component_error_request: "AckComponentErrorRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        return await self._unary_unary(
            "/frequenz.api.microgrid.v1.Microgrid/AckComponentError",
            ack_component_error_request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MicrogridBase(ServiceBase):

    async def get_microgrid_metadata(
        self,
        betterproto_lib_google_protobuf_empty: "betterproto_lib_google_protobuf.Empty",
    ) -> "GetMicrogridMetadataResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_components(
        self, list_components_request: "ListComponentsRequest"
    ) -> "ListComponentsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_sensors(
        self, list_sensor_request: "ListSensorRequest"
    ) -> "ListSensorsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_connections(
        self, list_connections_request: "ListConnectionsRequest"
    ) -> "ListConnectionsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def receive_component_data_stream(
        self, receive_component_data_stream_request: "ReceiveComponentDataStreamRequest"
    ) -> AsyncIterator["ReceiveComponentDataStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ReceiveComponentDataStreamResponse()

    async def receive_sensor_data_stream(
        self, receive_sensor_data_stream_request: "ReceiveSensorDataStreamRequest"
    ) -> AsyncIterator["ReceiveSensorDataStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ReceiveSensorDataStreamResponse()

    async def add_component_bounds(
        self, add_component_bounds_request: "AddComponentBoundsRequest"
    ) -> "AddComponentBoundsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_component_power_active(
        self, set_component_power_active_request: "SetComponentPowerActiveRequest"
    ) -> "SetComponentPowerActiveResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_component_power_reactive(
        self, set_component_power_reactive_request: "SetComponentPowerReactiveRequest"
    ) -> "SetComponentPowerReactiveResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def start_component(
        self, start_component_request: "StartComponentRequest"
    ) -> "betterproto_lib_google_protobuf.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def put_component_in_standby(
        self, put_component_in_standby_request: "PutComponentInStandbyRequest"
    ) -> "betterproto_lib_google_protobuf.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stop_component(
        self, stop_component_request: "StopComponentRequest"
    ) -> "betterproto_lib_google_protobuf.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def ack_component_error(
        self, ack_component_error_request: "AckComponentErrorRequest"
    ) -> "betterproto_lib_google_protobuf.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_microgrid_metadata(
        self,
        stream: "grpclib.server.Stream[betterproto_lib_google_protobuf.Empty, GetMicrogridMetadataResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_microgrid_metadata(request)
        await stream.send_message(response)

    async def __rpc_list_components(
        self,
        stream: "grpclib.server.Stream[ListComponentsRequest, ListComponentsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_components(request)
        await stream.send_message(response)

    async def __rpc_list_sensors(
        self, stream: "grpclib.server.Stream[ListSensorRequest, ListSensorsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_sensors(request)
        await stream.send_message(response)

    async def __rpc_list_connections(
        self,
        stream: "grpclib.server.Stream[ListConnectionsRequest, ListConnectionsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_connections(request)
        await stream.send_message(response)

    async def __rpc_receive_component_data_stream(
        self,
        stream: "grpclib.server.Stream[ReceiveComponentDataStreamRequest, ReceiveComponentDataStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.receive_component_data_stream,
            stream,
            request,
        )

    async def __rpc_receive_sensor_data_stream(
        self,
        stream: "grpclib.server.Stream[ReceiveSensorDataStreamRequest, ReceiveSensorDataStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.receive_sensor_data_stream,
            stream,
            request,
        )

    async def __rpc_add_component_bounds(
        self,
        stream: "grpclib.server.Stream[AddComponentBoundsRequest, AddComponentBoundsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.add_component_bounds(request)
        await stream.send_message(response)

    async def __rpc_set_component_power_active(
        self,
        stream: "grpclib.server.Stream[SetComponentPowerActiveRequest, SetComponentPowerActiveResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_component_power_active(request)
        await stream.send_message(response)

    async def __rpc_set_component_power_reactive(
        self,
        stream: "grpclib.server.Stream[SetComponentPowerReactiveRequest, SetComponentPowerReactiveResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set_component_power_reactive(request)
        await stream.send_message(response)

    async def __rpc_start_component(
        self,
        stream: "grpclib.server.Stream[StartComponentRequest, betterproto_lib_google_protobuf.Empty]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.start_component(request)
        await stream.send_message(response)

    async def __rpc_put_component_in_standby(
        self,
        stream: "grpclib.server.Stream[PutComponentInStandbyRequest, betterproto_lib_google_protobuf.Empty]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.put_component_in_standby(request)
        await stream.send_message(response)

    async def __rpc_stop_component(
        self,
        stream: "grpclib.server.Stream[StopComponentRequest, betterproto_lib_google_protobuf.Empty]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.stop_component(request)
        await stream.send_message(response)

    async def __rpc_ack_component_error(
        self,
        stream: "grpclib.server.Stream[AckComponentErrorRequest, betterproto_lib_google_protobuf.Empty]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.ack_component_error(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/frequenz.api.microgrid.v1.Microgrid/GetMicrogridMetadata": grpclib.const.Handler(
                self.__rpc_get_microgrid_metadata,
                grpclib.const.Cardinality.UNARY_UNARY,
                betterproto_lib_google_protobuf.Empty,
                GetMicrogridMetadataResponse,
            ),
            "/frequenz.api.microgrid.v1.Microgrid/ListComponents": grpclib.const.Handler(
                self.__rpc_list_components,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListComponentsRequest,
                ListComponentsResponse,
            ),
            "/frequenz.api.microgrid.v1.Microgrid/ListSensors": grpclib.const.Handler(
                self.__rpc_list_sensors,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListSensorRequest,
                ListSensorsResponse,
            ),
            "/frequenz.api.microgrid.v1.Microgrid/ListConnections": grpclib.const.Handler(
                self.__rpc_list_connections,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListConnectionsRequest,
                ListConnectionsResponse,
            ),
            "/frequenz.api.microgrid.v1.Microgrid/ReceiveComponentDataStream": grpclib.const.Handler(
                self.__rpc_receive_component_data_stream,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReceiveComponentDataStreamRequest,
                ReceiveComponentDataStreamResponse,
            ),
            "/frequenz.api.microgrid.v1.Microgrid/ReceiveSensorDataStream": grpclib.const.Handler(
                self.__rpc_receive_sensor_data_stream,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReceiveSensorDataStreamRequest,
                ReceiveSensorDataStreamResponse,
            ),
            "/frequenz.api.microgrid.v1.Microgrid/AddComponentBounds": grpclib.const.Handler(
                self.__rpc_add_component_bounds,
                grpclib.const.Cardinality.UNARY_UNARY,
                AddComponentBoundsRequest,
                AddComponentBoundsResponse,
            ),
            "/frequenz.api.microgrid.v1.Microgrid/SetComponentPowerActive": grpclib.const.Handler(
                self.__rpc_set_component_power_active,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetComponentPowerActiveRequest,
                SetComponentPowerActiveResponse,
            ),
            "/frequenz.api.microgrid.v1.Microgrid/SetComponentPowerReactive": grpclib.const.Handler(
                self.__rpc_set_component_power_reactive,
                grpclib.const.Cardinality.UNARY_UNARY,
                SetComponentPowerReactiveRequest,
                SetComponentPowerReactiveResponse,
            ),
            "/frequenz.api.microgrid.v1.Microgrid/StartComponent": grpclib.const.Handler(
                self.__rpc_start_component,
                grpclib.const.Cardinality.UNARY_UNARY,
                StartComponentRequest,
                betterproto_lib_google_protobuf.Empty,
            ),
            "/frequenz.api.microgrid.v1.Microgrid/PutComponentInStandby": grpclib.const.Handler(
                self.__rpc_put_component_in_standby,
                grpclib.const.Cardinality.UNARY_UNARY,
                PutComponentInStandbyRequest,
                betterproto_lib_google_protobuf.Empty,
            ),
            "/frequenz.api.microgrid.v1.Microgrid/StopComponent": grpclib.const.Handler(
                self.__rpc_stop_component,
                grpclib.const.Cardinality.UNARY_UNARY,
                StopComponentRequest,
                betterproto_lib_google_protobuf.Empty,
            ),
            "/frequenz.api.microgrid.v1.Microgrid/AckComponentError": grpclib.const.Handler(
                self.__rpc_ack_component_error,
                grpclib.const.Cardinality.UNARY_UNARY,
                AckComponentErrorRequest,
                betterproto_lib_google_protobuf.Empty,
            ),
        }
