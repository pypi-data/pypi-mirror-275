# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/05.storage.buffer.buffer.ipynb.

# %% ../../../nbs/05.storage.buffer.buffer.ipynb 3
from __future__ import annotations
import abc
import weakref
from dataclasses import dataclass
from typing import ClassVar, Generic, Optional, Tuple, get_args
import numpy as np
import pandas as pd  # type: ignore

# %% auto 0
__all__ = ['Buffer']

# %% ../../../nbs/05.storage.buffer.buffer.ipynb 4
from ..pool.pool import Pool
from ...data.core import ItemT, PoolQuery

# %% ../../../nbs/05.storage.buffer.buffer.ipynb 5
@dataclass(kw_only=True)
class Buffer(abc.ABC, Generic[ItemT]):
    """
    The abstract class for providing an buffer interface for data processing.

    Buffer is the internal dynamic memory object for pooling the experience tuples.
    It provides the following interface for inheriting classes (MongoBuffer, DaskBuffer, etc.):

    Methods:
        - load()
        - save()
        - store()
        - sample()


    Attributes:
        - pool: the pool object for storing the data
        - batch_size: the batch size for sampling
        - _type_T: the type of the data item (e.g. Record, Episode, etc.)
    """

    pool: Optional[Pool]
    batch_size: int
    _type_T: ClassVar[str]

    def __init_subclass__(cls):
        """Get the concrete type of the data item (e.g. Record, Episode, etc.)"""
        cls._type_T = get_args(cls.__orig_bases__[0])[0].__name__  # type: ignore
        # print(
        #     f"Pool.__init_subclass__(): {cls._type_T} in {cls.__name__} from {cls.__base__.__name__}"
        # )

    def __post_init__(self):
        """User weakref finalizer to make sure close is called when the object is destroyed"""
        self._finalizer = weakref.finalize(self, self.close)

    @abc.abstractmethod
    def load(self):
        """
        load buffer from pool
        """
        pass

    @abc.abstractmethod
    def close(self):
        """
        close the pool, for destructor
        """
        pass

    # @abc.abstractmethod
    def store(self, episode: ItemT):
        """
        Deposit an item (record/episode) into the pool
        """
        self.pool.store(episode)

    # @abc.abstractmethod
    def find(self, query: PoolQuery):
        """
        find an itme by id or name.
        """
        return self.pool.find(query)

    @abc.abstractmethod
    def sample(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        """
        sample data pool to get (state, action, reward, nstate) as a tuple of 4 DataFrames
        """
