{"version":3,"file":"lib_index_js.4bee53a274cec352147f.js","mappings":";;;;;;;;;;;;;;;;AAAmD;AACtB;AAC7B,oBAAoB,UAAU;AAC9B,wCAAwC,+CAAQ;AAChD,kCAAkC,+CAAQ;AAC1C,IAAI,gDAAS;AACb;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,WAAW,0DAAmB,CAAC,4CAAK,IAAI,4EAA4E;AACpH;AACA;AACA;AACA;AACA;AACA,iFAAiF,YAAY,yHAAyH;AACtN;AACA;AACA;AACA;AACA,yBAAyB,8BAA8B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;ACtDmB;AAC3C;AACA;AACA;AACA,6BAA6B,qDAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAM;AACd;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjDsE;AACD;AACpB;AACG;AACC;AACK;AACP;AACC;AACA;AACN;AACK;AACnD;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAe,EAAE,oEAAe,EAAE,8DAAS;AAC1D,cAAc,4DAAuB;AACrC;AACA;AACA,4BAA4B,uDAAiB;AAC7C;AACA;AACA;AACA;AACA,4BAA4B,+DAAa,GAAG,WAAW;AACvD;AACA;AACA;AACA;AACA,8BAA8B,6DAAoB;AAClD;AACA;AACA,+BAA+B,+DAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,0CAA0C;AACzG;AACA;AACA;AACA;AACA;AACA,+DAA+D,sBAAsB;AACrF;AACA;AACA;AACA;AACA,SAAS;AACT,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAuB,EAAE,oEAAgB,EAAE,8DAAS;AACnE;AACA;AACA;AACA;AACA;AACA,sBAAsB,6BAA6B,IAAI,6BAA6B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,0CAA0C,6DAAe,GAAG,SAAS;AACrE;AACA;AACA;AACA;AACA,wCAAwC,4DAAsB;AAC9D;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,2DAAS;AAC5E;AACA,gDAAgD,kEAAU;AAC1D;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA,yEAAyE,WAAW,GAAG;AACvF;AACA;AACA,wEAAwE,wBAAwB;AAChG;AACA;AACA,qFAAqF,iBAAiB,0DAA0D,YAAY,aAAa,QAAQ,sCAAsC,QAAQ,8CAA8C,QAAQ,gDAAgD,aAAa;AAClW;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,2DAAS;AACxE;AACA,4CAA4C,kEAAU;AACtD;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;ACzPoB;AAC3C;AACA;AACA;AACO;AACP;AACA,oCAAoC,qDAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtDyC;AACf;AACO;AACa;AACZ,CAAC;AACa;AACI;AACpD,QAAQ,OAAO,EAAE,4CAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mCAAmC,mDAAM;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAA6B,CAAC,0DAAmB,CAAC,4CAAK;AAC/D,YAAY,0DAAmB;AAC/B;AACA;AACA,oCAAoC;AACpC;AACA,8BAA8B,0DAAmB,CAAC,yDAAe,IAAI,SAAS,cAAc,cAAc;AAC1G;AACA;AACA;AACA,4CAA4C;AAC5C,2DAA2D;AAC3D,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAe,CAAC,0DAAmB,CAAC,4CAAK,IAAI,yBAAyB,0DAAmB,UAAU,2BAA2B,mBAAmB,oBAAoB;AACrL;AACA;AACA;AACA,4CAA4C;AAC5C,2DAA2D;AAC3D,6CAA6C;AAC7C,gBAAgB,uDAAe,CAAC,0DAAmB,CAAC,4CAAK,IAAI,+CAA+C,0DAAmB,UAAU,2BAA2B,mBAAmB,kBAAkB;AACzM;AACA;AACA;AACA,0CAA0C;AAC1C,2DAA2D;AAC3D,6CAA6C;AAC7C,gBAAgB,uDAAe,CAAC,0DAAmB,CAAC,iDAAQ,IAAI,mBAAmB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,kBAAkB;AAClB,kBAAkB;AAClB,oBAAoB;AACpB,mBAAmB;AACnB,oBAAoB;AACpB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;;;;;;;;;;;;;;AC3J3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjE0C;AACnC,oCAAoC,oDAAK;AAChD;AACA;AACA;AACO,6BAA6B,oDAAK","sources":["webpack://@amphi/pipeline-log-console/./lib/DataView.js","webpack://@amphi/pipeline-log-console/./lib/handler.js","webpack://@amphi/pipeline-log-console/./lib/index.js","webpack://@amphi/pipeline-log-console/./lib/kernelconnector.js","webpack://@amphi/pipeline-log-console/./lib/logconsole.js","webpack://@amphi/pipeline-log-console/./lib/manager.js","webpack://@amphi/pipeline-log-console/./lib/tokens.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { Table } from 'antd';\nconst DataView = ({ htmlData }) => {\n    const [dataSource, setDataSource] = useState([]);\n    const [columns, setColumns] = useState([]);\n    useEffect(() => {\n        console.log(\"DATA %o\", htmlData);\n        const { data, headers } = htmlToJson(htmlData);\n        setDataSource(data);\n        setColumns(headers.map((header) => ({\n            title: header,\n            dataIndex: header,\n            key: header\n        })));\n    }, [htmlData]);\n    return React.createElement(Table, { dataSource: dataSource, columns: columns, pagination: false, size: \"small\" });\n};\nfunction htmlToJson(htmlString) {\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(htmlString, 'text/html');\n    // Extract headers from both th inside thead\n    let headers = Array.from(doc.querySelectorAll('table thead th')).map(th => { var _a, _b; return (_b = (_a = th.textContent) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : \"\"; });\n    const rows = doc.querySelectorAll('table tbody tr');\n    const data = Array.from(rows, (row, rowIndex) => {\n        // Gather all cells, including th for indexing\n        const cells = row.querySelectorAll('th, td');\n        const rowObj = { index: rowIndex.toString() }; // Add the row index\n        // Decide how to map cells to headers based on their count\n        if (cells.length === headers.length) {\n            // Headers align directly with cells\n            cells.forEach((cell, idx) => {\n                var _a, _b;\n                rowObj[headers[idx]] = (_b = (_a = cell.textContent) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : \"\";\n            });\n        }\n        else if (cells.length === headers.length + 1) {\n            // There is an extra th for indexing; prepend an empty header name for it\n            ['', ...headers].forEach((header, idx) => {\n                var _a, _b;\n                rowObj[header] = (_b = (_a = cells[idx].textContent) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : \"\";\n            });\n        }\n        else {\n            // Fallback to use only td elements if counts are mismatched\n            const tds = row.querySelectorAll('td');\n            headers.forEach((header, idx) => {\n                var _a, _b, _c;\n                rowObj[header] = (_c = (_b = (_a = tds[idx]) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : \"\";\n            });\n        }\n        return rowObj;\n    });\n    return { data, headers };\n}\nexport default DataView;\n","import { Signal } from '@lumino/signaling';\nclass AbstractHandler {\n    constructor(connector) {\n        this._isDisposed = false;\n        this._disposed = new Signal(this);\n        this._rendermime = null;\n        this._connector = connector;\n    }\n    get disposed() {\n        return this._disposed;\n    }\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    get rendermime() {\n        return this._rendermime;\n    }\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._disposed.emit();\n        Signal.clearData(this);\n    }\n}\n/**\n * An object that handles code inspection.\n */\nexport class PipelineConsoleHandler extends AbstractHandler {\n    constructor(options) {\n        var _a;\n        super(options.connector);\n        this._id = options.id;\n        this._rendermime = (_a = options.rendermime) !== null && _a !== void 0 ? _a : null;\n        this._ready = this._connector.ready;\n        this._connector.kernelRestarted.connect((sender, kernelReady) => {\n            const title = {\n                contextName: '<b>Restarting kernel...</b> '\n            };\n            this._ready = this._connector.ready;\n        });\n    }\n    get id() {\n        return this._id;\n    }\n    get ready() {\n        return this._ready;\n    }\n}\n","import { ICommandPalette, WidgetTracker } from '@jupyterlab/apputils';\nimport { ILabShell, ILayoutRestorer } from '@jupyterlab/application';\nimport { Sanitizer } from '@jupyterlab/apputils';\nimport { renderText } from '@jupyterlab/rendermime';\nimport { listIcon } from '@jupyterlab/ui-components';\nimport { IPipelineTracker } from '@amphi/pipeline-editor';\nimport { PipelineConsoleHandler } from './handler';\nimport { KernelConnector } from './kernelconnector';\nimport { PipelineConsolePanel } from './logconsole';\nimport { LogConsoleManager } from './manager';\nimport { IPipelineConsoleManager } from './tokens';\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.open = 'pipeline-console:open';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * A service providing variable introspection.\n */\nconst logsconsole = {\n    id: '@amphi/pipeline-log-console',\n    requires: [ICommandPalette, ILayoutRestorer, ILabShell],\n    provides: IPipelineConsoleManager,\n    autoStart: true,\n    activate: (app, palette, restorer, labShell) => {\n        const manager = new LogConsoleManager();\n        const category = 'Pipeline Console';\n        const command = CommandIDs.open;\n        const label = 'Pipeline Console';\n        const namespace = 'pipeline-console';\n        const tracker = new WidgetTracker({ namespace });\n        /**\n         * Create and track a new inspector.\n         */\n        function newPanel() {\n            const panel = new PipelineConsolePanel();\n            panel.id = 'amphi-logConsole';\n            panel.title.label = 'Pipeline Console';\n            panel.title.icon = listIcon;\n            panel.title.closable = true;\n            panel.disposed.connect(() => {\n                if (manager.panel === panel) {\n                    manager.panel = null;\n                }\n            });\n            //Track the inspector panel\n            tracker.add(panel);\n            return panel;\n        }\n        // Enable state restoration\n        restorer.restore(tracker, {\n            command,\n            args: () => ({}),\n            name: () => 'amphi-logConsole'\n        });\n        // Add command to palette\n        app.commands.addCommand(command, {\n            label,\n            execute: () => {\n                const metadataPanelId = 'amphi-metadataPanel'; // Using the provided log console panel ID\n                let metadataPanel = null;\n                // Iterate over each widget in the 'main' area to find the log console\n                for (const widget of app.shell.widgets('main')) {\n                    if (widget.id === metadataPanelId) {\n                        metadataPanel = widget;\n                        break;\n                    }\n                }\n                if (!manager.panel || manager.panel.isDisposed) {\n                    manager.panel = newPanel();\n                }\n                // Check if the metadata panel is found and is attached\n                if (metadataPanel && metadataPanel.isAttached) {\n                    // If log console panel is open, add the preview panel as a tab next to it\n                    if (!manager.panel.isAttached) {\n                        app.shell.add(manager.panel, 'main', { ref: metadataPanel.id, mode: 'tab-after' });\n                    }\n                }\n                else {\n                    // If log console panel is not open, open the preview panel in split-bottom mode\n                    if (!manager.panel.isAttached) {\n                        app.shell.add(manager.panel, 'main', { mode: 'split-bottom' });\n                    }\n                }\n                app.shell.activateById(manager.panel.id);\n            }\n        });\n        palette.addItem({ command, category });\n        app.commands.addCommand('pipeline-console:clear', {\n            execute: () => {\n                manager.panel.clearLogs();\n            },\n            label: 'Clear Console'\n        });\n        app.commands.addCommand('pipeline-console:settings', {\n            execute: () => {\n            },\n            label: 'Console Settings'\n        });\n        app.contextMenu.addItem({\n            command: 'pipeline-console:clear',\n            selector: '.amphi-Console',\n            rank: 1\n        });\n        console.log('JupyterLab extension @amphi/pipeline-log-console is activated!');\n        return manager;\n    }\n};\n/**\n * An extension that registers consoles for variable inspection.\n */\nconst pipelines = {\n    id: '@amphi/pipeline-log-console:pipelines',\n    requires: [IPipelineConsoleManager, IPipelineTracker, ILabShell],\n    autoStart: true,\n    activate: (app, manager, pipelines, labShell) => {\n        const handlers = {};\n        function formatLogDate(date) {\n            const dateObj = new Date(date);\n            return `${dateObj.toLocaleDateString()}\\n${dateObj.toLocaleTimeString()}`;\n        }\n        /**\n         * Subscribes to the creation of new consoles. If a new pipeline is created, build a new handler for the consoles.\n         * Adds a promise for a instanced handler to the 'handlers' collection.\n         */\n        pipelines.widgetAdded.connect((sender, pipelinePanel) => {\n            if (manager.hasHandler(pipelinePanel.context.sessionContext.path)) {\n                handlers[pipelinePanel.id] = new Promise((resolve, reject) => {\n                    resolve(manager.getHandler(pipelinePanel.context.sessionContext.path));\n                });\n            }\n            else {\n                handlers[pipelinePanel.id] = new Promise((resolve, reject) => {\n                    const session = pipelinePanel.context.sessionContext;\n                    // Create connector and init w script if it exists for kernel type.\n                    const connector = new KernelConnector({ session });\n                    const options = {\n                        connector: connector,\n                        id: session.path //Using the sessions path as an identifier for now.\n                    };\n                    const handler = new PipelineConsoleHandler(options);\n                    manager.addHandler(handler);\n                    pipelinePanel.disposed.connect(() => {\n                        delete handlers[pipelinePanel.id];\n                        handler.dispose();\n                    });\n                    handler.ready.then(() => {\n                        resolve(handler);\n                        connector.ready.then(async () => {\n                            session.session.kernel.anyMessage.connect((sender, args) => {\n                                if (manager.panel) {\n                                    if (args.direction === 'recv') {\n                                        // Filter and process kernel messages here\n                                        // For example, args.msg.header.msg_type might be 'stream' for log messages\n                                        // console.log(\"MESSAGE %o\", args.msg);\n                                        if (args.msg.header.msg_type === 'execute_result' || args.msg.header.msg_type === 'display_data') {\n                                            // Assert the message type to IExecuteResultMsg or IDisplayDataMsg to access 'data'\n                                            const content = args.msg.content;\n                                            if (content.data['text/html']) {\n                                                manager.panel.onNewLog(formatLogDate(args.msg.header.date), \"data\", content.data['text/html']);\n                                            }\n                                        }\n                                        else if (args.msg.header.msg_type === 'stream') {\n                                            const streamMsg = args.msg;\n                                            if (streamMsg.content.text && streamMsg.content.text !== '\\n') {\n                                                // Wrap the text in a <pre> tag to preserve formatting\n                                                const streamText = document.createElement('div');\n                                                // manager.panel.onNewLog(formatLogDate(args.msg.header.date), \"info\", formattedText);\n                                                // Use the sanitizer to safely render the traceback\n                                                const options = {\n                                                    host: streamText,\n                                                    source: streamMsg.content.text,\n                                                    sanitizer: new Sanitizer(), // Use the default sanitizer\n                                                };\n                                                renderText(options).then(() => {\n                                                    // Once the traceback is sanitized and rendered, append it to the errorContainer\n                                                    // Convert the entire structure to HTML string if necessary\n                                                    const streamHTML = streamText.outerHTML;\n                                                    manager.panel.onNewLog(formatLogDate(args.msg.header.date), \"info\", streamHTML);\n                                                });\n                                            }\n                                        }\n                                        else if (args.msg.header.msg_type === 'error') {\n                                            // Handle error messages\n                                            const errorMsg = args.msg; // If using TypeScript\n                                            const traceback = errorMsg.content.traceback.join('\\n');\n                                            const errorId = `traceback-${Date.now()}`; // Unique ID for the traceback container\n                                            // Create a container for the error message and the link\n                                            const errorContainer = document.createElement('div');\n                                            const errorMessageText = `${errorMsg.content.evalue}`;\n                                            // Ensure the link has a unique ID that matches the pattern for event delegation\n                                            // Can do better here, ... TODO\n                                            errorContainer.innerHTML = `<pre><span>${errorMessageText}</span><br><a href=\"#\" style=\"text-decoration: underline; color: grey;\" id=\"link-${errorId}\" onClick=\"document.getElementById('${errorId}').style.display = document.getElementById('${errorId}').style.display === 'none' ? 'block' : 'none'; return false;\">Show Traceback</a></pre>`;\n                                            // Create a container for the traceback, initially hidden\n                                            const tracebackContainer = document.createElement('pre');\n                                            tracebackContainer.id = errorId;\n                                            tracebackContainer.style.display = 'none';\n                                            errorContainer.appendChild(tracebackContainer);\n                                            // Use the sanitizer to safely render the traceback\n                                            const options = {\n                                                host: tracebackContainer,\n                                                source: traceback,\n                                                sanitizer: new Sanitizer(), // Use the default sanitizer\n                                            };\n                                            renderText(options).then(() => {\n                                                // Once the traceback is sanitized and rendered, append it to the errorContainer\n                                                // Convert the entire structure to HTML string if necessary\n                                                const errorHTML = errorContainer.outerHTML;\n                                                manager.panel.onNewLog(formatLogDate(errorMsg.header.date), \"error\", errorHTML);\n                                            });\n                                        }\n                                    }\n                                }\n                            });\n                        });\n                    });\n                });\n            }\n            setSource(labShell);\n        });\n        const setSource = (sender, args) => {\n            var _a;\n            const widget = (_a = args === null || args === void 0 ? void 0 : args.newValue) !== null && _a !== void 0 ? _a : sender.currentWidget;\n            if (!widget || !pipelines.has(widget)) {\n                return;\n            }\n            const future = handlers[widget.id];\n            future.then((source) => {\n                if (source) {\n                    manager.source = source;\n                    // manager.source.performInspection();\n                }\n            });\n        };\n        /**\n         * If focus window changes, checks whether new focus widget is a console.\n         * In that case, retrieves the handler associated to the console after it has been\n         * initialized and updates the manager with it.\n         */\n        setSource(labShell);\n        labShell.currentChanged.connect(setSource);\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [\n    logsconsole,\n    pipelines\n];\nexport default plugins;\n","import { Signal } from '@lumino/signaling';\n/**\n * Connector class that handles execute request to a kernel\n */\nexport class KernelConnector {\n    constructor(options) {\n        this._kernelRestarted = new Signal(this);\n        this._session = options.session;\n        this._session.statusChanged.connect((sender, newStatus) => {\n            switch (newStatus) {\n                case 'restarting':\n                    this._kernelRestarted.emit(this._session.ready);\n                case 'autorestarting':\n                    this._kernelRestarted.emit(this._session.ready);\n                    break;\n                default:\n                    break;\n            }\n        });\n    }\n    get kernelRestarted() {\n        return this._kernelRestarted;\n    }\n    get kernelLanguage() {\n        var _a;\n        if (!((_a = this._session.session) === null || _a === void 0 ? void 0 : _a.kernel)) {\n            return Promise.resolve('');\n        }\n        return this._session.session.kernel.info.then(infoReply => {\n            return infoReply.language_info.name;\n        });\n    }\n    get kernelName() {\n        return this._session.kernelDisplayName;\n    }\n    /**\n     *  A Promise that is fulfilled when the session associated w/ the connector is ready.\n     */\n    get ready() {\n        return this._session.ready;\n    }\n    /**\n     *  A signal emitted for iopub messages of the kernel associated with the kernel.\n     */\n    get iopubMessage() {\n        return this._session.iopubMessage;\n    }\n    execute(content) {\n        var _a;\n        if (!((_a = this._session.session) === null || _a === void 0 ? void 0 : _a.kernel)) {\n            throw new Error('No session available.');\n        }\n        return this._session.session.kernel.requestExecute(content);\n    }\n}\n","import { Widget } from '@lumino/widgets';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport ReactDOMServer from 'react-dom/server';\nimport DataView from './DataView'; // Assume DataView is your React component\nimport { Alert, Typography, Space } from 'antd';\nimport { LoadingOutlined } from '@ant-design/icons';\nconst { Text } = Typography;\nconst TITLE_CLASS = 'amphi-Console-title';\nconst PANEL_CLASS = 'amphi-Console';\nconst TABLE_CLASS = 'amphi-Console-table';\nconst TABLE_BODY_CLASS = 'amphi-Console-content';\nconst TABLE_ROW_CLASS = 'amphi-Console-table-row';\nconst TABLE_DATE_CLASS = 'amphi-Console-date';\n/**\n * A panel that renders the pipeline logs\n */\nexport class PipelineConsolePanel extends Widget {\n    constructor() {\n        super();\n        this._source = null;\n        this.addClass(PANEL_CLASS);\n        this._title = Private.createTitle();\n        this._title.className = TITLE_CLASS;\n        this._console = Private.createConsole();\n        this._console.className = TABLE_CLASS;\n        this.node.appendChild(this._title);\n        this.node.appendChild(this._console);\n    }\n    get source() {\n        return this._source;\n    }\n    set source(source) {\n        if (this._source === source) {\n            return;\n        }\n        //Remove old subscriptions\n        if (this._source) {\n            this._source.disposed.disconnect(this.onSourceDisposed, this);\n        }\n        this._source = source;\n        //Subscribe to new object\n        if (this._source) {\n            this._source.disposed.connect(this.onSourceDisposed, this);\n        }\n    }\n    /**\n     * Dispose resources\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.source = null;\n        super.dispose();\n    }\n    onNewLog(date, level, content) {\n        if (!this.isAttached) {\n            return;\n        }\n        // Ensure the table footer exists\n        if (!this._console.tFoot) {\n            this._console.createTFoot();\n            this._console.tFoot.className = TABLE_BODY_CLASS;\n        }\n        // Insert a new row at the beginning of the table footer\n        let row = this._console.tFoot.insertRow(0); // Changed from -1 to 0\n        row.className = `${TABLE_ROW_CLASS}`;\n        // Add cells to the new row\n        let cell = row.insertCell(0);\n        let container;\n        cell.innerHTML = `\n    <span>\n      ${ReactDOMServer.renderToString(React.createElement(Space, null,\n            React.createElement(Text, null, date)))}\n    </span>\n  `;\n        cell.style.padding = \"5px\"; // Remove padding from the cell\n        cell.className = TABLE_DATE_CLASS;\n        const spinIndicator = React.createElement(LoadingOutlined, { style: { fontSize: 24 }, spin: true });\n        switch (level) {\n            case \"info\":\n                cell = row.insertCell(1);\n                cell.style.padding = \"5px\"; // Remove padding from the cell\n                container = document.createElement('div'); // Create a container for the React component\n                cell.appendChild(container); // Append the container to the cell\n                // Determine the alert type based on content\n                let alertType = /SUCCESS/i.test(content)\n                    ? \"success\"\n                    : /ERROR|WARNING/i.test(content)\n                        ? \"warning\"\n                        : \"info\";\n                ReactDOM.render(React.createElement(Alert, { showIcon: true, message: React.createElement(\"div\", { dangerouslySetInnerHTML: { __html: content } }), type: alertType }), container);\n                break;\n            case \"error\":\n                cell = row.insertCell(1);\n                cell.style.padding = \"5px\"; // Remove padding from the cell\n                container = document.createElement('div'); // Create a container for the React component\n                cell.appendChild(container); // Append the container to the cell\n                ReactDOM.render(React.createElement(Alert, { message: \"Error\", showIcon: true, description: React.createElement(\"div\", { dangerouslySetInnerHTML: { __html: content } }), type: \"error\" }), container);\n                break;\n            case \"data\":\n                cell = row.insertCell(1);\n                cell.style.padding = \"5\"; // Remove padding from the cell\n                container = document.createElement('div'); // Create a container for the React component\n                cell.appendChild(container); // Append the container to the cell\n                ReactDOM.render(React.createElement(DataView, { htmlData: content }), container);\n                break;\n            default:\n                // Handle other cases or do nothing\n                break;\n        }\n        // Scroll to the top\n        this._console.parentElement.scrollTop = 0; // Changed to scroll to the top\n    }\n    clearLogs() {\n        // Check if table footer exists and remove all its rows\n        if (this._console.tFoot) {\n            while (this._console.tFoot.rows.length > 0) {\n                this._console.tFoot.deleteRow(0);\n            }\n        }\n    }\n    /**\n     * Handle source disposed signals.\n     */\n    onSourceDisposed(sender, args) {\n        this.source = null;\n    }\n}\nvar Private;\n(function (Private) {\n    const entityMap = new Map(Object.entries({\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#39;',\n        '/': '&#x2F;'\n    }));\n    function escapeHtml(source) {\n        return String(source).replace(/[&<>\"'/]/g, (s) => entityMap.get(s));\n    }\n    Private.escapeHtml = escapeHtml;\n    function createConsole() {\n        const table = document.createElement('table');\n        return table;\n    }\n    Private.createConsole = createConsole;\n    function createTitle(header = '') {\n        const title = document.createElement('p');\n        title.innerHTML = header;\n        return title;\n    }\n    Private.createTitle = createTitle;\n})(Private || (Private = {}));\n","/**\n * A class that manages variable inspector widget instances and offers persistent\n * `IMetadataPanel` instance that other plugins can communicate with.\n */\nexport class LogConsoleManager {\n    constructor() {\n        this._source = null;\n        this._panel = null;\n        this._handlers = {};\n    }\n    hasHandler(id) {\n        if (this._handlers[id]) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    getHandler(id) {\n        return this._handlers[id];\n    }\n    addHandler(handler) {\n        this._handlers[handler.id] = handler;\n    }\n    /**\n     * The current console panel.\n     */\n    get panel() {\n        return this._panel;\n    }\n    set panel(panel) {\n        if (this.panel === panel) {\n            return;\n        }\n        this._panel = panel;\n        if (panel && !panel.source) {\n            panel.source = this._source;\n        }\n    }\n    /**\n     * The source of events the inspector panel listens for.\n     */\n    get source() {\n        return this._source;\n    }\n    set source(source) {\n        if (this._source === source) {\n            return;\n        }\n        // remove subscriptions\n        if (this._source) {\n            this._source.disposed.disconnect(this._onSourceDisposed, this);\n        }\n        this._source = source;\n        if (this._panel && !this._panel.isDisposed) {\n            this._panel.source = this._source;\n        }\n        // Subscribe to new source\n        if (this._source) {\n            this._source.disposed.connect(this._onSourceDisposed, this);\n        }\n    }\n    _onSourceDisposed() {\n        this._source = null;\n    }\n}\n","import { Token } from '@lumino/coreutils';\nexport const IPipelineConsoleManager = new Token('jupyterlab_extension/logconsole:IPipelineConsoleManager');\n/**\n * The inspector panel token.\n */\nexport const IPipelineConsole = new Token('jupyterlab_extension/logconsole:IPipelineConsole');\n"],"names":[],"sourceRoot":""}